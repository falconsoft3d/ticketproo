from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib.auth import login, authenticate, logout
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth.models import User, Group
from django.contrib import messages
from django.core.paginator import Paginator
from django.db.models import Q, Sum, F, Count
from django.db import models
from django.db.models.functions import TruncHour, TruncDay, TruncMonth
from django.http import HttpResponse, Http404, JsonResponse
from django.utils import timezone
from django.conf import settings
from django.views.decorators.http import require_http_methods
from django.views.decorators.csrf import csrf_exempt
from datetime import datetime, date, timedelta
import os
import json
from django.utils import timezone
from django.conf import settings
from django.views.decorators.http import require_http_methods
from django.views.decorators.csrf import csrf_exempt
from datetime import datetime, date, timedelta
import os
import json

# Imports para PDF
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.pdfgen import canvas
from io import BytesIO

# Imports para OpenAI
try:
    from openai import OpenAI
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False
    print("OpenAI library not available")

from .models import (
    Ticket, TicketAttachment, Category, TicketComment, UserProfile, 
    UserNote, TimeEntry, PublicTimeAccess, Project, Company, SystemConfiguration, Document, UrlManager, WorkOrder, Task,
    DailyTaskSession, DailyTaskItem, ChatRoom, ChatMessage, ContactFormSubmission,
    Opportunity, OpportunityStatus, OpportunityNote, OpportunityStatusHistory,
    Meeting, MeetingAttendee, MeetingQuestion, Contact,
    BlogCategory, BlogPost, BlogComment, AIChatSession, AIChatMessage, Concept,
    Exam, ExamQuestion, ExamAttempt, ExamAnswer, ContactoWeb, PublicDocumentUpload,
    Employee, JobApplicationToken, EmployeePayroll, Agreement, AgreementSignature,
    LandingPage, LandingPageSubmission, WorkOrderTask, WorkOrderTaskTimeEntry, SharedFile, SharedFileDownload,
    Recording, RecordingPlayback, MultipleDocumentation, MultipleDocumentationItem,
    TaskSchedule, ScheduleTask, ScheduleComment, SatisfactionSurvey, ClientProjectAccess, ClientTimeEntry, ShortUrl,
    ProductSet, ProductItem, Precotizador, PrecotizadorExample, PrecotizadorQuote,
    # ...existing code...
)

@login_required
def contact_chart(request):
    """Vista de gráfico de creación de contactos en el tiempo"""
    group_by = request.GET.get('group_by', 'hour')
    if group_by == 'day':
        trunc = TruncDay('contact_date')
        label_fmt = '%d/%m/%Y'
    elif group_by == 'month':
        trunc = TruncMonth('contact_date')
        label_fmt = '%m/%Y'
    else:
        trunc = TruncHour('contact_date')
        label_fmt = '%d/%m/%Y %H:00'

    data = (
        Contact.objects
        .annotate(grp=trunc)
        .values('grp')
        .annotate(count=Count('id'))
        .order_by('grp')
    )
    labels = [item['grp'].strftime(label_fmt) for item in data if item['grp']]
    counts = [item['count'] for item in data]
    
    import json
    context = {
        'labels': json.dumps(labels),
        'counts': json.dumps(counts),
        'group_by': group_by,
        'page_title': 'Gráfico de Creación de Contactos'
    }
    return render(request, 'tickets/contact_chart.html', context)
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib.auth import login, authenticate, logout
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth.models import User, Group
from django.contrib import messages
from django.core.paginator import Paginator
from django.db.models import Q, Sum, F
from django.db import models
from django.http import HttpResponse, Http404, JsonResponse
from django.utils import timezone
from django.conf import settings
from django.views.decorators.http import require_http_methods
from django.views.decorators.csrf import csrf_exempt
from datetime import datetime, date, timedelta
import os
import json

# Imports para OpenAI
try:
    from openai import OpenAI
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False
    print("OpenAI library not available")

from .models import (
    Ticket, TicketAttachment, Category, TicketComment, UserProfile, 
    UserNote, TimeEntry, PublicTimeAccess, Project, Company, SystemConfiguration, Document, UrlManager, WorkOrder, Task,
    DailyTaskSession, DailyTaskItem, ChatRoom, ChatMessage, ContactFormSubmission,
    Opportunity, OpportunityStatus, OpportunityNote, OpportunityStatusHistory,
    Meeting, MeetingAttendee, MeetingQuestion, Contact,
    BlogCategory, BlogPost, BlogComment, AIChatSession, AIChatMessage, Concept,
    Exam, ExamQuestion, ExamAttempt, ExamAnswer, ContactoWeb, PublicDocumentUpload,
    Employee, JobApplicationToken, EmployeePayroll, Agreement, AgreementSignature,
    LandingPage, LandingPageSubmission, WorkOrderTask, WorkOrderTaskTimeEntry, SharedFile, SharedFileDownload,
    Recording, RecordingPlayback, MultipleDocumentation, MultipleDocumentationItem,
    TaskSchedule, ScheduleTask, ScheduleComment, SatisfactionSurvey, ClientProjectAccess, ClientTimeEntry, ShortUrl,
    ProductSet, ProductItem, Precotizador, PrecotizadorExample, PrecotizadorQuote,
    CompanyDocumentation, CompanyDocumentationURL, TermsOfUse, ContactGenerator,
    CompanyRequestGenerator, CompanyRequest, CompanyRequestComment,
    Form, FormQuestion, FormQuestionOption, FormResponse, FormAnswer, FormAIAnalysis, Alcance, License,
    WhatsAppConnection, WhatsAppKeyword, WhatsAppMessage, ImagePrompt,
    AIManager, AIManagerMeeting, AIManagerSummary, CompanyAISummary, UserAIPerformanceEvaluation,
    WebsiteTracker, LegalContract, Asset, AssetHistory,
    AITutor, AITutorProgressReport, AITutorAttachment,
    ExpenseReport, ExpenseItem, ExpenseComment, VideoMeeting, MeetingNote, QuoteGenerator, Procedure
)
from .forms import (
    TicketForm, AgentTicketForm, UserManagementForm, UserEditForm, 
    TicketAttachmentForm, CategoryForm, UserTicketForm, UserTicketEditForm, 
    TicketCommentForm, UserNoteForm, TimeEntryStartForm, TimeEntryEndForm, 
    TimeEntryEditForm, PublicTimeEntryForm, ProjectForm, CompanyForm, SystemConfigurationForm, DocumentForm,
    UrlManagerForm, UrlManagerFilterForm, WorkOrderForm, WorkOrderFilterForm, TaskForm,
    ChatMessageForm, ChatRoomForm, AIChatSessionForm, AIChatMessageForm, ConceptForm,
    EmployeeHiringOpinionForm, EmployeePayrollForm, AgreementForm, AgreementSignatureForm, AgreementPublicForm,
    LandingPageForm, LandingPageSubmissionForm, PublicCompanyTicketForm, WorkOrderTaskForm, 
    WorkOrderTaskTimeEntryForm, WorkOrderTaskBulkForm, SharedFileForm, PublicSharedFileForm,
    TaskScheduleForm, ScheduleTaskForm, ScheduleCommentForm, ClientProjectAccessForm, ClientTimeEntryForm,
    ProductSetForm, ProductItemForm, ProductItemFormSet, PrecotizadorForm, PrecotizadorExampleForm, 
    PrecotizadorExampleFormSet, PrecotizadorQuoteForm, CompanyDocumentationForm, CompanyDocumentationURLForm,
    CompanyDocumentationURLFormSet, TermsOfUseForm, ContactGeneratorForm, PublicContactForm,
    CompanyRequestGeneratorForm, PublicCompanyRequestForm, FormForm, FormQuestionForm,
    FormQuestionOptionForm, PublicFormResponseForm, AssetForm, AssetAssignForm, AssetFilterForm,
    AITutorForm, AITutorProgressReportForm, AITutorAttachmentForm, AITutorFilterForm,
    ExpenseReportForm, ExpenseItemForm, ExpenseCommentForm, ExpenseReportFilterForm,
    VideoMeetingForm, MeetingTranscriptionForm, MeetingFilterForm, QuoteGeneratorForm, AbsenceTypeForm
)
from .utils import is_agent, is_regular_user, is_teacher, can_manage_courses, get_user_role, assign_user_to_group

def home_view(request):
    """Vista para la página de inicio de TicketProo - accesible para todos"""
    # Estadísticas generales del sistema
    total_tickets = Ticket.objects.count()
    total_users = Ticket.objects.values('created_by').distinct().count()
    
    # Estadísticas por estado si el usuario está autenticado
    user_tickets_count = 0
    user_role = None
    tickets_by_status = {}
    
    if request.user.is_authenticated:
        user_role = get_user_role(request.user)
        
        if is_agent(request.user):
            # Para agentes: estadísticas de todos los tickets
            tickets_by_status = {
                'open': Ticket.objects.filter(status='open').count(),
                'in_progress': Ticket.objects.filter(status='in_progress').count(),
                'resolved': Ticket.objects.filter(status='resolved').count(),
                'closed': Ticket.objects.filter(status='closed').count(),
            }
            user_tickets_count = Ticket.objects.count()
        else:
            # Para usuarios regulares: solo sus tickets
            user_tickets = Ticket.objects.filter(created_by=request.user)
            tickets_by_status = {
                'open': user_tickets.filter(status='open').count(),
                'in_progress': user_tickets.filter(status='in_progress').count(),
                'resolved': user_tickets.filter(status='resolved').count(),
                'closed': user_tickets.filter(status='closed').count(),
            }
            user_tickets_count = user_tickets.count()
    
    # Obtener conceptos activos para mostrar en el home
    concepts = Concept.objects.filter(is_active=True)[:10]  # Máximo 10 conceptos
    
    # Obtener alcances públicos
    alcances = Alcance.objects.filter(publico=True).order_by('-creado_en')[:8]
    
    # Obtener los últimos 4 artículos del blog
    from .models import BlogPost
    latest_blog_posts = BlogPost.objects.filter(
        status='published'
    ).order_by('-created_at')[:4]
    
    context = {
        'total_tickets': total_tickets,
        'total_users': total_users,
        'user_tickets_count': user_tickets_count,
        'user_role': user_role,
        'tickets_by_status': tickets_by_status,
        'is_authenticated': request.user.is_authenticated,
        'concepts': concepts,
        'alcances': alcances,
        'latest_blog_posts': latest_blog_posts,
    }
    return render(request, 'tickets/home.html', context)

def register_view(request):
    """Vista para registro de nuevos usuarios"""
    # Verificar si el registro está habilitado en la configuración
    config = SystemConfiguration.get_config()
    
    if not config.allow_user_registration:
        messages.error(request, 'El registro de nuevos usuarios está deshabilitado. Contacta a un administrador.')
        return redirect('login')
    
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            username = form.cleaned_data.get('username')
            
            # Asignar automáticamente al grupo de Usuarios
            assign_user_to_group(user, 'Usuarios')
            
            messages.success(request, f'Cuenta creada para {username}. Ya puedes iniciar sesión.')
            return redirect('login')
    else:
        form = UserCreationForm()
    return render(request, 'registration/register.html', {'form': form})

@login_required
def dashboard_view(request):
    """Vista principal del dashboard de TicketProo"""
    user_role = get_user_role(request.user)
    
    if is_agent(request.user):
        # Estadísticas para agentes (todos los tickets)
        all_tickets = Ticket.objects.all()
        total_tickets = all_tickets.count()
        open_tickets = all_tickets.filter(status='open').count()
        in_progress_tickets = all_tickets.filter(status='in_progress').count()
        resolved_tickets = all_tickets.filter(status='resolved').count()
        recent_tickets = all_tickets[:5]
        
        # Estadísticas adicionales para agentes
        unassigned_tickets = all_tickets.filter(assigned_to__isnull=True).count()
        my_assigned_tickets = all_tickets.filter(assigned_to=request.user).count()
        
        # Obtener horas diarias
        daily_hours = 0
        try:
            daily_hours = request.user.userprofile.get_daily_hours()
        except AttributeError:
            # Crear UserProfile si no existe
            from tickets.models import UserProfile
            profile, created = UserProfile.objects.get_or_create(user=request.user)
            daily_hours = profile.get_daily_hours()
        
        # Órdenes de trabajo pendientes de aprobación (solo primeras 5)
        pending_work_orders = WorkOrder.objects.filter(status='draft').order_by('-created_at')[:5]
        
        context = {
            'total_tickets': total_tickets,
            'open_tickets': open_tickets,
            'in_progress_tickets': in_progress_tickets,
            'resolved_tickets': resolved_tickets,
            'recent_tickets': recent_tickets,
            'unassigned_tickets': unassigned_tickets,
            'my_assigned_tickets': my_assigned_tickets,
            'pending_work_orders': pending_work_orders,
            'user_role': user_role,
            'is_agent': True,
            'daily_hours': daily_hours,
        }
        
        # Agregar conceptos activos
        concepts = Concept.objects.filter(is_active=True)[:10]
        context['concepts'] = concepts
        
        # Agregar URLs principales
        principal_urls = UrlManager.objects.filter(is_principal=True, is_active=True).order_by('title')[:10]
        context['principal_urls'] = principal_urls
        
        # Estadísticas de gastos para agentes
        expense_reports = ExpenseReport.objects.all()
        context.update({
            'expense_stats': {
                'total_reports': expense_reports.count(),
                'pending_approval': expense_reports.filter(status='submitted').count(),
                'approved_reports': expense_reports.filter(status='approved').count(),
                'total_pending_amount': expense_reports.filter(status__in=['submitted', 'approved']).aggregate(
                    total=Sum('expense_items__amount'))['total'] or 0,
            }
        })
        
        # Reuniones de video recientes para agentes (solo de empresas existentes)
        recent_video_meetings = VideoMeeting.objects.filter(company__isnull=False).order_by('-created_at')[:5]
        context['recent_video_meetings'] = recent_video_meetings
    else:
        # Estadísticas para usuarios regulares (sus tickets + tickets de empresa + proyectos)
        user_projects = request.user.assigned_projects.all()
        user_company = None
        
        # Obtener empresa del usuario si tiene perfil
        try:
            user_company = request.user.profile.company
        except:
            pass
        
        # Construir query base
        query_conditions = Q(created_by=request.user)  # Sus propios tickets
        
        # Agregar tickets de proyectos asignados
        if user_projects.exists():
            query_conditions |= Q(project__in=user_projects)
        
        # Agregar tickets de la empresa del usuario
        if user_company:
            query_conditions |= Q(company=user_company)
        
        user_tickets = Ticket.objects.filter(query_conditions).distinct()
        total_tickets = user_tickets.count()
        open_tickets = user_tickets.filter(status='open').count()
        in_progress_tickets = user_tickets.filter(status='in_progress').count()
        resolved_tickets = user_tickets.filter(status='resolved').count()
        recent_tickets = user_tickets.order_by('-created_at')[:5]
        
        # Estadísticas adicionales para mostrar el contexto
        own_tickets = Ticket.objects.filter(created_by=request.user).count()
        company_tickets = 0
        if user_company:
            company_tickets = Ticket.objects.filter(company=user_company).exclude(created_by=request.user).count()
        
        # Obtener horas diarias
        daily_hours = 0
        try:
            daily_hours = request.user.userprofile.get_daily_hours()
        except AttributeError:
            # Crear UserProfile si no existe
            from tickets.models import UserProfile
            profile, created = UserProfile.objects.get_or_create(user=request.user)
            daily_hours = profile.get_daily_hours()
        
        context = {
            'total_tickets': total_tickets,
            'open_tickets': open_tickets,
            'in_progress_tickets': in_progress_tickets,
            'resolved_tickets': resolved_tickets,
            'recent_tickets': recent_tickets,
            'own_tickets': own_tickets,
            'company_tickets': company_tickets,
            'user_company': user_company,
            'user_role': user_role,
            'is_agent': False,
            'daily_hours': daily_hours,
        }
        
        # Agregar URLs principales
        principal_urls = UrlManager.objects.filter(is_principal=True, is_active=True).order_by('title')[:10]
        context['principal_urls'] = principal_urls
        
        # Estadísticas de gastos para usuarios normales (solo sus propios gastos)
        user_expense_reports = ExpenseReport.objects.filter(employee=request.user)
        context.update({
            'expense_stats': {
                'total_reports': user_expense_reports.count(),
                'draft_reports': user_expense_reports.filter(status='draft').count(),
                'pending_reports': user_expense_reports.filter(status='submitted').count(),
                'approved_reports': user_expense_reports.filter(status='approved').count(),
                'my_total_amount': user_expense_reports.aggregate(
                    total=Sum('expense_items__amount'))['total'] or 0,
            }
        })
        
        # Reuniones de video recientes para usuarios normales (solo de su empresa)
        video_meetings_query = Q(organizer=request.user)  # Sus propias reuniones
        if user_company:
            # Agregar reuniones de su empresa (usando el campo company directamente)
            video_meetings_query |= Q(company=user_company)
        
        recent_video_meetings = VideoMeeting.objects.filter(video_meetings_query).distinct().order_by('-created_at')[:5]
        context['recent_video_meetings'] = recent_video_meetings
    
    # Agregar citas activas para mostrar en el dashboard
    user_company = None
    try:
        user_company = request.user.profile.company
    except:
        pass
    
    if is_agent(request.user):
        # Agentes ven todas las citas activas
        active_quotes = QuoteGenerator.objects.filter(is_active=True).order_by('-created_at')
    else:
        # Usuarios regulares ven solo las de su empresa
        if user_company:
            active_quotes = QuoteGenerator.objects.filter(
                models.Q(created_by=request.user) | models.Q(company=user_company),
                is_active=True
            ).distinct().order_by('-created_at')
        else:
            active_quotes = QuoteGenerator.objects.filter(created_by=request.user, is_active=True).order_by('-created_at')
    
    # Obtener todas las citas de todos los generadores activos
    all_quotes = []
    for generator in active_quotes:
        quotes_list = generator.get_quotes_list()
        for quote in quotes_list:
            all_quotes.append({
                'quote': quote.get('quote', ''),
                'author': quote.get('author', 'Anónimo'),
                'generator_title': generator.title
            })
    
    import json
    context['dashboard_quotes'] = all_quotes
    context['dashboard_quotes_json'] = json.dumps(all_quotes, ensure_ascii=False)
    
    # Agregar notas al dashboard según nueva lógica:
    # 1. Notas sin empresa: visibles para todos los usuarios
    # 2. Notas con empresa: solo visibles para usuarios de esa empresa específica
    user_company = None
    try:
        user_company = request.user.profile.company
    except:
        pass
    
    # Construir query para notas recientes
    notes_query = models.Q()
    
    # 1. Siempre incluir notas sin empresa (company=None) que no sean privadas para mostrar a todos
    notes_query |= models.Q(company__isnull=True, is_private=False)
    
    # 2. Si el usuario tiene empresa, incluir notas públicas de su empresa
    if user_company:
        notes_query |= models.Q(company=user_company, is_private=False)
    
    # 3. Siempre incluir las notas propias del usuario (privadas y públicas)
    notes_query |= models.Q(created_by=request.user)
    
    # Aplicar el query y obtener las notas recientes
    recent_notes = UserNote.objects.filter(notes_query).select_related(
        'user', 'created_by', 'company'
    ).distinct().order_by('-created_at')[:5]
    
    context['recent_notes'] = recent_notes
    
    # Agregar documentos al dashboard según nueva lógica:
    # 1. Documentos sin empresa: visibles para todos los usuarios
    # 2. Documentos con empresa: solo visibles para usuarios de esa empresa específica
    documents_query = models.Q()
    
    # 1. Siempre incluir documentos sin empresa (company=None) para mostrar a todos
    documents_query |= models.Q(company__isnull=True)
    
    # 2. Si el usuario tiene empresa, incluir documentos de su empresa
    if user_company:
        documents_query |= models.Q(company=user_company)
    
    # Aplicar el query y obtener los documentos recientes
    recent_documents = Document.objects.filter(documents_query).select_related(
        'created_by', 'company'
    ).distinct().order_by('-created_at')[:5]
    
    context['recent_documents'] = recent_documents
    
    # Agregar procedimientos al dashboard según nueva lógica:
    # 1. Procedimientos sin empresa: visibles para todos los usuarios
    # 2. Procedimientos con empresa: solo visibles para usuarios de esa empresa específica
    procedures_query = models.Q(is_active=True)  # Solo procedimientos activos
    
    # Filtrar por empresa
    if user_company:
        # Si el usuario tiene empresa, mostrar procedimientos sin empresa Y procedimientos de su empresa
        procedures_query &= models.Q(
            models.Q(company__isnull=True) | models.Q(company=user_company)
        )
    else:
        # Si el usuario no tiene empresa, solo mostrar procedimientos sin empresa
        procedures_query &= models.Q(company__isnull=True)
    
    # Aplicar el query y obtener los procedimientos recientes
    user_procedures = Procedure.objects.filter(procedures_query).select_related(
        'created_by', 'company'
    ).distinct().order_by('sequence', '-created_at')[:10]
    
    context['user_procedures'] = user_procedures
    
    return render(request, 'tickets/dashboard.html', context)

@login_required
def ticket_chart(request):
    """Vista de gráfico de creación de tickets en el tiempo con filtros"""
    # Obtener los tickets según permisos del usuario
    if is_agent(request.user):
        tickets = Ticket.objects.all()
    else:
        user_projects = request.user.assigned_projects.all()
        user_company = None
        
        try:
            user_company = request.user.profile.company
        except:
            pass
        
        query_conditions = Q(created_by=request.user)
        
        if user_projects.exists():
            query_conditions |= Q(project__in=user_projects)
        
        if user_company:
            query_conditions |= Q(company=user_company)
        
        tickets = Ticket.objects.filter(query_conditions).distinct()
    
    # Aplicar filtros de búsqueda
    status_filter = request.GET.get('status')
    priority_filter = request.GET.get('priority')
    search = request.GET.get('search')
    assigned_filter = request.GET.get('assigned_to')
    company_filter = request.GET.get('company')
    
    if status_filter:
        tickets = tickets.filter(status=status_filter)
    
    if priority_filter:
        tickets = tickets.filter(priority=priority_filter)
    
    if company_filter:
        try:
            from .models import Company
            company = Company.objects.get(pk=company_filter)
            tickets = tickets.filter(company=company)
        except (Company.DoesNotExist, ValueError):
            pass
    
    if search:
        tickets = tickets.filter(
            Q(title__icontains=search) | 
            Q(description__icontains=search)
        )
    
    if is_agent(request.user) and assigned_filter:
        if assigned_filter == 'unassigned':
            tickets = tickets.filter(assigned_to__isnull=True)
        elif assigned_filter == 'me':
            tickets = tickets.filter(assigned_to=request.user)
    
    # Agrupar por tiempo
    group_by = request.GET.get('group_by', 'hour')
    if group_by == 'day':
        trunc = TruncDay('created_at')
        label_fmt = '%d/%m/%Y'
    elif group_by == 'month':
        trunc = TruncMonth('created_at')
        label_fmt = '%m/%Y'
    else:
        trunc = TruncHour('created_at')
        label_fmt = '%d/%m/%Y %H:00'

    data = (
        tickets
        .annotate(grp=trunc)
        .values('grp')
        .annotate(count=Count('id'))
        .order_by('grp')
    )
    labels = [item['grp'].strftime(label_fmt) for item in data if item['grp']]
    counts = [item['count'] for item in data]
    
    import json
    context = {
        'labels': json.dumps(labels),
        'counts': json.dumps(counts),
        'group_by': group_by,
        'page_title': 'Gráfico de Creación de Tickets'
    }
    return render(request, 'tickets/ticket_chart.html', context)

@login_required
def ticket_export_excel(request):
    """Exportar tickets a Excel"""
    import openpyxl
    from django.http import HttpResponse
    from openpyxl.styles import Font, PatternFill
    
    # Obtener tickets según el rol del usuario
    if is_agent(request.user):
        tickets = Ticket.objects.all()
    else:
        user_projects = request.user.assigned_projects.all()
        user_company = None
        try:
            user_company = request.user.profile.company
        except:
            pass
        
        query_conditions = Q(created_by=request.user)
        if user_projects.exists():
            query_conditions |= Q(project__in=user_projects)
        if user_company:
            query_conditions |= Q(company=user_company)
        
        tickets = Ticket.objects.filter(query_conditions).distinct()
    
    # Aplicar filtros de la URL
    status_filter = request.GET.get('status')
    if status_filter:
        tickets = tickets.filter(status=status_filter)
    
    priority_filter = request.GET.get('priority')
    if priority_filter:
        tickets = tickets.filter(priority=priority_filter)
    
    search = request.GET.get('search')
    if search:
        tickets = tickets.filter(
            Q(title__icontains=search) | 
            Q(description__icontains=search)
        )
    
    # Crear workbook de Excel
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Tickets"
    
    # Definir headers
    headers = ['ID', 'Título', 'Descripción', 'Estado', 'Prioridad', 'Categoría', 'Empresa', 'Creado por', 'Asignado a', 'Fecha de creación']
    
    # Aplicar estilo a headers
    header_font = Font(bold=True, color="FFFFFF")
    header_fill = PatternFill(start_color="4472C4", end_color="4472C4", fill_type="solid")
    
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=1, column=col, value=header)
        cell.font = header_font
        cell.fill = header_fill
    
    # Agregar datos
    for row, ticket in enumerate(tickets.order_by('-created_at'), 2):
        ws.cell(row=row, column=1, value=ticket.id)
        ws.cell(row=row, column=2, value=ticket.title)
        ws.cell(row=row, column=3, value=ticket.description[:200] + "..." if len(ticket.description) > 200 else ticket.description)
        ws.cell(row=row, column=4, value=ticket.get_status_display())
        ws.cell(row=row, column=5, value=ticket.get_priority_display())
        ws.cell(row=row, column=6, value=ticket.category.name if ticket.category else "Sin categoría")
        ws.cell(row=row, column=7, value=ticket.company.name if ticket.company else "Sin empresa")
        ws.cell(row=row, column=8, value=ticket.created_by.get_full_name() or ticket.created_by.username)
        ws.cell(row=row, column=9, value=ticket.assigned_to.get_full_name() if ticket.assigned_to else "Sin asignar")
        ws.cell(row=row, column=10, value=ticket.created_at.strftime('%d/%m/%Y %H:%M'))
    
    # Ajustar ancho de columnas
    for column in ws.columns:
        max_length = 0
        column_letter = column[0].column_letter
        for cell in column:
            try:
                if len(str(cell.value)) > max_length:
                    max_length = len(str(cell.value))
            except:
                pass
        adjusted_width = min(max_length + 2, 50)
        ws.column_dimensions[column_letter].width = adjusted_width
    
    # Preparar respuesta
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'attachment; filename="tickets_{timezone.now().strftime("%Y%m%d_%H%M%S")}.xlsx"'
    
    wb.save(response)
    return response

@login_required
def ticket_list_view(request):
    """Vista para listar tickets según el rol del usuario"""
    if is_agent(request.user):
        # Los agentes ven todos los tickets
        tickets = Ticket.objects.all()
    else:
        # Los usuarios regulares ven sus propios tickets Y tickets de proyectos asignados Y tickets de su empresa
        user_projects = request.user.assigned_projects.all()
        user_company = None
        
        # Obtener empresa del usuario si tiene perfil
        try:
            user_company = request.user.profile.company
        except:
            pass
        
        # Construir query base
        query_conditions = Q(created_by=request.user)  # Sus propios tickets
        
        # Agregar tickets de proyectos asignados
        if user_projects.exists():
            query_conditions |= Q(project__in=user_projects)
        
        # Agregar tickets de la empresa del usuario
        if user_company:
            query_conditions |= Q(company=user_company)
        
        tickets = Ticket.objects.filter(query_conditions).distinct()
    
    # Filtros
    status_filter = request.GET.get('status')
    priority_filter = request.GET.get('priority')
    search = request.GET.get('search')
    assigned_filter = request.GET.get('assigned_to')  # Nuevo filtro para agentes
    company_filter = request.GET.get('company')  # Nuevo filtro por empresa
    
    if status_filter:
        tickets = tickets.filter(status=status_filter)
    
    if priority_filter:
        tickets = tickets.filter(priority=priority_filter)
    
    if company_filter:
        try:
            from .models import Company
            company = Company.objects.get(pk=company_filter)
            tickets = tickets.filter(company=company)
        except (Company.DoesNotExist, ValueError):
            pass
    
    if search:
        tickets = tickets.filter(
            Q(title__icontains=search) | 
            Q(description__icontains=search)
        )
    
    # Filtro adicional para agentes
    if is_agent(request.user) and assigned_filter:
        if assigned_filter == 'unassigned':
            tickets = tickets.filter(assigned_to__isnull=True)
        elif assigned_filter == 'me':
            tickets = tickets.filter(assigned_to=request.user)
    
    # Paginación
    paginator = Paginator(tickets, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Obtener todas las empresas para el filtro
    from .models import Company
    companies = Company.objects.all().order_by('name')
    
    context = {
        'page_obj': page_obj,
        'status_filter': status_filter,
        'priority_filter': priority_filter,
        'search': search,
        'assigned_filter': assigned_filter,
        'company_filter': company_filter,
        'status_choices': Ticket.STATUS_CHOICES,
        'priority_choices': Ticket.PRIORITY_CHOICES,
        'companies': companies,
        'is_agent': is_agent(request.user),
        'user_role': get_user_role(request.user),
    }
    return render(request, 'tickets/ticket_list.html', context)

@login_required
def ticket_create_view(request):
    """Vista para crear un nuevo ticket"""
    # Usar formulario apropiado según el rol
    FormClass = AgentTicketForm if is_agent(request.user) else UserTicketForm
    
    if request.method == 'POST':
        form = FormClass(request.POST)
        if form.is_valid():
            ticket = form.save(commit=False)
            ticket.created_by = request.user
            # Los usuarios regulares siempre crean tickets con estado "open"
            if not is_agent(request.user):
                ticket.status = 'open'
            ticket.save()
            messages.success(request, 'Ticket creado exitosamente.')
            return redirect('ticket_detail', pk=ticket.pk)
    else:
        form = FormClass()
    
    context = {
        'form': form,
        'is_agent': is_agent(request.user),
        'user_role': get_user_role(request.user),
    }
    
    return render(request, 'tickets/ticket_create.html', context)

@login_required
def ticket_detail_view(request, pk):
    """Vista para ver los detalles de un ticket"""
    if is_agent(request.user):
        # Los agentes pueden ver cualquier ticket
        ticket = get_object_or_404(Ticket, pk=pk)
    else:
        # Los usuarios pueden ver sus propios tickets O tickets de su empresa O tickets de proyectos asignados
        user_projects = request.user.assigned_projects.all()
        user_company = None
        
        # Obtener empresa del usuario si tiene perfil
        try:
            user_company = request.user.profile.company
        except:
            pass
        
        # Construir query de acceso
        query_conditions = Q(created_by=request.user)  # Sus propios tickets
        
        # Agregar tickets de proyectos asignados
        if user_projects.exists():
            query_conditions |= Q(project__in=user_projects)
        
        # Agregar tickets de la empresa del usuario
        if user_company:
            query_conditions |= Q(company=user_company)
        
        ticket = get_object_or_404(Ticket, pk=pk)
        
        # Verificar que el usuario tenga acceso al ticket
        if not Ticket.objects.filter(pk=pk).filter(query_conditions).exists():
            messages.error(request, 'No tienes permisos para ver este ticket.')
            return redirect('ticket_list')
    
    # Manejar autoasignación para agentes
    if request.method == 'POST' and 'assign_to_me' in request.POST and is_agent(request.user):
        ticket.assigned_to = request.user
        ticket.save()
        messages.success(request, f'Te has asignado el ticket #{ticket.pk}.')
        return redirect('ticket_detail', pk=pk)
    
    # Manejar activar compartir público (solo agentes)
    if request.method == 'POST' and 'enable_public_share' in request.POST and is_agent(request.user):
        ticket.is_public_shareable = True
        ticket.save()
        messages.success(request, 'Compartir público activado. Ahora puedes compartir este ticket mediante un enlace.')
        return redirect('ticket_detail', pk=pk)
    
    # Manejar desactivar compartir público (solo agentes)
    if request.method == 'POST' and 'disable_public_share' in request.POST and is_agent(request.user):
        ticket.is_public_shareable = False
        ticket.save()
        messages.warning(request, 'Compartir público desactivado. El enlace ya no será accesible.')
        return redirect('ticket_detail', pk=pk)
    
    # Manejar regenerar token (solo agentes)
    if request.method == 'POST' and 'regenerate_token' in request.POST and is_agent(request.user):
        ticket.regenerate_public_token()
        messages.info(request, 'Enlace público regenerado. El enlace anterior ya no es válido.')
        return redirect('ticket_detail', pk=pk)
    
    # Formulario para agregar comentarios
    comment_form = TicketCommentForm()
    if request.method == 'POST' and 'add_comment' in request.POST:
        comment_form = TicketCommentForm(request.POST)
        if comment_form.is_valid():
            comment = comment_form.save(commit=False)
            comment.ticket = ticket
            comment.user = request.user
            comment.save()
            messages.success(request, 'Comentario agregado exitosamente.')
            return redirect('ticket_detail', pk=pk)
    
    # Formulario para subir adjuntos
    attachment_form = TicketAttachmentForm()
    if request.method == 'POST' and 'upload_attachment' in request.POST:
        attachment_form = TicketAttachmentForm(request.POST, request.FILES)
        if attachment_form.is_valid():
            attachment = attachment_form.save(commit=False)
            attachment.ticket = ticket
            attachment.uploaded_by = request.user
            attachment.original_filename = attachment.file.name
            attachment.file_size = attachment.file.size
            attachment.save()
            messages.success(request, 'Adjunto subido exitosamente.')
            return redirect('ticket_detail', pk=pk)
    
    # Obtener comentarios del ticket
    comments = ticket.comments.all().order_by('created_at')
    
    # Obtener items TODO del ticket
    todo_items = ticket.todo_items.all()
    
    context = {
        'ticket': ticket,
        'comments': comments,
        'comment_form': comment_form,
        'attachment_form': attachment_form,
        'is_agent': is_agent(request.user),
        'user_role': get_user_role(request.user),
        'todo_items': todo_items,
    }
    return render(request, 'tickets/ticket_detail.html', context)

@login_required
def ticket_edit_view(request, pk):
    """Vista para editar un ticket"""
    if is_agent(request.user):
        # Los agentes pueden editar cualquier ticket
        ticket = get_object_or_404(Ticket, pk=pk)
        FormClass = AgentTicketForm
    else:
        # Los usuarios pueden editar sus propios tickets O tickets de su empresa O tickets de proyectos asignados
        user_projects = request.user.assigned_projects.all()
        user_company = None
        
        # Obtener empresa del usuario si tiene perfil
        try:
            user_company = request.user.profile.company
        except:
            pass
        
        # Construir query de acceso
        query_conditions = Q(created_by=request.user)  # Sus propios tickets
        
        # Agregar tickets de proyectos asignados
        if user_projects.exists():
            query_conditions |= Q(project__in=user_projects)
        
        # Agregar tickets de la empresa del usuario
        if user_company:
            query_conditions |= Q(company=user_company)
        
        ticket = get_object_or_404(Ticket, pk=pk)
        
        # Verificar que el usuario tenga acceso al ticket
        if not Ticket.objects.filter(pk=pk).filter(query_conditions).exists():
            messages.error(request, 'No tienes permisos para editar este ticket.')
            return redirect('ticket_list')
        
        FormClass = UserTicketEditForm
    
    if request.method == 'POST':
        form = FormClass(request.POST, instance=ticket)
        if form.is_valid():
            form.save()
            messages.success(request, 'Ticket actualizado exitosamente.')
            return redirect('ticket_detail', pk=ticket.pk)
    else:
        form = FormClass(instance=ticket)
    
    context = {
        'form': form, 
        'ticket': ticket,
        'is_agent': is_agent(request.user),
        'user_role': get_user_role(request.user),
    }
    return render(request, 'tickets/ticket_edit.html', context)

@login_required
def ticket_delete_view(request, pk):
    """Vista para eliminar un ticket"""
    if is_agent(request.user):
        # Los agentes pueden eliminar cualquier ticket
        ticket = get_object_or_404(Ticket, pk=pk)
    else:
        # Los usuarios solo pueden eliminar sus propios tickets
        ticket = get_object_or_404(Ticket, pk=pk, created_by=request.user)
    
    if request.method == 'POST':
        ticket.delete()
        messages.success(request, 'Ticket eliminado exitosamente.')
        return redirect('ticket_list')
    
    context = {
        'ticket': ticket,
        'is_agent': is_agent(request.user),
        'user_role': get_user_role(request.user),
    }
    return render(request, 'tickets/ticket_delete.html', context)


@login_required
def ticket_approve_view(request, pk):
    """Vista para aprobar/desaprobar un ticket"""
    # Verificar acceso al ticket
    if is_agent(request.user):
        # Los agentes pueden aprobar cualquier ticket
        ticket = get_object_or_404(Ticket, pk=pk)
    else:
        # Los usuarios pueden aprobar tickets donde están involucrados
        user_company = getattr(request.user.profile, 'company', None) if hasattr(request.user, 'profile') else None
        user_projects = Project.objects.filter(assigned_users=request.user)
        
        query_conditions = Q(created_by=request.user)
        
        if user_projects.exists():
            query_conditions |= Q(project__in=user_projects)
        
        if user_company:
            query_conditions |= Q(company=user_company)
        
        ticket = get_object_or_404(Ticket, pk=pk)
        
        # Verificar que el usuario tenga acceso al ticket
        if not Ticket.objects.filter(pk=pk).filter(query_conditions).exists():
            messages.error(request, 'No tienes permisos para aprobar este ticket.')
            return redirect('ticket_list')
    
    if request.method == 'POST':
        action = request.POST.get('action')
        
        if action == 'approve':
            if not ticket.is_approved:
                ticket.approve_ticket(request.user)
                messages.success(request, f'Ticket #{ticket.ticket_number} aprobado exitosamente.')
            else:
                messages.info(request, 'Este ticket ya estaba aprobado.')
        
        elif action == 'unapprove':
            if ticket.is_approved:
                ticket.unapprove_ticket()
                messages.success(request, f'Aprobación del ticket #{ticket.ticket_number} removida.')
            else:
                messages.info(request, 'Este ticket no estaba aprobado.')
        
        return redirect('ticket_detail', pk=ticket.pk)
    
    # Si no es POST, redirigir al detalle del ticket
    return redirect('ticket_detail', pk=ticket.pk)

@login_required
def logout_view(request):
    """Vista personalizada para logout"""
    logout(request)
    messages.info(request, 'Has cerrado sesión exitosamente.')
    return redirect('home')

# ========== VISTAS DE GESTIÓN DE USUARIOS ==========

def agent_required(user):
    """Decorador para verificar si el usuario es agente"""
    return is_agent(user)

def course_manager_required(user):
    """Decorador para verificar si el usuario puede gestionar cursos (Agente o Profesor)"""
    return can_manage_courses(user)

@login_required
@user_passes_test(agent_required, login_url='dashboard')
def user_management_view(request):
    """Vista para listar todos los usuarios (solo para agentes)"""
    users = User.objects.select_related('profile').prefetch_related('groups').all().order_by('username')
    
    # Filtros
    role_filter = request.GET.get('role')
    status_filter = request.GET.get('status')
    search = request.GET.get('search')
    
    if role_filter:
        if role_filter == 'agents':
            users = users.filter(groups__name='Agentes')
        elif role_filter == 'users':
            users = users.filter(groups__name='Usuarios')
    
    if status_filter:
        if status_filter == 'active':
            users = users.filter(is_active=True)
        elif status_filter == 'inactive':
            users = users.filter(is_active=False)
    
    if search:
        users = users.filter(
            Q(username__icontains=search) |
            Q(first_name__icontains=search) |
            Q(last_name__icontains=search) |
            Q(email__icontains=search)
        )
    
    # Agregar información de actividad actual para cada usuario
    for user in users:
        # Buscar si tiene una jornada activa (sin fecha de salida)
        current_entry = TimeEntry.objects.filter(
            user=user,
            fecha_salida__isnull=True
        ).select_related('project', 'ticket', 'work_order').first()
        
        user.current_entry = current_entry
        user.is_working = current_entry is not None
        
        # Calcular estadísticas de tiempo del usuario de manera simple
        from django.utils import timezone
        from datetime import timedelta
        
        # Tiempo total trabajado
        completed_entries = TimeEntry.objects.filter(
            user=user,
            fecha_salida__isnull=False
        )
        
        total_seconds = 0
        for entry in completed_entries:
            duration = entry.fecha_salida - entry.fecha_entrada
            total_seconds += duration.total_seconds()
        
        user.total_hours = round(total_seconds / 3600, 1)
        
        # Tiempo trabajado este mes
        now = timezone.now()
        start_of_month = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        
        month_entries = TimeEntry.objects.filter(
            user=user,
            fecha_entrada__gte=start_of_month,
            fecha_salida__isnull=False
        )
        
        month_seconds = 0
        for entry in month_entries:
            duration = entry.fecha_salida - entry.fecha_entrada
            month_seconds += duration.total_seconds()
        
        user.month_hours = round(month_seconds / 3600, 1)
        
        # Tiempo trabajado esta semana
        start_of_week = now - timedelta(days=now.weekday())
        start_of_week = start_of_week.replace(hour=0, minute=0, second=0, microsecond=0)
        
        week_entries = TimeEntry.objects.filter(
            user=user,
            fecha_entrada__gte=start_of_week,
            fecha_salida__isnull=False
        )
        
        week_seconds = 0
        for entry in week_entries:
            duration = entry.fecha_salida - entry.fecha_entrada
            week_seconds += duration.total_seconds()
        
        user.week_hours = round(week_seconds / 3600, 1)
        
        # Tiempo trabajado hoy
        today = now.date()
        today_entries = TimeEntry.objects.filter(
            user=user,
            fecha_entrada__date=today,
            fecha_salida__isnull=False
        )
        
        today_seconds = 0
        for entry in today_entries:
            duration = entry.fecha_salida - entry.fecha_entrada
            today_seconds += duration.total_seconds()
        
        user.today_hours = round(today_seconds / 3600, 1)
    
    # Paginación
    paginator = Paginator(users, 15)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_obj': page_obj,
        'role_filter': role_filter,
        'status_filter': status_filter,
        'search': search,
    }
    return render(request, 'tickets/user_management.html', context)

@login_required
@user_passes_test(agent_required, login_url='dashboard')
def user_create_view(request):
    """Vista para crear nuevos usuarios (solo para agentes)"""
    if request.method == 'POST':
        form = UserManagementForm(request.POST)
        if form.is_valid():
            user = form.save()
            role = form.cleaned_data['role']
            messages.success(request, f'Usuario "{user.username}" creado exitosamente como {role[:-1]}.')
            return redirect('user_management')
    else:
        form = UserManagementForm()
    
    return render(request, 'tickets/user_create.html', {'form': form})

@login_required
@user_passes_test(agent_required, login_url='dashboard')
def user_edit_view(request, user_id):
    """Vista para editar usuarios existentes (solo para agentes)"""
    user_to_edit = get_object_or_404(User, pk=user_id)
    
    if request.method == 'POST':
        form = UserEditForm(request.POST, instance=user_to_edit)
        if form.is_valid():
            user = form.save()
            
            # Actualizar rol del usuario
            new_role = form.cleaned_data['role']
            user.groups.clear()  # Remover todos los grupos
            try:
                group = Group.objects.get(name=new_role)
                user.groups.add(group)
            except Group.DoesNotExist:
                pass
            
            messages.success(request, f'Usuario "{user.username}" actualizado exitosamente.')
            return redirect('user_management')
    else:
        form = UserEditForm(instance=user_to_edit)
    
    context = {
        'form': form,
        'user_to_edit': user_to_edit,
    }
    
    # Agregar información de acceso público si existe
    try:
        public_access = user_to_edit.public_time_access
        context['public_access'] = public_access
        if public_access.is_active:
            context['public_url'] = public_access.public_url
    except PublicTimeAccess.DoesNotExist:
        context['public_access'] = None
    
    return render(request, 'tickets/user_edit.html', context)

@login_required
@user_passes_test(agent_required, login_url='dashboard')
def user_toggle_status_view(request, user_id):
    """Vista para activar/desactivar usuarios (solo para agentes)"""
    user_to_toggle = get_object_or_404(User, pk=user_id)
    
    if user_to_toggle == request.user:
        messages.error(request, 'No puedes desactivar tu propia cuenta.')
    else:
        user_to_toggle.is_active = not user_to_toggle.is_active
        user_to_toggle.save()
        
        status = "activado" if user_to_toggle.is_active else "desactivado"
        messages.success(request, f'Usuario "{user_to_toggle.username}" {status} exitosamente.')
    
    return redirect('user_management')


@login_required
def download_attachment_view(request, attachment_id):
    """Vista para descargar adjuntos"""
    attachment = get_object_or_404(TicketAttachment, pk=attachment_id)
    
    # Verificar permisos
    if is_agent(request.user) or attachment.ticket.created_by == request.user:
        if attachment.file:
            try:
                with open(attachment.file.path, 'rb') as f:
                    response = HttpResponse(f.read(), content_type='application/octet-stream')
                    response['Content-Disposition'] = f'attachment; filename="{attachment.original_filename}"'
                    return response
            except FileNotFoundError:
                messages.error(request, 'El archivo no se encontró en el servidor.')
        else:
            messages.error(request, 'No hay archivo asociado.')
    else:
        messages.error(request, 'No tienes permisos para descargar este archivo.')
    
    return redirect('ticket_detail', pk=attachment.ticket.pk)


@login_required
def delete_attachment_view(request, attachment_id):
    """Vista para eliminar adjuntos"""
    attachment = get_object_or_404(TicketAttachment, pk=attachment_id)
    ticket_pk = attachment.ticket.pk
    
    # Verificar permisos (solo el que subió el archivo o agentes pueden eliminarlo)
    if is_agent(request.user) or attachment.uploaded_by == request.user:
        attachment.delete()
        messages.success(request, 'Adjunto eliminado exitosamente.')
    else:
        messages.error(request, 'No tienes permisos para eliminar este archivo.')
    
    return redirect('ticket_detail', pk=ticket_pk)


@login_required
@user_passes_test(agent_required, login_url='dashboard')
def unassign_ticket_view(request, pk):
    """Vista para que los agentes desasignen tickets"""
    ticket = get_object_or_404(Ticket, pk=pk)
    ticket.assigned_to = None
    ticket.save()
    messages.success(request, f'Ticket #{ticket.pk} desasignado exitosamente.')
    return redirect('ticket_detail', pk=pk)


# ================================
# VISTAS PARA GESTIÓN DE CATEGORÍAS
# ================================

@login_required
@user_passes_test(is_agent)
def category_list_view(request):
    """Vista para listar todas las categorías (solo agentes)"""
    categories = Category.objects.all().order_by('name')
    
    # Agregar contador de tickets por categoría
    for category in categories:
        category.ticket_count = category.tickets.count()
    
    context = {
        'categories': categories,
        'page_title': 'Gestión de Categorías'
    }
    return render(request, 'tickets/category_list.html', context)


@login_required
@user_passes_test(is_agent)
def category_create_view(request):
    """Vista para crear una nueva categoría (solo agentes)"""
    if request.method == 'POST':
        form = CategoryForm(request.POST)
        if form.is_valid():
            category = form.save()
            messages.success(request, f'Categoría "{category.name}" creada exitosamente.')
            return redirect('category_list')
    else:
        form = CategoryForm()
    
    context = {
        'form': form,
        'page_title': 'Crear Categoría',
        'form_title': 'Nueva Categoría'
    }
    return render(request, 'tickets/category_form.html', context)


@login_required
@user_passes_test(is_agent)
def category_edit_view(request, pk):
    """Vista para editar una categoría existente (solo agentes)"""
    category = get_object_or_404(Category, pk=pk)
    
    if request.method == 'POST':
        form = CategoryForm(request.POST, instance=category)
        if form.is_valid():
            category = form.save()
            messages.success(request, f'Categoría "{category.name}" actualizada exitosamente.')
            return redirect('category_list')
    else:
        form = CategoryForm(instance=category)
    
    context = {
        'form': form,
        'category': category,
        'page_title': 'Editar Categoría',
        'form_title': f'Editar: {category.name}'
    }
    return render(request, 'tickets/category_form.html', context)


@login_required
@user_passes_test(is_agent)
def category_delete_view(request, pk):
    """Vista para eliminar una categoría (solo agentes)"""
    category = get_object_or_404(Category, pk=pk)
    ticket_count = category.tickets.count()
    
    if request.method == 'POST':
        category_name = category.name
        category.delete()
        messages.success(request, f'Categoría "{category_name}" eliminada exitosamente.')
        return redirect('category_list')
    
    context = {
        'category': category,
        'ticket_count': ticket_count,
        'page_title': 'Eliminar Categoría'
    }
    return render(request, 'tickets/category_delete.html', context)


@login_required
@user_passes_test(is_agent)
def category_detail_view(request, pk):
    """Vista para ver detalles de una categoría y sus tickets (solo agentes)"""
    category = get_object_or_404(Category, pk=pk)
    tickets = category.tickets.all().order_by('-created_at')
    
    # Paginación de tickets
    paginator = Paginator(tickets, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'category': category,
        'tickets': page_obj,
        'ticket_count': tickets.count(),
        'page_title': f'Categoría: {category.name}'
    }
    return render(request, 'tickets/category_detail.html', context)


def public_ticket_view(request, token):
    """Vista pública para mostrar un ticket mediante su token único"""
    try:
        ticket = get_object_or_404(Ticket, public_share_token=token, is_public_shareable=True)
    except:
        # Si el ticket no existe o no está habilitado para compartir
        context = {
            'error_message': 'El enlace del ticket no es válido o ha expirado.',
            'error_type': 'not_found'
        }
        return render(request, 'tickets/public_ticket.html', context, status=404)
    
    # Obtener comentarios del ticket
    comments = ticket.comments.all().order_by('created_at')
    
    # Obtener adjuntos del ticket
    attachments = ticket.attachments.all().order_by('-uploaded_at')
    
    # Verificar si ya tiene aprobación
    has_approval = hasattr(ticket, 'client_approval')
    
    context = {
        'ticket': ticket,
        'comments': comments,
        'attachments': attachments,
        'has_approval': has_approval,
        'approval': ticket.client_approval if has_approval else None,
        'token': token,  # Agregar el token al contexto
        'page_title': f'Ticket Público: {ticket.ticket_number}',
    }
    return render(request, 'tickets/public_ticket.html', context)


def public_ticket_approve(request, token):
    """Vista para que los clientes aprueben tickets públicos"""
    try:
        ticket = get_object_or_404(Ticket, public_share_token=token, is_public_shareable=True)
    except:
        messages.error(request, 'Ticket no encontrado o no es público.')
        return redirect('ticket_list')
    
    # Verificar si ya tiene aprobación
    if hasattr(ticket, 'client_approval'):
        messages.warning(request, 'Este ticket ya ha sido aprobado anteriormente.')
        return redirect('public_ticket', token=token)
    
    if request.method == 'POST':
        try:
            # Obtener datos del formulario
            client_name = request.POST.get('client_name', '').strip()
            client_email = request.POST.get('client_email', '').strip()
            notes = request.POST.get('notes', '').strip()
            
            # Validaciones básicas
            if not client_name or not client_email:
                messages.error(request, 'Nombre y correo electrónico son obligatorios.')
                return redirect('public_ticket', token=token)
            
            # Validar formato de email
            from django.core.validators import validate_email
            from django.core.exceptions import ValidationError
            try:
                validate_email(client_email)
            except ValidationError:
                messages.error(request, 'Por favor ingresa un correo electrónico válido.')
                return redirect('public_ticket', token=token)
            
            # Obtener IP del cliente
            def get_client_ip(request):
                x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
                if x_forwarded_for:
                    ip = x_forwarded_for.split(',')[0]
                else:
                    ip = request.META.get('REMOTE_ADDR')
                return ip
            
            # Crear la aprobación
            from .models import TicketApproval
            approval = TicketApproval.objects.create(
                ticket=ticket,
                client_name=client_name,
                client_email=client_email,
                notes=notes,
                ip_address=get_client_ip(request)
            )
            
            # Actualizar el estado de aprobación del ticket
            ticket.is_approved = True
            ticket.approved_by = None  # Aprobado por el cliente, no por un usuario del sistema
            ticket.approved_at = approval.approved_at
            ticket.save(update_fields=['is_approved', 'approved_by', 'approved_at'])
            
            # Agregar un comentario informando de la aprobación
            TicketComment.objects.create(
                ticket=ticket,
                user=ticket.created_by,  # Sistema
                content=f"✅ TICKET APROBADO POR EL CLIENTE\n\n" +
                       f"Cliente: {client_name}\n" +
                       f"Email: {client_email}\n" +
                       f"Fecha: {approval.approved_at.strftime('%d/%m/%Y %H:%M')}\n" +
                       (f"Comentarios: {notes}\n" if notes else "") +
                       f"IP: {approval.ip_address}\n\n" +
                       f"El cliente ha confirmado su satisfacción con la solución proporcionada."
            )
            
            messages.success(
                request, 
                f'¡Gracias {client_name}! Tu aprobación ha sido registrada exitosamente. '
                f'El equipo ha sido notificado de tu satisfacción con la solución.'
            )
            
            return redirect('public_ticket', token=token)
            
        except Exception as e:
            messages.error(request, f'Error al procesar la aprobación: {str(e)}')
            return redirect('public_ticket', token=token)
    
    # Si es GET, redirigir al ticket público
    return redirect('public_ticket', token=token)
    return JsonResponse({'success': False, 'error': 'Método no permitido'})


def public_ticket_survey(request, token):
    """Vista para que los clientes llenen encuesta de satisfacción"""
    try:
        ticket = get_object_or_404(Ticket, public_share_token=token, is_public_shareable=True)
    except:
        messages.error(request, 'Ticket no encontrado o no es público.')
        return redirect('ticket_list')
    
    # Verificar si ya tiene encuesta de satisfacción
    if hasattr(ticket, 'satisfaction_survey'):
        messages.info(request, 'Ya has enviado una encuesta de satisfacción para este ticket.')
        return redirect('public_ticket', token=token)
    
    if request.method == 'POST':
        try:
            # Obtener datos del formulario
            client_name = request.POST.get('client_name', '').strip()
            client_email = request.POST.get('client_email', '').strip()
            
            # Calificaciones (obligatorias)
            overall_satisfaction = request.POST.get('overall_satisfaction')
            resolution_quality = request.POST.get('resolution_quality')
            response_time = request.POST.get('response_time')
            communication = request.POST.get('communication')
            
            # Comentarios (opcionales)
            what_went_well = request.POST.get('what_went_well', '').strip()
            what_could_improve = request.POST.get('what_could_improve', '').strip()
            additional_comments = request.POST.get('additional_comments', '').strip()
            
            # Recomendación
            would_recommend = request.POST.get('would_recommend') == 'true'
            recommendation_reason = request.POST.get('recommendation_reason', '').strip()
            
            # Validaciones básicas
            if not client_name or not client_email:
                messages.error(request, 'Nombre y correo electrónico son obligatorios.')
                return redirect('public_ticket_survey', token=token)
            
            if not all([overall_satisfaction, resolution_quality, response_time, communication]):
                messages.error(request, 'Todas las calificaciones son obligatorias.')
                return redirect('public_ticket_survey', token=token)
            
            # Validar formato de email
            from django.core.validators import validate_email
            from django.core.exceptions import ValidationError
            try:
                validate_email(client_email)
            except ValidationError:
                messages.error(request, 'Por favor ingresa un correo electrónico válido.')
                return redirect('public_ticket_survey', token=token)
            
            # Validar que las calificaciones sean números válidos
            try:
                overall_satisfaction = int(overall_satisfaction)
                resolution_quality = int(resolution_quality)
                response_time = int(response_time)
                communication = int(communication)
                
                # Validar rango 1-5
                if not all(1 <= rating <= 5 for rating in [overall_satisfaction, resolution_quality, response_time, communication]):
                    raise ValueError("Las calificaciones deben estar entre 1 y 5")
                    
            except (ValueError, TypeError):
                messages.error(request, 'Las calificaciones deben ser números válidos entre 1 y 5.')
                return redirect('public_ticket_survey', token=token)
            
            # Obtener IP del cliente
            def get_client_ip(request):
                x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
                if x_forwarded_for:
                    ip = x_forwarded_for.split(',')[0]
                else:
                    ip = request.META.get('REMOTE_ADDR')
                return ip
            
            # Crear la encuesta de satisfacción
            survey = SatisfactionSurvey.objects.create(
                ticket=ticket,
                client_name=client_name,
                client_email=client_email,
                overall_satisfaction=overall_satisfaction,
                resolution_quality=resolution_quality,
                response_time=response_time,
                communication=communication,
                what_went_well=what_went_well,
                what_could_improve=what_could_improve,
                additional_comments=additional_comments,
                would_recommend=would_recommend,
                recommendation_reason=recommendation_reason,
                ip_address=get_client_ip(request)
            )
            
            # Agregar un comentario informando de la encuesta
            TicketComment.objects.create(
                ticket=ticket,
                user=ticket.created_by,  # Sistema
                content=f"📊 ENCUESTA DE SATISFACCIÓN COMPLETADA\n\n" +
                       f"Cliente: {client_name}\n" +
                       f"Email: {client_email}\n" +
                       f"Fecha: {survey.submitted_at.strftime('%d/%m/%Y %H:%M')}\n\n" +
                       f"📈 CALIFICACIONES:\n" +
                       f"• Satisfacción General: {overall_satisfaction}/5\n" +
                       f"• Calidad de la Solución: {resolution_quality}/5\n" +
                       f"• Tiempo de Respuesta: {response_time}/5\n" +
                       f"• Comunicación: {communication}/5\n" +
                       f"• Promedio: {survey.average_rating}/5 - {survey.rating_summary}\n\n" +
                       f"🎯 RECOMENDACIÓN: {'Sí' if would_recommend else 'No'}\n" +
                       (f"Razón: {recommendation_reason}\n\n" if recommendation_reason else "\n") +
                       (f"✅ Lo que funcionó bien:\n{what_went_well}\n\n" if what_went_well else "") +
                       (f"🔧 Qué se podría mejorar:\n{what_could_improve}\n\n" if what_could_improve else "") +
                       (f"💬 Comentarios adicionales:\n{additional_comments}\n\n" if additional_comments else "") +
                       f"IP: {survey.ip_address}"
            )
            
            messages.success(
                request, 
                f'¡Gracias {client_name}! Tu encuesta de satisfacción ha sido enviada exitosamente. '
                f'Tu retroalimentación es muy valiosa para nosotros.'
            )
            
            return redirect('public_ticket', token=token)
            
        except Exception as e:
            messages.error(request, f'Error al procesar la encuesta: {str(e)}')
            return redirect('public_ticket_survey', token=token)
    
    # Si es GET, mostrar el formulario de encuesta
    context = {
        'ticket': ticket,
        'token': token,
        'rating_choices': SatisfactionSurvey.RATING_CHOICES,
        'resolution_quality_choices': SatisfactionSurvey.RESOLUTION_QUALITY_CHOICES,
        'response_time_choices': SatisfactionSurvey.RESPONSE_TIME_CHOICES,
    }
    
    return render(request, 'tickets/public_ticket_survey.html', context)


def public_ticket_upload(request, token):
    """Vista para que los clientes suban archivos a tickets públicos"""
    try:
        ticket = get_object_or_404(Ticket, public_share_token=token, is_public_shareable=True)
    except:
        messages.error(request, 'Ticket no encontrado o no es público.')
        return redirect('ticket_list')
    
    if request.method == 'POST':
        try:
            # Obtener datos del formulario
            client_name = request.POST.get('client_name', '').strip()
            client_email = request.POST.get('client_email', '').strip()
            description = request.POST.get('description', '').strip()
            
            # Validaciones básicas
            if not client_name or not client_email:
                messages.error(request, 'Nombre y correo electrónico son obligatorios.')
                return redirect('public_ticket_upload', token=token)
            
            # Validar formato de email
            from django.core.validators import validate_email
            from django.core.exceptions import ValidationError
            try:
                validate_email(client_email)
            except ValidationError:
                messages.error(request, 'Por favor ingresa un correo electrónico válido.')
                return redirect('public_ticket_upload', token=token)
            
            # Verificar que se haya subido al menos un archivo
            files = request.FILES.getlist('attachments')
            if not files:
                messages.error(request, 'Debes subir al menos un archivo.')
                return redirect('public_ticket_upload', token=token)
            
            # Validar cada archivo
            max_file_size = 10 * 1024 * 1024  # 10MB
            allowed_extensions = ['.pdf', '.doc', '.docx', '.txt', '.jpg', '.jpeg', '.png', '.gif', '.zip', '.rar', '.xlsx', '.xls', '.ppt', '.pptx']
            
            for file in files:
                # Validar tamaño
                if file.size > max_file_size:
                    messages.error(request, f'El archivo "{file.name}" excede el tamaño máximo permitido (10MB).')
                    return redirect('public_ticket_upload', token=token)
                
                # Validar extensión
                file_extension = os.path.splitext(file.name.lower())[1]
                if file_extension not in allowed_extensions:
                    messages.error(request, f'El archivo "{file.name}" tiene una extensión no permitida. Extensiones permitidas: {", ".join(allowed_extensions)}')
                    return redirect('public_ticket_upload', token=token)
            
            # Obtener IP del cliente
            def get_client_ip(request):
                x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
                if x_forwarded_for:
                    ip = x_forwarded_for.split(',')[0]
                else:
                    ip = request.META.get('REMOTE_ADDR')
                return ip
            
            # Crear usuario temporal para los adjuntos (usar el creador del ticket)
            upload_user = ticket.created_by
            
            # Subir cada archivo
            uploaded_files = []
            for file in files:
                attachment = TicketAttachment.objects.create(
                    ticket=ticket,
                    file=file,
                    original_filename=file.name,
                    uploaded_by=upload_user,
                    file_size=file.size
                )
                uploaded_files.append(attachment)
            
            # Crear comentario informativo sobre la subida de archivos
            files_list = '\n'.join([f"• {att.original_filename} ({att.get_file_size_display()})" for att in uploaded_files])
            
            TicketComment.objects.create(
                ticket=ticket,
                user=upload_user,
                content=f"📎 ARCHIVOS SUBIDOS POR EL CLIENTE\n\n" +
                       f"Cliente: {client_name}\n" +
                       f"Email: {client_email}\n" +
                       f"Fecha: {timezone.now().strftime('%d/%m/%Y %H:%M')}\n" +
                       f"IP: {get_client_ip(request)}\n\n" +
                       f"Archivos subidos ({len(uploaded_files)}):\n{files_list}\n\n" +
                       (f"Descripción: {description}\n\n" if description else "") +
                       f"Los archivos han sido adjuntados al ticket y están disponibles para revisión."
            )
            
            messages.success(
                request, 
                f'¡Gracias {client_name}! Se {"ha" if len(uploaded_files) == 1 else "han"} subido {len(uploaded_files)} archivo{"" if len(uploaded_files) == 1 else "s"} exitosamente al ticket.'
            )
            
            return redirect('public_ticket', token=token)
            
        except Exception as e:
            messages.error(request, f'Error al subir los archivos: {str(e)}')
            return redirect('public_ticket_upload', token=token)
    
    # Si es GET, mostrar el formulario de subida
    context = {
        'ticket': ticket,
        'token': token,
        'max_file_size_mb': 10,
        'allowed_extensions': ['.pdf', '.doc', '.docx', '.txt', '.jpg', '.jpeg', '.png', '.gif', '.zip', '.rar', '.xlsx', '.xls', '.ppt', '.pptx'],
    }
    
    return render(request, 'tickets/public_ticket_upload.html', context)


@login_required
def user_profile_view(request):
    """Vista para mostrar y actualizar el perfil del usuario"""
    from . import utils
    
    # Obtener o crear el perfil del usuario
    profile, created = UserProfile.objects.get_or_create(user=request.user)
    
    # Asegurar que el perfil tenga un token público
    if not profile.public_token:
        import uuid
        profile.public_token = uuid.uuid4()
        profile.save()
    
    # Importar formularios aquí para evitar importación circular
    from .forms import UserProfileForm, CustomPasswordChangeForm
    
    profile_form = UserProfileForm(instance=profile, user=request.user)
    password_form = CustomPasswordChangeForm(request.user)
    
    if request.method == 'POST':
        if 'update_profile' in request.POST:
            # Actualizar perfil
            profile_form = UserProfileForm(
                request.POST, 
                instance=profile, 
                user=request.user
            )
            if profile_form.is_valid():
                profile_form.save(user=request.user)
                messages.success(request, 'Tu perfil ha sido actualizado exitosamente.')
                return redirect('user_profile')
        
        elif 'update_contact_form_toggle' in request.POST:
            # Actualizar solo el toggle del formulario de contacto
            enable_form = request.POST.get('enable_public_contact_form') == 'true'
            profile.enable_public_contact_form = enable_form
            profile.save()
            return JsonResponse({'success': True})
        
        elif 'change_password' in request.POST:
            # Cambiar contraseña
            password_form = CustomPasswordChangeForm(request.user, request.POST)
            if password_form.is_valid():
                user = password_form.save()
                from django.contrib.auth import update_session_auth_hash
                update_session_auth_hash(request, user)  # Mantener la sesión activa
                messages.success(request, 'Tu contraseña ha sido cambiada exitosamente.')
                return redirect('user_profile')
        
        elif 'regenerate_token' in request.POST:
            # Regenerar token público
            new_token = profile.regenerate_token()
            messages.success(request, 'Tu token de acceso público ha sido regenerado.')
            return redirect('user_profile')
    
    # Construir URL pública para tareas
    if request.is_secure():
        protocol = 'https'
    else:
        protocol = 'http'
    
    public_task_url = f"{protocol}://{request.get_host()}/public/tasks/{profile.public_token}/"
    
    # Construir URL pública para formulario de contacto
    public_contact_form_url = None
    contact_form_stats = None
    if profile.enable_public_contact_form:
        public_contact_form_url = f"{protocol}://{request.get_host()}/contact/{profile.public_token}/"
        
        # Calcular estadísticas de formularios de contacto
        from .models import ContactFormSubmission
        submissions = ContactFormSubmission.objects.filter(submitted_by_user=request.user)
        contact_form_stats = {
            'pending': submissions.filter(status='pending').count(),
            'approved': submissions.filter(status='approved').count(),
            'rejected': submissions.filter(status='rejected').count(),
            'company_created': submissions.filter(status='company_created').count(),
            'total': submissions.count(),
        }
    
    context = {
        'profile_form': profile_form,
        'password_form': password_form,
        'user_profile': profile,
        'public_task_url': public_task_url,
        'public_contact_form_url': public_contact_form_url,
        'contact_form_stats': contact_form_stats,
        'is_agent': utils.is_agent(request.user),
        'page_title': 'Mi Perfil'
    }
    return render(request, 'tickets/user_profile.html', context)


# =====================================
# VIEWS PARA GESTIÓN DE NOTAS INTERNAS
# =====================================

@login_required
def notes_list_view(request):
    """Lista todas las notas internas"""
    
    # Obtener parámetros de filtro
    search_query = request.GET.get('search', '')
    user_filter = request.GET.get('user', '')
    privacy_filter = request.GET.get('privacy', '')
    
    # Obtener la empresa del usuario
    user_company = getattr(request.user.profile, 'company', None) if hasattr(request.user, 'profile') else None
    
    # Base queryset sin filtrado por empresa - mostrar todas las notas
    if is_agent(request.user):
        # Los agentes ven todas las notas públicas + sus propias notas privadas
        notes = UserNote.objects.filter(
            Q(is_private=False) | Q(created_by=request.user)
        ).select_related('user', 'created_by', 'company').prefetch_related('tickets')
    else:
        # Los usuarios normales ven todas sus propias notas
        notes = UserNote.objects.filter(
            created_by=request.user
        ).select_related('user', 'created_by', 'company').prefetch_related('tickets')
    
    # Aplicar filtros
    if search_query:
        notes = notes.filter(
            Q(title__icontains=search_query) |
            Q(description__icontains=search_query) |
            Q(user__username__icontains=search_query) |
            Q(user__first_name__icontains=search_query) |
            Q(user__last_name__icontains=search_query)
        )
    
    if user_filter:
        notes = notes.filter(user_id=user_filter)
    
    if privacy_filter == 'private':
        notes = notes.filter(is_private=True)
    elif privacy_filter == 'public':
        notes = notes.filter(is_private=False)
    
    # Paginación
    paginator = Paginator(notes, 15)  # 15 notas por página
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Obtener lista de usuarios para el filtro
    users_with_notes = User.objects.filter(notes__isnull=False).distinct().order_by('username')
    
    context = {
        'page_obj': page_obj,
        'users_with_notes': users_with_notes,
        'search_query': search_query,
        'user_filter': user_filter,
        'privacy_filter': privacy_filter,
        'page_title': 'Notas Internas'
    }
    return render(request, 'tickets/notes_list.html', context)


@login_required
def note_detail_view(request, note_id):
    """Vista detallada de una nota"""
    
    # Obtener la empresa del usuario
    user_company = getattr(request.user.profile, 'company', None) if hasattr(request.user, 'profile') else None
    
    # Sin filtrar por empresa - permitir acceso a todas las notas
    if is_agent(request.user):
        # Los agentes pueden ver cualquier nota
        try:
            note = UserNote.objects.get(id=note_id)
        except UserNote.DoesNotExist:
            raise Http404("Nota no encontrada")
    else:
        # Los usuarios normales solo sus propias notas
        try:
            note = UserNote.objects.get(
                id=note_id,
                created_by=request.user
            )
        except UserNote.DoesNotExist:
            raise Http404("Nota no encontrada")
    
    # Verificar permisos usando el método del modelo
    if not note.can_view(request.user):
        messages.error(request, 'No tienes permisos para ver esta nota.')
        return redirect('notes_list')
    
    context = {
        'note': note,
        'page_title': f'Nota: {note.title}',
        'can_edit': note.can_edit(request.user)
    }
    return render(request, 'tickets/note_detail.html', context)


@login_required
@user_passes_test(is_agent, login_url='dashboard')
def note_create_view(request):
    """Crear nueva nota interna (solo para agentes)"""
    
    if request.method == 'POST':
        # Si es una petición AJAX desde widget de notas rápidas, configurar datos automáticamente
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest' and request.POST.get('created_via') == 'quick_note_widget':
            # Crear una copia mutable de POST data
            post_data = request.POST.copy()
            post_data['user'] = request.user.id  # Asignar el usuario actual como usuario asociado
            request.POST = post_data
        
        form = UserNoteForm(request.POST, current_user=request.user)
        
        if form.is_valid():
            note = form.save(commit=False)
            note.created_by = request.user
            
            # Asignar empresa del usuario si no es agente
            if hasattr(request.user, 'profile') and request.user.profile.company and not note.company:
                note.company = request.user.profile.company
            
            note.save()
            form.save_m2m()  # Guardar relaciones many-to-many
            
            # Si es una petición AJAX, devolver JSON
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': True,
                    'message': f'Nota "{note.title}" creada exitosamente.',
                    'note_id': note.id
                })
            
            messages.success(request, f'Nota "{note.title}" creada exitosamente.')
            return redirect('note_detail', note_id=note.id)
        else:
            # Si hay errores en el formulario y es AJAX
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': False,
                    'errors': form.errors
                }, status=400)
    else:
        form = UserNoteForm(current_user=request.user)
        
        # Preseleccionar la empresa del usuario si tiene una
        if hasattr(request.user, 'profile') and request.user.profile.company:
            form.fields['company'].initial = request.user.profile.company
        
        # Si se pasa un usuario por parámetro, preseleccionarlo
        user_id = request.GET.get('user')
        if user_id:
            try:
                user = User.objects.get(id=user_id)
                form.fields['user'].initial = user
                # Cargar tickets del usuario seleccionado
                form.fields['tickets'].queryset = Ticket.objects.filter(
                    created_by=user
                ).order_by('-created_at')
            except User.DoesNotExist:
                pass
    
    context = {
        'form': form,
        'page_title': 'Crear Nota Interna'
    }
    return render(request, 'tickets/note_form.html', context)


@login_required
def note_edit_view(request, note_id):
    """Editar nota interna existente"""
    
    # Obtener la empresa del usuario
    user_company = getattr(request.user.profile, 'company', None) if hasattr(request.user, 'profile') else None
    
    # Filtrar por empresa también
    if is_agent(request.user):
        # Los agentes pueden editar notas de su empresa
        note = get_object_or_404(UserNote, id=note_id, company=user_company)
    else:
        # Los usuarios normales solo sus propias notas de su empresa
        note = get_object_or_404(UserNote, id=note_id, created_by=request.user, company=user_company)
    
    # Verificar permisos usando el método del modelo
    if not note.can_edit(request.user):
        messages.error(request, 'No tienes permisos para editar esta nota.')
        return redirect('note_detail', note_id=note.id)
    
    if request.method == 'POST':
        form = UserNoteForm(request.POST, instance=note, current_user=request.user)
        if form.is_valid():
            updated_note = form.save(commit=False)
            
            # Asignar empresa del usuario si no hay empresa asignada
            if hasattr(request.user, 'profile') and request.user.profile.company and not updated_note.company:
                updated_note.company = request.user.profile.company
            
            updated_note.save()
            form.save_m2m()  # Guardar relaciones many-to-many
            messages.success(request, f'Nota "{updated_note.title}" actualizada exitosamente.')
            return redirect('note_detail', note_id=updated_note.id)
    else:
        form = UserNoteForm(instance=note, current_user=request.user)
    
    context = {
        'form': form,
        'note': note,
        'page_title': f'Editar Nota: {note.title}'
    }
    return render(request, 'tickets/note_form.html', context)


@login_required
def note_delete_view(request, note_id):
    """Eliminar nota interna"""
    
    # Obtener la empresa del usuario
    user_company = getattr(request.user.profile, 'company', None) if hasattr(request.user, 'profile') else None
    
    # Filtrar por empresa también
    if is_agent(request.user):
        # Los agentes pueden eliminar notas de su empresa
        note = get_object_or_404(UserNote, id=note_id, company=user_company)
    else:
        # Los usuarios normales solo sus propias notas de su empresa
        note = get_object_or_404(UserNote, id=note_id, created_by=request.user, company=user_company)
    
    # Verificar permisos usando el método del modelo
    if not note.can_delete(request.user):
        messages.error(request, 'No tienes permisos para eliminar esta nota.')
        return redirect('note_detail', note_id=note.id)
    
    if request.method == 'POST':
        note_title = note.title
        note.delete()
        messages.success(request, f'Nota "{note_title}" eliminada exitosamente.')
        return redirect('notes_list')
    
    context = {
        'note': note,
        'page_title': f'Eliminar Nota: {note.title}'
    }
    return render(request, 'tickets/note_delete.html', context)


@login_required
def note_pdf_view(request, note_id):
    """Generar PDF de una nota"""
    from django.http import HttpResponse
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.lib import colors
    from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
    from io import BytesIO
    import datetime
    
    # Obtener la empresa del usuario
    user_company = getattr(request.user.profile, 'company', None) if hasattr(request.user, 'profile') else None
    
    # Filtrar por empresa también
    if is_agent(request.user):
        # Los agentes pueden ver PDFs de notas de su empresa
        note = get_object_or_404(UserNote, id=note_id, company=user_company)
    else:
        # Los usuarios normales solo sus propias notas de su empresa
        note = get_object_or_404(UserNote, id=note_id, created_by=request.user, company=user_company)
    
    # Verificar permisos usando el método del modelo
    if not note.can_view(request.user):
        messages.error(request, 'No tienes permisos para ver esta nota.')
        return redirect('notes_list')
    
    # Crear el PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="{note.title.replace(" ", "_")}.pdf"'
    
    # Crear el documento PDF
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=20, leftMargin=20, topMargin=72, bottomMargin=72)
    
    # Estilos
    styles = getSampleStyleSheet()
    
    # Estilo personalizado para el título
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=20,
        spaceAfter=30,
        alignment=TA_CENTER,
        textColor=colors.darkblue
    )
    
    # Estilo para información
    info_style = ParagraphStyle(
        'InfoStyle',
        parent=styles['Normal'],
        fontSize=12,
        spaceAfter=8,
        alignment=TA_LEFT,
        textColor=colors.grey
    )
    
    # Estilo para el contenido
    content_style = ParagraphStyle(
        'CustomContent',
        parent=styles['Normal'],
        fontSize=11,
        spaceAfter=12,
        alignment=TA_LEFT,
        leftIndent=20,
        rightIndent=20
    )
    
    # Contenido del PDF
    story = []
    
    # Título de la nota (no "NOTA INTERNA")
    story.append(Paragraph(note.title.upper(), title_style))
    story.append(Spacer(1, 20))
    
    # Fecha
    story.append(Paragraph(f"Fecha: {note.created_at.strftime('%d/%m/%Y')}", info_style))
    story.append(Spacer(1, 10))
    
    # Empresa (si existe)
    if note.company:
        story.append(Paragraph(f"Empresa: {note.company.name}", info_style))
        story.append(Spacer(1, 20))
    else:
        story.append(Spacer(1, 10))
    
    # Línea separadora
    story.append(Spacer(1, 20))
    
    # Descripción (contenido de la nota)
    description_lines = note.description.split('\n')
    for line in description_lines:
        if line.strip():
            story.append(Paragraph(line.strip(), content_style))
        else:
            story.append(Spacer(1, 8))
    
    # Construir el PDF
    doc.build(story)
    
    # Obtener el valor del buffer y escribirlo en la respuesta
    pdf = buffer.getvalue()
    buffer.close()
    response.write(pdf)
    
    return response


@login_required
def note_generate_share_link(request, note_id):
    """Generar enlace para compartir nota públicamente"""
    
    # Obtener la empresa del usuario
    user_company = getattr(request.user.profile, 'company', None) if hasattr(request.user, 'profile') else None
    
    # Filtrar por empresa también
    if is_agent(request.user):
        # Los agentes pueden generar enlaces para notas de su empresa
        note = get_object_or_404(UserNote, id=note_id, company=user_company)
    else:
        # Los usuarios normales solo para sus propias notas de su empresa
        note = get_object_or_404(UserNote, id=note_id, created_by=request.user, company=user_company)
    
    # Verificar permisos usando el método del modelo
    if not note.can_edit(request.user):
        messages.error(request, 'No tienes permisos para generar enlace de esta nota.')
        return redirect('note_detail', note_id=note_id)
    
    if request.method == 'POST':
        if not note.share_token:
            # Generar token si no existe
            note.generate_share_token()
            messages.success(request, 'Enlace para compartir generado exitosamente.')
        else:
            # Si ya existe, solo activar compartir
            note.is_shareable = True
            note.save()
            messages.info(request, 'Enlace para compartir activado.')
    
    return redirect('note_detail', note_id=note_id)


@login_required
def note_disable_sharing(request, note_id):
    """Deshabilitar compartir nota públicamente"""
    
    # Obtener la empresa del usuario
    user_company = getattr(request.user.profile, 'company', None) if hasattr(request.user, 'profile') else None
    
    # Filtrar por empresa también
    if is_agent(request.user):
        # Los agentes pueden deshabilitar enlaces para notas de su empresa
        note = get_object_or_404(UserNote, id=note_id, company=user_company)
    else:
        # Los usuarios normales solo para sus propias notas de su empresa
        note = get_object_or_404(UserNote, id=note_id, created_by=request.user, company=user_company)
    
    # Verificar permisos usando el método del modelo
    if not note.can_edit(request.user):
        messages.error(request, 'No tienes permisos para deshabilitar enlace de esta nota.')
        return redirect('note_detail', note_id=note_id)
    
    if request.method == 'POST':
        note.disable_sharing()
        messages.warning(request, 'Enlace para compartir deshabilitado.')
    
    return redirect('note_detail', note_id=note_id)


@login_required
def note_regenerate_share_link(request, note_id):
    """Regenerar enlace para compartir nota públicamente"""
    
    # Obtener la empresa del usuario
    user_company = getattr(request.user.profile, 'company', None) if hasattr(request.user, 'profile') else None
    
    # Filtrar por empresa también
    if is_agent(request.user):
        # Los agentes pueden regenerar enlaces para notas de su empresa
        note = get_object_or_404(UserNote, id=note_id, company=user_company)
    else:
        # Los usuarios normales solo para sus propias notas de su empresa
        note = get_object_or_404(UserNote, id=note_id, created_by=request.user, company=user_company)
    
    # Verificar permisos usando el método del modelo
    if not note.can_edit(request.user):
        messages.error(request, 'No tienes permisos para regenerar enlace de esta nota.')
        return redirect('note_detail', note_id=note_id)
    
    if request.method == 'POST':
        # Generar nuevo token
        note.generate_share_token()
        messages.info(request, 'Enlace para compartir regenerado. El enlace anterior ya no es válido.')
    
    return redirect('note_detail', note_id=note_id)


def shared_note_view(request, token):
    """Vista pública para mostrar una nota mediante su token único"""
    try:
        note = get_object_or_404(UserNote, share_token=token, is_shareable=True)
    except:
        # Si la nota no existe o no está habilitada para compartir
        context = {
            'error_message': 'El enlace de la nota no es válido o ha expirado.',
            'error_type': 'not_found'
        }
        return render(request, 'tickets/shared_note.html', context, status=404)
    
    # Incrementar contador de visualizaciones
    note.increment_view_count()
    
    context = {
        'note': note,
        'token': token,
        'page_title': f'Nota Compartida: {note.title}',
    }
    return render(request, 'tickets/shared_note.html', context)


def shared_note_pdf(request, token):
    """Vista pública para descargar PDF de una nota mediante su token único"""
    try:
        note = get_object_or_404(UserNote, share_token=token, is_shareable=True)
    except:
        raise Http404("La nota no existe o no está disponible para compartir")
    
    # Incrementar contador de visualizaciones (también cuenta como descarga)
    note.increment_view_count()
    
    # Reutilizar la lógica de generación de PDF existente
    from django.http import HttpResponse
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.lib import colors
    from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
    from io import BytesIO
    import datetime
    
    # Crear el PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="{note.title.replace(" ", "_")}.pdf"'
    
    # Crear el documento PDF con márgenes reducidos
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=20, leftMargin=20, topMargin=72, bottomMargin=72)
    
    # Estilos
    styles = getSampleStyleSheet()
    
    # Estilo personalizado para el título
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=20,
        spaceAfter=30,
        alignment=TA_CENTER,
        textColor=colors.darkblue
    )
    
    # Estilo para información
    info_style = ParagraphStyle(
        'InfoStyle',
        parent=styles['Normal'],
        fontSize=12,
        spaceAfter=8,
        alignment=TA_LEFT,
        textColor=colors.grey
    )
    
    # Estilo para el contenido
    content_style = ParagraphStyle(
        'CustomContent',
        parent=styles['Normal'],
        fontSize=11,
        spaceAfter=12,
        alignment=TA_LEFT,
        leftIndent=20,
        rightIndent=20
    )
    
    # Contenido del PDF
    story = []
    
    # Título de la nota
    story.append(Paragraph(note.title.upper(), title_style))
    
    # Información de la nota
    story.append(Paragraph(f"Fecha: {note.created_at.strftime('%d/%m/%Y')}", info_style))
    
    if note.company:
        story.append(Paragraph(f"Empresa: {note.company.name}", info_style))
        story.append(Spacer(1, 20))
    else:
        story.append(Spacer(1, 10))
    
    # Línea separadora
    story.append(Spacer(1, 20))
    
    # Descripción (contenido de la nota)
    description_lines = note.description.split('\n')
    for line in description_lines:
        if line.strip():
            story.append(Paragraph(line.strip(), content_style))
        else:
            story.append(Spacer(1, 8))
    
    # Construir el PDF
    doc.build(story)
    
    # Obtener el valor del buffer y escribirlo en la respuesta
    pdf = buffer.getvalue()
    buffer.close()
    response.write(pdf)
    
    return response


@login_required
def user_notes_view(request, user_id=None):
    """Vista de notas asociadas a un usuario específico"""
    
    # Si no se proporciona user_id, usar el usuario actual
    if user_id is None:
        target_user = request.user
    else:
        target_user = get_object_or_404(User, id=user_id)
    
    # Verificar permisos
    can_view_notes = False
    if is_agent(request.user):
        # Los agentes pueden ver notas de cualquier usuario
        can_view_notes = True
        notes = UserNote.objects.filter(user=target_user)
    elif request.user == target_user:
        # Los usuarios pueden ver sus propias notas (solo las no privadas)
        can_view_notes = True
        notes = UserNote.objects.filter(user=target_user, is_private=False)
    else:
        # Otros usuarios no pueden ver las notas
        messages.error(request, 'No tienes permisos para ver estas notas.')
        return redirect('dashboard')
    
    if not can_view_notes:
        messages.error(request, 'No tienes permisos para ver estas notas.')
        return redirect('dashboard')
    
    # Ordenar por fecha de creación descendente
    notes = notes.select_related('created_by').prefetch_related('tickets').order_by('-created_at')
    
    # Paginación
    paginator = Paginator(notes, 10)  # 10 notas por página
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'target_user': target_user,
        'page_obj': page_obj,
        'is_own_notes': request.user == target_user,
        'can_create_notes': is_agent(request.user),
        'page_title': f'Notas de {target_user.get_full_name() or target_user.username}'
    }
    return render(request, 'tickets/user_notes.html', context)


# =====================================
# API PARA OBTENER TICKETS DE USUARIO
# =====================================

@login_required
@user_passes_test(is_agent, login_url='dashboard')
def api_user_tickets(request, user_id):
    """API para obtener tickets de un usuario específico (solo para agentes)"""
    
    try:
        user = User.objects.get(id=user_id)
        tickets = Ticket.objects.filter(created_by=user).order_by('-created_at')
        
        tickets_data = [
            {
                'id': ticket.id,
                'ticket_number': ticket.ticket_number,
                'title': ticket.title,
                'status': ticket.get_status_display(),
                'created_at': ticket.created_at.strftime('%Y-%m-%d %H:%M')
            }
            for ticket in tickets
        ]
        
        return JsonResponse({
            'user': {
                'id': user.id,
                'username': user.username,
                'full_name': user.get_full_name()
            },
            'tickets': tickets_data
        })
        
    except User.DoesNotExist:
        return JsonResponse({'error': 'Usuario no encontrado'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


# =======================================
# VISTAS PARA CONTROL DE HORARIO
# =======================================

@login_required
@user_passes_test(is_agent, login_url='dashboard')
def time_clock_view(request):
    """Vista principal del control de horario para agentes"""
    
    # Obtener registro activo del usuario
    active_entry = TimeEntry.get_active_entry_for_agent(request.user)
    
    # Obtener registros recientes (última semana)
    from datetime import timedelta
    # Calcular el inicio de la semana actual (lunes)
    now = timezone.now()
    start_week = now - timedelta(days=now.weekday())
    start_week = start_week.replace(hour=0, minute=0, second=0, microsecond=0)
    
    recent_entries = TimeEntry.objects.filter(
        user=request.user,
        fecha_entrada__gte=start_week
    ).order_by('-fecha_entrada')[:10]
    
    # Calcular estadísticas de la semana actual
    week_entries = TimeEntry.objects.filter(
        user=request.user,
        fecha_entrada__gte=start_week,
        fecha_salida__isnull=False  # Solo entradas completadas
    )
    total_minutos = sum(entry.duracion_trabajada for entry in week_entries)
    total_horas = round(total_minutos / 60, 2)
    
    # Obtener acceso público si existe
    public_access = None
    try:
        public_access = PublicTimeAccess.objects.get(user=request.user)
    except PublicTimeAccess.DoesNotExist:
        pass
    
    context = {
        'active_entry': active_entry,
        'recent_entries': recent_entries,
        'total_horas_semana': total_horas,
        'can_start': not active_entry,
        'can_end': bool(active_entry),
        'public_access': public_access,
        'page_title': 'Control de Horario'
    }
    
    return render(request, 'tickets/time_clock.html', context)


@login_required
@user_passes_test(is_agent, login_url='dashboard')
def time_start_work(request):
    """Iniciar jornada laboral"""
    
    # Verificar que no hay una jornada activa
    active_entry = TimeEntry.get_active_entry_for_agent(request.user)
    if active_entry:
        messages.warning(request, 'Ya tienes una jornada activa desde las ' + 
                        active_entry.fecha_entrada.strftime('%H:%M'))
        return redirect('time_clock')
    
    if request.method == 'POST':
        form = TimeEntryStartForm(request.POST, user=request.user)
        if form.is_valid():
            try:
                project = form.cleaned_data.get('project')
                ticket = form.cleaned_data.get('ticket')
                work_order = form.cleaned_data.get('work_order')
                task = form.cleaned_data.get('task')
                notas = form.cleaned_data.get('notas_entrada', '')
                
                entry = TimeEntry.create_entry(
                    user=request.user,
                    project=project,
                    ticket=ticket,
                    work_order=work_order,
                    task=task,
                    notas_entrada=notas
                )
                
                # Mensaje personalizado según los elementos seleccionados
                message_parts = [f'¡Jornada iniciada a las {entry.fecha_entrada.strftime("%H:%M")}']
                if project:
                    message_parts.append(f'en el proyecto "{project.name}"')
                if ticket:
                    message_parts.append(f'trabajando en el ticket "{ticket.ticket_number}"')
                if work_order:
                    message_parts.append(f'en la orden "{work_order.order_number}"')
                if task:
                    message_parts.append(f'en la tarea "{task.title}"')
                
                message = ' '.join(message_parts) + '!'
                messages.success(request, message)
                    
                return redirect('time_clock')
            except ValueError as e:
                messages.error(request, str(e))
                return redirect('time_clock')
    else:
        form = TimeEntryStartForm(user=request.user)
    
    context = {
        'form': form,
        'page_title': 'Iniciar Jornada'
    }
    return render(request, 'tickets/time_start.html', context)


@login_required
@user_passes_test(is_agent, login_url='dashboard')
def time_end_work(request):
    """Finalizar jornada laboral"""
    
    # Verificar que hay una jornada activa
    active_entry = TimeEntry.get_active_entry_for_agent(request.user)
    if not active_entry:
        messages.error(request, 'No tienes una jornada activa para finalizar.')
        return redirect('time_clock')
    
    if request.method == 'POST':
        form = TimeEntryEndForm(request.POST)
        if form.is_valid():
            try:
                notas_salida = form.cleaned_data.get('notas_salida', '')
                end_reason = form.cleaned_data.get('end_reason')
                
                # Actualizar el campo end_reason antes de finalizar
                active_entry.end_reason = end_reason
                active_entry.finalizar_jornada(notas_salida)
                
                duracion = active_entry.duracion_formateada
                reason_display = dict(form.fields['end_reason'].choices)[end_reason]
                messages.success(request, 
                    f'¡Jornada finalizada! Duración total: {duracion} horas. Causa: {reason_display}')
                return redirect('time_clock')
            except ValueError as e:
                messages.error(request, str(e))
                return redirect('time_clock')
    else:
        form = TimeEntryEndForm()
    
    context = {
        'form': form,
        'active_entry': active_entry,
        'page_title': 'Finalizar Jornada'
    }
    return render(request, 'tickets/time_end.html', context)


@login_required
@user_passes_test(is_agent, login_url='dashboard')
def time_entries_list(request):
    """Lista de registros de horario del empleado"""
    
    # Filtros
    fecha_desde = request.GET.get('fecha_desde')
    fecha_hasta = request.GET.get('fecha_hasta')
    
    # Base queryset - solo registros del usuario actual
    entries = TimeEntry.objects.filter(user=request.user)
    
    # Aplicar filtros de fecha
    if fecha_desde:
        try:
            from datetime import datetime
            fecha_desde_dt = datetime.strptime(fecha_desde, '%Y-%m-%d').date()
            entries = entries.filter(fecha_entrada__date__gte=fecha_desde_dt)
        except ValueError:
            messages.warning(request, 'Formato de fecha inválido')
    
    if fecha_hasta:
        try:
            from datetime import datetime
            fecha_hasta_dt = datetime.strptime(fecha_hasta, '%Y-%m-%d').date()
            entries = entries.filter(fecha_entrada__date__lte=fecha_hasta_dt)
        except ValueError:
            messages.warning(request, 'Formato de fecha inválido')
    
    # Ordenar por fecha descendente
    entries = entries.order_by('-fecha_entrada')
    
    # Paginación
    paginator = Paginator(entries, 20)  # 20 registros por página
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Calcular totales
    if page_obj.object_list:
        total_minutos = sum(entry.duracion_trabajada for entry in entries if entry.fecha_salida)
        total_horas = round(total_minutos / 60, 2)
        total_dias = entries.filter(fecha_salida__isnull=False).count()
    else:
        total_horas = 0
        total_dias = 0
    
    context = {
        'page_obj': page_obj,
        'fecha_desde': fecha_desde,
        'fecha_hasta': fecha_hasta,
        'total_horas': total_horas,
        'total_dias': total_dias,
        'page_title': 'Mis Registros de Horario'
    }
    
    return render(request, 'tickets/time_entries_list.html', context)


@login_required
def time_entries_export_excel(request):
    """Exportar registros de horario a Excel"""
    
    # Aplicar los mismos filtros que en la lista
    fecha_desde = request.GET.get('fecha_desde')
    fecha_hasta = request.GET.get('fecha_hasta')
    
    # Base queryset - solo registros del usuario actual
    entries = TimeEntry.objects.filter(user=request.user)
    
    # Aplicar filtros de fecha
    if fecha_desde:
        try:
            from datetime import datetime
            fecha_desde_dt = datetime.strptime(fecha_desde, '%Y-%m-%d').date()
            entries = entries.filter(fecha_entrada__date__gte=fecha_desde_dt)
        except ValueError:
            pass
    
    if fecha_hasta:
        try:
            from datetime import datetime
            fecha_hasta_dt = datetime.strptime(fecha_hasta, '%Y-%m-%d').date()
            entries = entries.filter(fecha_entrada__date__lte=fecha_hasta_dt)
        except ValueError:
            pass
    
    # Ordenar por fecha descendente
    entries = entries.order_by('-fecha_entrada')
    
    # Crear el archivo Excel
    import openpyxl
    from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
    from django.http import HttpResponse
    from io import BytesIO
    
    # Crear workbook y worksheet
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Registros de Horario"
    
    # Definir estilos
    header_font = Font(bold=True, color="FFFFFF")
    header_fill = PatternFill(start_color="2F5597", end_color="2F5597", fill_type="solid")
    header_alignment = Alignment(horizontal="center", vertical="center")
    
    border = Border(
        left=Side(style='thin'),
        right=Side(style='thin'),
        top=Side(style='thin'),
        bottom=Side(style='thin')
    )
    
    # Encabezados
    headers = [
        'Fecha',
        'Hora Entrada',
        'Hora Salida', 
        'Duración',
        'Estado',
        'Notas',
        'Proyecto',
        'Ticket',
        'Orden de Trabajo',
        'Tarea'
    ]
    
    # Escribir encabezados
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=1, column=col, value=header)
        cell.font = header_font
        cell.fill = header_fill
        cell.alignment = header_alignment
        cell.border = border
    
    # Escribir datos
    for row, entry in enumerate(entries, 2):
        # Fecha
        ws.cell(row=row, column=1, value=entry.fecha_entrada.strftime('%d/%m/%Y')).border = border
        
        # Hora entrada
        ws.cell(row=row, column=2, value=entry.fecha_entrada.strftime('%H:%M')).border = border
        
        # Hora salida
        salida_str = entry.fecha_salida.strftime('%H:%M') if entry.fecha_salida else 'En curso'
        ws.cell(row=row, column=3, value=salida_str).border = border
        
        # Duración
        if entry.fecha_salida:
            duracion_str = entry.duracion_formateada
        else:
            duracion_str = 'En curso'
        ws.cell(row=row, column=4, value=duracion_str).border = border
        
        # Estado
        estado = 'Finalizada' if entry.fecha_salida else 'Activa'
        ws.cell(row=row, column=5, value=estado).border = border
        
        # Notas
        ws.cell(row=row, column=6, value=entry.notas or '').border = border
        
        # Proyecto
        proyecto_str = str(entry.project) if entry.project else ''
        ws.cell(row=row, column=7, value=proyecto_str).border = border
        
        # Ticket
        ticket_str = f"#{entry.ticket.id} - {entry.ticket.title}" if entry.ticket else ''
        ws.cell(row=row, column=8, value=ticket_str).border = border
        
        # Orden de trabajo
        wo_str = f"#{entry.work_order.id} - {entry.work_order.title}" if entry.work_order else ''
        ws.cell(row=row, column=9, value=wo_str).border = border
        
        # Tarea
        task_str = f"{entry.task.title}" if entry.task else ''
        ws.cell(row=row, column=10, value=task_str).border = border
    
    # Ajustar ancho de columnas
    column_widths = [12, 12, 12, 12, 12, 30, 25, 30, 30, 25]
    for col, width in enumerate(column_widths, 1):
        ws.column_dimensions[openpyxl.utils.get_column_letter(col)].width = width
    
    # Agregar fila de totales si hay datos
    if entries.exists():
        total_row = len(list(entries)) + 3
        
        # Etiquetas de totales
        ws.cell(row=total_row, column=1, value="TOTALES:").font = Font(bold=True)
        
        # Calcular totales
        total_minutos = sum(entry.duracion_trabajada for entry in entries if entry.fecha_salida)
        total_horas = round(total_minutos / 60, 2)
        total_dias = entries.filter(fecha_salida__isnull=False).count()
        
        ws.cell(row=total_row, column=4, value=f"{total_horas}h").font = Font(bold=True)
        ws.cell(row=total_row + 1, column=1, value="Días trabajados:").font = Font(bold=True)
        ws.cell(row=total_row + 1, column=4, value=total_dias).font = Font(bold=True)
    
    # Preparar respuesta HTTP
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    
    # Generar nombre de archivo
    usuario = request.user.get_full_name() or request.user.username
    fecha_actual = timezone.now().strftime('%Y%m%d_%H%M%S')
    filename = f"registros_horario_{usuario.replace(' ', '_')}_{fecha_actual}.xlsx"
    
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    
    # Guardar workbook en response
    wb.save(response)
    
    return response


@login_required
@user_passes_test(is_agent, login_url='dashboard')
def time_entry_detail(request, entry_id):
    """Vista detallada de un registro de horario"""
    
    entry = get_object_or_404(TimeEntry, id=entry_id)
    
    # Verificar permisos - solo el propietario puede ver sus registros
    if not entry.can_view(request.user):
        messages.error(request, 'No tienes permisos para ver este registro.')
        return redirect('time_entries_list')
    
    context = {
        'entry': entry,
        'page_title': f'Registro del {entry.fecha_entrada.strftime("%d/%m/%Y")}'
    }
    
    return render(request, 'tickets/time_entry_detail.html', context)


@login_required
@user_passes_test(is_agent, login_url='dashboard')
def time_entry_edit(request, entry_id):
    """Editar notas de un registro de horario"""
    
    entry = get_object_or_404(TimeEntry, id=entry_id)
    
    # Verificar permisos
    if not entry.can_edit(request.user):
        messages.error(request, 'No tienes permisos para editar este registro.')
        return redirect('time_entry_detail', entry_id=entry.id)
    
    if request.method == 'POST':
        form = TimeEntryEditForm(request.POST, instance=entry, user=request.user)
        if form.is_valid():
            form.save()
            messages.success(request, 'Registro actualizado exitosamente.')
            return redirect('time_entry_detail', entry_id=entry.id)
    else:
        form = TimeEntryEditForm(instance=entry, user=request.user)
    
    context = {
        'form': form,
        'entry': entry,
        'page_title': f'Editar Registro del {entry.fecha_entrada.strftime("%d/%m/%Y")}'
    }
    
    return render(request, 'tickets/time_entry_edit.html', context)


@login_required
@user_passes_test(is_agent, login_url='dashboard')
def ajax_current_time_status(request):
    """API AJAX para obtener el estado actual del tiempo trabajado"""
    
    active_entry = TimeEntry.get_active_entry_for_agent(request.user)
    
    if active_entry:
        return JsonResponse({
            'is_working': True,
            'start_time': active_entry.fecha_entrada.strftime('%H:%M'),
            'duration': active_entry.duracion_formateada,
            'minutes_worked': active_entry.duracion_trabajada
        })
    else:
        return JsonResponse({
            'is_working': False,
            'start_time': None,
            'duration': '00:00',
            'minutes_worked': 0
        })


# ===========================================
# VISTAS PÚBLICAS DE CONTROL DE HORARIO
# ===========================================

def public_time_clock(request, token):
    """Vista pública para control de horario usando token"""
    
    # Buscar el acceso público por token
    try:
        public_access = PublicTimeAccess.objects.get(token=token, is_active=True)
    except PublicTimeAccess.DoesNotExist:
        return render(request, 'tickets/public_time_error.html', {
            'error_title': 'Token no válido',
            'error_message': 'El enlace que estás usando no es válido o ha expirado.'
        }, status=404)
    
    # Verificar IP permitida (si está configurado)
    client_ip = get_client_ip(request)
    if not public_access.is_ip_allowed(client_ip):
        return render(request, 'tickets/public_time_error.html', {
            'error_title': 'Acceso no autorizado',
            'error_message': 'Tu dirección IP no está autorizada para usar este enlace.'
        }, status=403)
    
    user = public_access.user
    
    # Obtener estado actual del usuario
    active_entry = TimeEntry.get_active_entry(user)
    
    # Procesar formulario
    if request.method == 'POST':
        form = PublicTimeEntryForm(request.POST, public_access=public_access)
        if form.is_valid():
            action = form.cleaned_data['action']
            notes = form.cleaned_data.get('notes', '')
            latitude = form.cleaned_data.get('latitude')
            longitude = form.cleaned_data.get('longitude')
            
            try:
                if action == 'entrada':
                    # Verificar que no haya una jornada activa
                    if active_entry:
                        return render(request, 'tickets/public_time_error.html', {
                            'error_title': 'Ya tienes una jornada activa',
                            'error_message': f'Tu jornada comenzó a las {active_entry.fecha_entrada.strftime("%H:%M")}. Debes registrar la salida primero.',
                            'token': token
                        })
                    
                    # Crear nueva entrada (solo hora de entrada) usando método público
                    entry = TimeEntry.create_public_entry(
                        user=user,
                        notas_entrada=notes
                    )
                    
                    # Guardar ubicación si se proporcionó
                    if latitude and longitude:
                        entry.ubicacion_entrada = f"{latitude},{longitude}"
                        entry.save()
                    
                    # Actualizar último uso
                    public_access.update_last_used()
                    
                    return render(request, 'tickets/public_time_success.html', {
                        'action': 'entrada',
                        'time': entry.fecha_entrada.strftime('%H:%M'),
                        'user': user,
                        'notes': notes,
                        'token': token
                    })
                
                elif action == 'salida':
                    # Verificar que haya una jornada activa
                    if not active_entry:
                        return render(request, 'tickets/public_time_error.html', {
                            'error_title': 'No hay jornada activa',
                            'error_message': 'No tienes una jornada activa para finalizar. Registra tu entrada primero.',
                            'token': token
                        })
                    
                    # Actualizar la entrada existente con la hora de salida
                    active_entry.finalizar_jornada(notes)
                    
                    # Guardar ubicación de salida si se proporcionó
                    if latitude and longitude:
                        active_entry.ubicacion_salida = f"{latitude},{longitude}"
                        active_entry.save()
                    
                    # Actualizar último uso
                    public_access.update_last_used()
                    
                    return render(request, 'tickets/public_time_success.html', {
                        'action': 'salida',
                        'time': active_entry.fecha_salida.strftime('%H:%M'),
                        'duration': active_entry.duracion_formateada,
                        'user': user,
                        'notes': notes,
                        'token': token
                    })
                    
            except Exception as e:
                return render(request, 'tickets/public_time_error.html', {
                    'error_title': 'Error al procesar',
                    'error_message': f'Ocurrió un error: {str(e)}',
                    'token': token
                })
    else:
        form = PublicTimeEntryForm(public_access=public_access)
    
    # Estadísticas del día
    from datetime import date
    today = date.today()
    today_entries = TimeEntry.objects.filter(
        user=user,
        fecha_entrada__date=today
    ).order_by('-fecha_entrada')
    
    context = {
        'user': user,
        'active_entry': active_entry,
        'public_access': public_access,
        'form': form,
        'today_entries': today_entries,
        'token': token,
        'require_location': public_access.require_location,
    }
    
    return render(request, 'tickets/public_time_clock.html', context)


def get_client_ip(request):
    """Obtener la IP real del cliente"""
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0]
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip


@login_required
@user_passes_test(is_agent, login_url='dashboard')
def public_time_access_list(request):
    """Vista para listar y gestionar accesos públicos de control de horario (solo agentes)"""
    
    access_list = PublicTimeAccess.objects.select_related('user').order_by('-created_at')
    
    # Búsqueda
    search = request.GET.get('search')
    if search:
        access_list = access_list.filter(
            Q(user__username__icontains=search) |
            Q(user__first_name__icontains=search) |
            Q(user__last_name__icontains=search) |
            Q(user__email__icontains=search)
        )
    
    # Filtro por estado
    status = request.GET.get('status')
    if status == 'active':
        access_list = access_list.filter(is_active=True)
    elif status == 'inactive':
        access_list = access_list.filter(is_active=False)
    
    # Paginación
    paginator = Paginator(access_list, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_obj': page_obj,
        'search': search,
        'status': status,
        'page_title': 'Gestión de Accesos Públicos de Horario'
    }
    
    return render(request, 'tickets/public_time_access_list.html', context)


@login_required
@user_passes_test(is_agent, login_url='dashboard')
def public_time_access_create(request, user_id):
    """Crear acceso público para un usuario específico"""
    
    user = get_object_or_404(User, id=user_id)
    
    # Verificar si ya existe un acceso para este usuario
    if hasattr(user, 'public_time_access'):
        messages.warning(request, f'{user.get_full_name() or user.username} ya tiene un acceso público configurado.')
        return redirect('public_time_access_list')
    
    if request.method == 'POST':
        form = PublicTimeAccessForm(request.POST)
        if form.is_valid():
            access = form.save(commit=False)
            access.user = user
            access.save()
            
            messages.success(request, f'Acceso público creado para {user.get_full_name() or user.username}')
            return redirect('public_time_access_list')
    else:
        form = PublicTimeAccessForm()
    
    context = {
        'form': form,
        'user': user,
        'page_title': f'Crear Acceso Público para {user.get_full_name() or user.username}'
    }
    
    return render(request, 'tickets/public_time_access_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='dashboard')
def public_time_access_edit(request, access_id):
    """Editar acceso público existente"""
    
    access = get_object_or_404(PublicTimeAccess, id=access_id)
    
    if request.method == 'POST':
        form = PublicTimeAccessForm(request.POST, instance=access)
        if form.is_valid():
            form.save()
            messages.success(request, f'Acceso público actualizado para {access.user.get_full_name() or access.user.username}')
            return redirect('public_time_access_list')
    else:
        form = PublicTimeAccessForm(instance=access)
    
    context = {
        'form': form,
        'access': access,
        'page_title': f'Editar Acceso Público - {access.user.get_full_name() or access.user.username}'
    }
    
    return render(request, 'tickets/public_time_access_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='dashboard')
def public_time_access_delete(request, access_id):
    """Eliminar acceso público"""
    
    access = get_object_or_404(PublicTimeAccess, id=access_id)
    
    if request.method == 'POST':
        user_name = access.user.get_full_name() or access.user.username
        access.delete()
        messages.success(request, f'Acceso público eliminado para {user_name}')
        return redirect('public_time_access_list')
    
    context = {
        'access': access,
        'page_title': 'Confirmar Eliminación'
    }
    
    return render(request, 'tickets/public_time_access_delete.html', context)


# ===========================================
# VISTAS DE GESTIÓN DE PROYECTOS
# ===========================================

@login_required
@user_passes_test(is_agent, login_url='ticket_list')
def project_list(request):
    """Vista para listar todos los proyectos (solo agentes)"""
    projects = Project.objects.all()
    
    # Búsqueda
    search_query = request.GET.get('search', '')
    if search_query:
        projects = projects.filter(
            Q(name__icontains=search_query) |
            Q(description__icontains=search_query)
        )
    
    # Filtro por estado
    status_filter = request.GET.get('status', '')
    if status_filter:
        projects = projects.filter(status=status_filter)
    
    # Paginación
    paginator = Paginator(projects, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Obtener configuración del sistema
    from tickets.models import SystemConfiguration
    system_config = SystemConfiguration.get_config()
    
    context = {
        'page_title': 'Gestión de Proyectos',
        'page_obj': page_obj,
        'search_query': search_query,
        'status_filter': status_filter,
        'project_status_choices': Project.STATUS_CHOICES,
        'system_config': system_config,
    }
    
    return render(request, 'tickets/project_list.html', context)


@login_required
@user_passes_test(is_agent, login_url='ticket_list')
def project_create(request):
    """Vista para crear un nuevo proyecto (solo agentes)"""
    if request.method == 'POST':
        form = ProjectForm(request.POST)
        if form.is_valid():
            project = form.save(created_by=request.user)
            messages.success(request, f'Proyecto "{project.name}" creado exitosamente.')
            return redirect('project_list')
    else:
        form = ProjectForm()
    
    context = {
        'page_title': 'Crear Nuevo Proyecto',
        'form': form,
        'action': 'create'
    }
    
    return render(request, 'tickets/project_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='ticket_list')
def project_edit(request, project_id):
    """Vista para editar un proyecto existente (solo agentes)"""
    project = get_object_or_404(Project, id=project_id)
    
    # Verificar permisos
    if not project.can_edit(request.user):
        messages.error(request, 'No tienes permisos para editar este proyecto.')
        return redirect('project_list')
    
    if request.method == 'POST':
        form = ProjectForm(request.POST, instance=project)
        if form.is_valid():
            form.save()
            messages.success(request, f'Proyecto "{project.name}" actualizado exitosamente.')
            return redirect('project_list')
    else:
        form = ProjectForm(instance=project)
    
    context = {
        'page_title': f'Editar Proyecto: {project.name}',
        'form': form,
        'project': project,
        'action': 'edit'
    }
    
    return render(request, 'tickets/project_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='ticket_list')
def project_detail(request, project_id):
    """Vista para ver detalles de un proyecto"""
    project = get_object_or_404(Project, id=project_id)
    
    # Obtener registros de tiempo de este proyecto
    time_entries = project.time_entries.filter(
        fecha_salida__isnull=False
    ).order_by('-fecha_entrada')[:10]
    
    # Obtener trabajadores activos en este proyecto
    active_workers = project.time_entries.filter(
        fecha_salida__isnull=True
    ).select_related('user')
    
    context = {
        'page_title': f'Proyecto: {project.name}',
        'project': project,
        'time_entries': time_entries,
        'active_workers': active_workers,
        'total_hours': project.get_total_hours(),
        'active_workers_count': project.get_active_workers_count(),
        'can_edit_project': project.can_edit(request.user) if request.user.is_authenticated else False,
    }
    
    return render(request, 'tickets/project_detail.html', context)


@login_required
@user_passes_test(is_agent, login_url='ticket_list')
def project_delete(request, project_id):
    """Vista para eliminar un proyecto (solo agentes)"""
    project = get_object_or_404(Project, id=project_id)
    
    # Verificar permisos
    if not project.can_delete(request.user):
        messages.error(request, 'No tienes permisos para eliminar este proyecto.')
        return redirect('project_list')
    
    # Verificar si hay registros de tiempo asociados
    if project.time_entries.exists():
        messages.error(request, 
            'No se puede eliminar el proyecto porque tiene registros de tiempo asociados. '
            'Considera marcarlo como inactivo en su lugar.')
        return redirect('project_detail', project_id=project.id)
    
    if request.method == 'POST':
        project_name = project.name
        project.delete()
        messages.success(request, f'Proyecto "{project_name}" eliminado exitosamente.')
        return redirect('project_list')
    
    context = {
        'page_title': f'Eliminar Proyecto: {project.name}',
        'project': project,
    }
    
    return render(request, 'tickets/project_delete.html', context)


@login_required
@user_passes_test(is_agent, login_url='ticket_list')
def project_generate_public_token(request, project_id):
    """Vista para generar o regenerar el token público de un proyecto"""
    project = get_object_or_404(Project, id=project_id)
    
    # Verificar permisos
    if not project.can_edit(request.user):
        messages.error(request, 'No tienes permisos para gestionar este proyecto.')
        return redirect('project_detail', project_id=project.id)
    
    if request.method == 'POST':
        # Generar nuevo token (esto también actualizará uno existente)
        import secrets
        project.public_share_token = secrets.token_urlsafe(32)
        project.save()
        
        messages.success(request, 
            'Enlace público generado exitosamente. '
            'Ahora puedes compartir este proyecto con información básica sin necesidad de iniciar sesión.')
    
    return redirect('project_detail', project_id=project.id)


@login_required
@user_passes_test(is_agent, login_url='ticket_list')
def project_duplicate(request, project_id):
    """Vista para duplicar un proyecto con todas sus tareas"""
    original_project = get_object_or_404(Project, id=project_id)
    
    # Verificar permisos
    if not original_project.can_edit(request.user):
        messages.error(request, 'No tienes permisos para duplicar este proyecto.')
        return redirect('project_detail', project_id=project_id)
    
    if request.method == 'POST':
        try:
            # Crear el proyecto duplicado
            duplicated_project = Project.objects.create(
                name=f"Copia de {original_project.name}",
                description=original_project.description,
                company=original_project.company,
                status=original_project.status,
                start_date=original_project.start_date,
                end_date=original_project.end_date,
                color=original_project.color,
                is_active=True,  # El proyecto duplicado siempre empieza activo
                created_by=request.user,
                # No copiamos el token público por seguridad
                public_share_token=None,
                # No copiamos precios ya que son específicos del proyecto original
                precio_hora=original_project.precio_hora,
                costo_hora=original_project.costo_hora,
            )
            
            # Duplicar las tareas del cronograma si existen
            original_schedules = TaskSchedule.objects.filter(project=original_project)
            
            for original_schedule in original_schedules:
                # Crear cronograma duplicado
                duplicated_schedule = TaskSchedule.objects.create(
                    title=f"Copia de {original_schedule.title}",
                    description=original_schedule.description,
                    project=duplicated_project,
                    company=original_schedule.company,
                    start_date=original_schedule.start_date,
                    end_date=original_schedule.end_date,
                    is_public=False,  # Por seguridad, no hacer público automáticamente
                    created_by=request.user,
                    # No copiamos el token público
                    public_token=None,
                )
                
                # Duplicar las tareas del cronograma
                original_tasks = ScheduleTask.objects.filter(schedule=original_schedule)
                task_map = {}  # Para mapear dependencias
                
                # Primer paso: crear todas las tareas sin dependencias
                for original_task in original_tasks:
                    duplicated_task = ScheduleTask.objects.create(
                        schedule=duplicated_schedule,
                        title=original_task.title,
                        description=original_task.description,
                        start_date=original_task.start_date,
                        end_date=original_task.end_date,
                        priority=original_task.priority,
                        assigned_to=original_task.assigned_to,
                        is_completed=False,  # Las tareas duplicadas empiezan como no completadas
                        progress_percentage=0,  # Progreso en 0
                    )
                    task_map[original_task.id] = duplicated_task
                
                # Segundo paso: establecer dependencias
                for original_task in original_tasks:
                    duplicated_task = task_map[original_task.id]
                    for dependency in original_task.dependencies.all():
                        if dependency.id in task_map:
                            duplicated_task.dependencies.add(task_map[dependency.id])
            
            messages.success(
                request, 
                f'Proyecto "{duplicated_project.name}" duplicado exitosamente con todas sus tareas. '
                f'Se han copiado {TaskSchedule.objects.filter(project=duplicated_project).count()} cronogramas.'
            )
            
            # Redirigir al nuevo proyecto duplicado
            return redirect('project_detail', project_id=duplicated_project.id)
            
        except Exception as e:
            messages.error(request, f'Error al duplicar el proyecto: {str(e)}')
            return redirect('project_detail', project_id=project_id)
    
    # Si es GET, mostrar confirmación
    context = {
        'page_title': f'Duplicar Proyecto: {original_project.name}',
        'project': original_project,
        'schedules_count': TaskSchedule.objects.filter(project=original_project).count(),
        'total_tasks_count': ScheduleTask.objects.filter(schedule__project=original_project).count(),
    }
    
    return render(request, 'tickets/project_duplicate_confirm.html', context)


# ========================
# GESTIÓN DE PRODUCTOS
# ========================

@login_required
@user_passes_test(is_agent, login_url='/')
def product_list(request):
    """Lista todos los productos"""
    from .models import Product, SystemConfiguration
    
    # Obtener configuración del sistema para la moneda
    config = SystemConfiguration.objects.first()
    currency_symbol = config.get_currency_symbol() if config else '€'
    
    # Filtros
    search = request.GET.get('search', '')
    status = request.GET.get('status', 'all')
    
    # Base queryset
    queryset = Product.objects.select_related('created_by').all()
    
    # Aplicar filtros
    if search:
        queryset = queryset.filter(
            Q(name__icontains=search) | 
            Q(description__icontains=search)
        )
    
    if status == 'active':
        queryset = queryset.filter(is_active=True)
    elif status == 'inactive':
        queryset = queryset.filter(is_active=False)
    
    # Ordenar por fecha de creación
    queryset = queryset.order_by('-created_at')
    
    # Paginación
    paginator = Paginator(queryset, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_title': 'Gestión de Productos',
        'page_obj': page_obj,
        'search': search,
        'status': status,
        'total_products': Product.objects.count(),
        'active_products': Product.objects.filter(is_active=True).count(),
        'inactive_products': Product.objects.filter(is_active=False).count(),
        'currency_symbol': currency_symbol,
    }
    return render(request, 'tickets/product_list.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def product_create(request):
    """Crear un nuevo producto"""
    from .forms import ProductForm
    from .models import Product, SystemConfiguration
    
    # Obtener configuración del sistema para la moneda
    config = SystemConfiguration.objects.first()
    currency_symbol = config.get_currency_symbol() if config else '€'
    
    if request.method == 'POST':
        form = ProductForm(request.POST)
        if form.is_valid():
            product = form.save(commit=False)
            product.created_by = request.user
            product.save()
            messages.success(request, f'Producto "{product.name}" creado exitosamente.')
            return redirect('product_list')
    else:
        form = ProductForm()
    
    context = {
        'page_title': 'Crear Producto',
        'form': form,
        'currency_symbol': currency_symbol,
    }
    return render(request, 'tickets/product_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def product_edit(request, product_id):
    """Editar un producto existente"""
    from .forms import ProductForm
    from .models import Product, SystemConfiguration
    
    product = get_object_or_404(Product, pk=product_id)
    
    # Obtener configuración del sistema para la moneda
    config = SystemConfiguration.objects.first()
    currency_symbol = config.get_currency_symbol() if config else '€'
    
    if request.method == 'POST':
        form = ProductForm(request.POST, instance=product)
        if form.is_valid():
            product = form.save()
            messages.success(request, f'Producto "{product.name}" actualizado exitosamente.')
            return redirect('product_list')
    else:
        form = ProductForm(instance=product)
    
    context = {
        'page_title': f'Editar Producto: {product.name}',
        'form': form,
        'product': product,
        'currency_symbol': currency_symbol,
    }
    return render(request, 'tickets/product_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def product_detail(request, product_id):
    """Ver detalles de un producto"""
    from .models import Product, SystemConfiguration
    
    product = get_object_or_404(Product, pk=product_id)
    
    # Obtener configuración del sistema para la moneda
    config = SystemConfiguration.objects.first()
    currency_symbol = config.get_currency_symbol() if config else '€'
    
    context = {
        'page_title': f'Producto: {product.name}',
        'product': product,
        'currency_symbol': currency_symbol,
    }
    return render(request, 'tickets/product_detail.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def product_delete(request, product_id):
    """Eliminar un producto"""
    from .models import Product
    
    product = get_object_or_404(Product, pk=product_id)
    
    if request.method == 'POST':
        product_name = product.name
        product.delete()
        messages.success(request, f'Producto "{product_name}" eliminado exitosamente.')
        return redirect('product_list')
    
    context = {
        'page_title': f'Eliminar Producto: {product.name}',
        'product': product,
    }
    return render(request, 'tickets/product_delete.html', context)


@login_required
@user_passes_test(is_agent, login_url='dashboard')
def attendance_overview(request):
    """Vista para que los agentes vean la asistencia de todos los empleados"""
    from django.db.models import Q
    from datetime import datetime, timedelta
    
    # Filtros de fecha
    fecha_desde = request.GET.get('fecha_desde')
    fecha_hasta = request.GET.get('fecha_hasta')
    proyecto_id = request.GET.get('proyecto')
    usuario_id = request.GET.get('usuario')
    
    # Si no hay fechas, mostrar los últimos 7 días
    if not fecha_desde:
        fecha_desde = (timezone.now() - timedelta(days=7)).date()
    else:
        fecha_desde = datetime.strptime(fecha_desde, '%Y-%m-%d').date()
    
    if not fecha_hasta:
        fecha_hasta = timezone.now().date()
    else:
        fecha_hasta = datetime.strptime(fecha_hasta, '%Y-%m-%d').date()
    
    # Base queryset
    queryset = TimeEntry.objects.select_related('user', 'project').filter(
        fecha_entrada__date__gte=fecha_desde,
        fecha_entrada__date__lte=fecha_hasta
    ).order_by('-fecha_entrada')
    
    # Filtro por proyecto
    if proyecto_id:
        queryset = queryset.filter(project_id=proyecto_id)
    
    # Filtro por usuario
    if usuario_id:
        queryset = queryset.filter(user_id=usuario_id)
    
    # Obtener estadísticas
    total_entries = queryset.count()
    active_entries = queryset.filter(fecha_salida__isnull=True).count()
    
    # Calcular total de horas y promedio
    total_hours = 0
    completed_entries = 0
    completed_hours = 0
    
    for entry in queryset:
        if entry.fecha_salida:
            # Jornada completada
            duration = (entry.fecha_salida - entry.fecha_entrada).total_seconds()
            completed_hours += duration
            completed_entries += 1
        else:
            # Jornada activa - solo para el total
            duration = (timezone.now() - entry.fecha_entrada).total_seconds()
        
        total_hours += duration
    
    total_hours = round(total_hours / 3600, 2)
    
    # Calcular promedio por jornada (solo jornadas completadas)
    if completed_entries > 0:
        avg_hours_per_session = round(completed_hours / 3600 / completed_entries, 2)
    else:
        avg_hours_per_session = 0
    
    # Paginación
    paginator = Paginator(queryset, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Datos para filtros
    proyectos = Project.objects.filter(is_active=True).order_by('name')
    usuarios = User.objects.filter(
        groups__name='Agentes'
    ).order_by('first_name', 'username')
    
    context = {
        'page_title': 'Control de Asistencia General',
        'page_obj': page_obj,
        'total_entries': total_entries,
        'active_entries': active_entries,
        'total_hours': total_hours,
        'avg_hours_per_session': avg_hours_per_session,
        'fecha_desde': fecha_desde.strftime('%Y-%m-%d'),
        'fecha_hasta': fecha_hasta.strftime('%Y-%m-%d'),
        'proyectos': proyectos,
        'usuarios': usuarios,
        'proyecto_seleccionado': proyecto_id,
        'usuario_seleccionado': usuario_id,
    }
    
    return render(request, 'tickets/attendance_overview.html', context)



# =============================================================================
# VISTAS PARA GESTIÓN DE EMPRESAS (SOLO AGENTES)
# =============================================================================

@login_required
@user_passes_test(is_agent, login_url='/')
def company_list_view(request):
    """Vista para listar todas las empresas"""
    search_query = request.GET.get('search', '').strip()
    status_filter = request.GET.get('status', 'all')
    
    # Filtro base
    queryset = Company.objects.all().order_by('name')
    
    # Aplicar filtros
    if search_query:
        queryset = queryset.filter(
            Q(name__icontains=search_query) |
            Q(description__icontains=search_query) |
            Q(email__icontains=search_query)
        )
    
    if status_filter == 'active':
        queryset = queryset.filter(is_active=True)
    elif status_filter == 'inactive':
        queryset = queryset.filter(is_active=False)
    
    # Paginación
    paginator = Paginator(queryset, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Estadísticas
    total_companies = Company.objects.count()
    active_companies = Company.objects.filter(is_active=True).count()
    
    context = {
        'page_title': 'Gestión de Empresas',
        'page_obj': page_obj,
        'search_query': search_query,
        'status_filter': status_filter,
        'total_companies': total_companies,
        'active_companies': active_companies,
    }
    
    return render(request, 'tickets/company_list.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def company_create_view(request):
    """Vista para crear una nueva empresa"""
    if request.method == 'POST':
        form = CompanyForm(request.POST, request.FILES)
        if form.is_valid():
            company = form.save()
            messages.success(request, f'La empresa "{company.name}" ha sido creada exitosamente.')
            return redirect('company_list')
    else:
        form = CompanyForm()
    
    context = {
        'page_title': 'Crear Nueva Empresa',
        'form': form,
        'is_create': True,
    }
    
    return render(request, 'tickets/company_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def company_detail_view(request, company_id):
    """Vista para ver detalles de una empresa"""
    company = get_object_or_404(Company, id=company_id)
    
    # Generar public_token si no existe
    if not company.public_token:
        import uuid
        company.public_token = uuid.uuid4()
        company.save()
    
    # Manejar actualización de objetivos empresariales (POST)
    if request.method == 'POST' and request.POST.get('action') == 'update_objectives':
        if is_agent(request.user):
            business_objectives = request.POST.get('business_objectives', '').strip()
            company.business_objectives = business_objectives
            company.save()
            messages.success(request, f'✅ Objetivos empresariales de "{company.name}" actualizados exitosamente.')
        else:
            messages.error(request, '❌ No tienes permisos para modificar esta empresa.')
        return redirect('company_detail', company_id=company.id)
    
    # Estadísticas de la empresa
    total_tickets = company.tickets.count()
    open_tickets = company.tickets.filter(status='open').count()
    total_users = company.users.count()
    active_users = company.users.filter(user__is_active=True).count()
    
    # Tickets recientes
    recent_tickets = company.tickets.select_related(
        'created_by', 'assigned_to', 'category'
    ).order_by('-created_at')[:10]
    
    # Usuarios de la empresa
    company_users = company.users.select_related('user').order_by('user__first_name', 'user__username')
    
    context = {
        'page_title': f'Empresa: {company.name}',
        'company': company,
        'total_tickets': total_tickets,
        'open_tickets': open_tickets,
        'total_users': total_users,
        'active_users': active_users,
        'recent_tickets': recent_tickets,
        'company_users': company_users,
        'is_agent': is_agent(request.user),
    }
    
    return render(request, 'tickets/company_detail.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def company_edit_view(request, company_id):
    """Vista para editar una empresa"""
    company = get_object_or_404(Company, id=company_id)
    
    if request.method == 'POST':
        form = CompanyForm(request.POST, request.FILES, instance=company)
        if form.is_valid():
            form.save()
            messages.success(request, f'La empresa "{company.name}" ha sido actualizada exitosamente.')
            return redirect('company_detail', company_id=company.id)
    else:
        form = CompanyForm(instance=company)
    
    context = {
        'page_title': f'Editar Empresa: {company.name}',
        'form': form,
        'company': company,
        'is_create': False,
    }
    
    return render(request, 'tickets/company_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def company_delete_view(request, company_id):
    """Vista para eliminar una empresa"""
    company = get_object_or_404(Company, id=company_id)
    
    # Verificar si la empresa tiene tickets o usuarios asociados
    has_tickets = company.tickets.exists()
    has_users = company.users.exists()
    
    if request.method == 'POST':
        if has_tickets or has_users:
            messages.error(
                request, 
                f'No se puede eliminar la empresa "{company.name}" porque tiene tickets o usuarios asociados. '
                'Desactívala en su lugar.'
            )
        else:
            company_name = company.name
            company.delete()
            messages.success(request, f'La empresa "{company_name}" ha sido eliminada exitosamente.')
            return redirect('company_list')
    
    context = {
        'page_title': f'Eliminar Empresa: {company.name}',
        'company': company,
        'has_tickets': has_tickets,
        'has_users': has_users,
    }
    
    return render(request, 'tickets/company_delete.html', context)


# =============================================================================
# VISTAS PARA CONFIGURACIÓN DEL SISTEMA (SOLO AGENTES)
# =============================================================================

@login_required
@user_passes_test(is_agent, login_url='/')
def system_configuration_view(request):
    """Vista para configurar el sistema"""
    config = SystemConfiguration.get_config()
    
    if request.method == 'POST':
        # Verificar si es una prueba de Telegram
        if 'test_telegram' in request.POST:
            from .telegram_utils import test_telegram_connection
            bot_token = request.POST.get('telegram_bot_token', '').strip()
            chat_id = request.POST.get('telegram_chat_id', '').strip()
            
            result = test_telegram_connection(bot_token, chat_id)
            
            if result['success']:
                messages.success(request, result['message'])
            else:
                messages.error(request, result['message'])
            
            return redirect('system_configuration')
        
        # Verificar si es una prueba de email
        if 'test_email' in request.POST:
            try:
                from .utils import send_contact_notification
                from .models import ContactoWeb
                
                # Crear un contacto de prueba temporal
                contacto_prueba = ContactoWeb(
                    nombre='Prueba del Sistema',
                    email='prueba@sistema.local',
                    telefono='+34 600 000 000',
                    empresa='Sistema TicketProo',
                    asunto='Prueba de notificación por email',
                    mensaje='Este es un mensaje de prueba generado desde la configuración del sistema.',
                    ip_address='127.0.0.1',
                    user_agent='System Configuration Test'
                )
                
                # Intentar enviar la notificación sin guardar el contacto
                result = send_contact_notification(contacto_prueba)
                
                if result:
                    messages.success(request, '✅ Email de prueba enviado exitosamente. Revisa los emails configurados.')
                else:
                    messages.error(request, '❌ Error enviando el email de prueba. Revisa la configuración.')
                    
            except Exception as e:
                messages.error(request, f'❌ Error en la prueba de email: {str(e)}')
            
            return redirect('system_configuration')
        
        # Procesar formulario normal
        form = SystemConfigurationForm(request.POST, instance=config)
        if form.is_valid():
            form.save()
            messages.success(request, 'La configuración del sistema ha sido actualizada exitosamente.')
            return redirect('system_configuration')
    else:
        form = SystemConfigurationForm(instance=config)
    
    context = {
        'page_title': 'Configuración del Sistema',
        'form': form,
        'config': config,
    }
    
    return render(request, 'tickets/system_configuration.html', context)


# =============================================================================
# VISTAS PARA GESTIÓN DE DOCUMENTOS
# =============================================================================

@login_required
@user_passes_test(is_agent, login_url='/')
def document_list_view(request):
    """Vista para listar todos los documentos"""
    search_query = request.GET.get('search', '').strip()
    company_filter = request.GET.get('company', '')
    tag_filter = request.GET.get('tag', '').strip()
    
    # Filtro base
    queryset = Document.objects.select_related('created_by', 'company').order_by('-created_at')
    
    # Aplicar filtros
    if search_query:
        queryset = queryset.filter(
            Q(title__icontains=search_query) |
            Q(description__icontains=search_query) |
            Q(tags__icontains=search_query)
        )
    
    if company_filter:
        if company_filter == 'none':
            queryset = queryset.filter(company__isnull=True)
        else:
            queryset = queryset.filter(company_id=company_filter)
    
    if tag_filter:
        queryset = queryset.filter(tags__icontains=tag_filter)
    
    # Paginación
    paginator = Paginator(queryset, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Datos para filtros
    companies = Company.objects.filter(is_active=True).order_by('name')
    
    # Obtener todas las etiquetas únicas
    all_tags = set()
    for doc in Document.objects.exclude(tags=''):
        for tag in doc.get_tags_list():
            all_tags.add(tag)
    all_tags = sorted(list(all_tags))
    
    context = {
        'page_title': 'Gestión de Documentos',
        'page_obj': page_obj,
        'search_query': search_query,
        'company_filter': company_filter,
        'tag_filter': tag_filter,
        'companies': companies,
        'all_tags': all_tags,
        'total_documents': Document.objects.count(),
    }
    
    return render(request, 'tickets/document_list.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def document_create_view(request):
    """Vista para crear un nuevo documento"""
    if request.method == 'POST':
        form = DocumentForm(request.POST, request.FILES)
        if form.is_valid():
            document = form.save(commit=False)
            document.created_by = request.user
            document.save()
            messages.success(request, f'El documento "{document.title}" ha sido creado exitosamente.')
            return redirect('document_list')
    else:
        form = DocumentForm()
    
    context = {
        'page_title': 'Subir Nuevo Documento',
        'form': form,
        'is_create': True,
    }
    
    return render(request, 'tickets/document_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def document_detail_view(request, document_id):
    """Vista para ver detalles de un documento"""
    document = get_object_or_404(Document, id=document_id)
    
    context = {
        'page_title': f'Documento: {document.title}',
        'document': document,
    }
    
    return render(request, 'tickets/document_detail.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def document_edit_view(request, document_id):
    """Vista para editar un documento"""
    document = get_object_or_404(Document, id=document_id)
    
    if request.method == 'POST':
        form = DocumentForm(request.POST, request.FILES, instance=document)
        if form.is_valid():
            form.save()
            messages.success(request, f'El documento "{document.title}" ha sido actualizado exitosamente.')
            return redirect('document_detail', document_id=document.id)
    else:
        form = DocumentForm(instance=document)
    
    context = {
        'page_title': f'Editar Documento: {document.title}',
        'form': form,
        'document': document,
        'is_create': False,
    }
    
    return render(request, 'tickets/document_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def document_delete_view(request, document_id):
    """Vista para eliminar un documento"""
    document = get_object_or_404(Document, id=document_id)
    
    if request.method == 'POST':
        document_title = document.title
        # Eliminar archivo físico
        if document.file:
            document.file.delete(save=False)
        document.delete()
        messages.success(request, f'El documento "{document_title}" ha sido eliminado exitosamente.')
        return redirect('document_list')
    
    context = {
        'page_title': f'Eliminar Documento: {document.title}',
        'document': document,
    }
    
    return render(request, 'tickets/document_delete.html', context)


def document_public_view(request, token):
    """Vista pública para compartir documentos sin autenticación"""
    document = get_object_or_404(Document, public_share_token=token, is_public=True)
    
    context = {
        'document': document,
        'page_title': f'Documento Compartido: {document.title}',
    }
    
    return render(request, 'tickets/document_public.html', context)


def document_download_view(request, token):
    """Vista para descargar documentos públicos"""
    document = get_object_or_404(Document, public_share_token=token, is_public=True)
    
    # Incrementar contador de descargas
    document.increment_download_count()
    
    # Servir el archivo
    from django.http import HttpResponse, Http404
    import os
    
    if not document.file or not os.path.exists(document.file.path):
        raise Http404("Archivo no encontrado")
    
    response = HttpResponse(
        document.file.read(),
        content_type='application/octet-stream'
    )
    response['Content-Disposition'] = f'attachment; filename="{document.file.name}"'
    
    return response


@login_required
@user_passes_test(is_agent, login_url='/')
def document_download_private_view(request, document_id):
    """Vista para descargar documentos con autenticación"""
    document = get_object_or_404(Document, id=document_id)
    
    # Incrementar contador de descargas
    document.increment_download_count()
    
    # Servir el archivo
    from django.http import HttpResponse, Http404
    import os
    
    if not document.file or not os.path.exists(document.file.path):
        raise Http404("Archivo no encontrado")
    
    response = HttpResponse(
        document.file.read(),
        content_type='application/octet-stream'
    )
    response['Content-Disposition'] = f'attachment; filename="{document.file.name}"'
    
    return response


# VIEWS PARA GESTIÓN DE URLs CON CREDENCIALES

@login_required
@user_passes_test(is_agent, login_url='/')
def url_manager_list_view(request):
    """Lista todas las URLs gestionadas (solo para agentes)"""
    from .models import UrlManager
    from .forms import UrlManagerFilterForm
    from django.db.models import Q
    
    # Obtener filtros
    form = UrlManagerFilterForm(request.GET)
    urls = UrlManager.objects.all()
    
    # Aplicar filtros
    if form.is_valid():
        search = form.cleaned_data.get('search')
        category = form.cleaned_data.get('category')
        is_active = form.cleaned_data.get('is_active')
        
        if search:
                       urls = urls.filter(
                Q(title__icontains=search) |
                Q(url__icontains=search) |
                Q(description__icontains=search) |
                Q(username__icontains=search)
            )
        
        if category:
            urls = urls.filter(category__icontains=category)
        
        if is_active:
            urls = urls.filter(is_active=is_active == 'True')
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(urls, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Obtener categorías únicas para el filtro
    categories = UrlManager.objects.values_list('category', flat=True).distinct().exclude(category__isnull=True).exclude(category='')
    
    context = {
        'page_obj': page_obj,
        'form': form,
        'categories': categories,
        'search_query': form.cleaned_data.get('search', '') if form.is_valid() else '',
        'category_filter': form.cleaned_data.get('category', '') if form.is_valid() else '',
        'status_filter': form.cleaned_data.get('is_active', '') if form.is_valid() else '',
        'page_title': 'Gestión de URLs'
    }
    
    return render(request, 'tickets/url_manager_list.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def url_manager_create_view(request):
    """Crear nueva URL gestionada (solo para agentes)"""
    from .models import UrlManager
    from .forms import UrlManagerForm
    
    if request.method == 'POST':
        form = UrlManagerForm(request.POST)
        if form.is_valid():
            url_manager = form.save(commit=False)
            url_manager.created_by = request.user
            url_manager.save()
            
            messages.success(request, f'URL "{url_manager.title}" creada exitosamente.')
            return redirect('url_manager_list')
    else:
        form = UrlManagerForm()
    
    context = {
        'form': form,
        'page_title': 'Crear Nueva URL',
        'action': 'Crear'
    }
    
    return render(request, 'tickets/url_manager_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def url_manager_edit_view(request, url_id):
    """Editar URL gestionada (solo para agentes)"""
    from .models import UrlManager
    from .forms import UrlManagerForm
    
    url_manager = get_object_or_404(UrlManager, id=url_id)
    
    if request.method == 'POST':
        form = UrlManagerForm(request.POST, instance=url_manager)
        if form.is_valid():
            form.save()
            messages.success(request, f'URL "{url_manager.title}" actualizada exitosamente.')
            return redirect('url_manager_list')
    else:
        form = UrlManagerForm(instance=url_manager)
    
    context = {
        'form': form,
        'url_manager': url_manager,
        'page_title': f'Editar URL: {url_manager.title}',
        'action': 'Actualizar'
    }
    
    return render(request, 'tickets/url_manager_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def url_manager_detail_view(request, url_id):
    """Ver detalles de una URL gestionada (solo para agentes)"""
    from .models import UrlManager
    
    url_manager = get_object_or_404(UrlManager, id=url_id)
    
    # Marcar como accedida
    url_manager.mark_accessed()
    
    context = {
        'url_manager': url_manager,
        'page_title': f'Detalles: {url_manager.title}'
    }
    
    return render(request, 'tickets/url_manager_detail.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def url_manager_delete_view(request, url_id):
    """Eliminar URL gestionada (solo para agentes)"""
    from .models import UrlManager
    
    url_manager = get_object_or_404(UrlManager, id=url_id)
    
    if request.method == 'POST':
        title = url_manager.title
        url_manager.delete()
        messages.success(request, f'URL "{title}" eliminada exitosamente.')
        return redirect('url_manager_list')
    
    context = {
        'url_manager': url_manager,
        'page_title': f'Eliminar URL: {url_manager.title}'
    }
    
    return render(request, 'tickets/url_manager_delete.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def url_manager_password_view(request, url_id):
    """AJAX endpoint para obtener la contraseña desencriptada"""
    from .models import UrlManager
    from django.http import JsonResponse
    import logging
    
    logger = logging.getLogger(__name__)
    logger.info(f"Solicitando contraseña para URL ID: {url_id}")
    
    try:
        url_manager = get_object_or_404(UrlManager, id=url_id)
        logger.info(f"URL encontrada: {url_manager.title}")
        
        password = url_manager.get_password()
        logger.info(f"Contraseña obtenida exitosamente")
        
        return JsonResponse({
            'success': True,
            'password': password
        })
    except Exception as e:
        logger.error(f"Error al obtener contraseña: {str(e)}")
        return JsonResponse({
            'success': False,
            'error': str(e)
        })


# ===========================================
# VISTAS PARA ÓRDENAS DE TRABAJO
# ===========================================

@login_required
@user_passes_test(is_agent, login_url='/')
def work_order_list_view(request):
    """Vista para listar órdenes de trabajo"""
    # Obtener todas las órdenes de trabajo
    work_orders = WorkOrder.objects.all()
    
    # Aplicar filtros si existen
    form = WorkOrderFilterForm(request.GET)
    if form.is_valid():
        search = form.cleaned_data.get('search')
        company = form.cleaned_data.get('company')
        status = form.cleaned_data.get('status')
        priority = form.cleaned_data.get('priority')
        assigned_to = form.cleaned_data.get('assigned_to')
        
        if search:
            work_orders = work_orders.filter(
                Q(title__icontains=search) |
                Q(description__icontains=search)
            )
        
        if company:
            work_orders = work_orders.filter(company=company)
        
        if status:
            work_orders = work_orders.filter(status=status)
        
        if priority:
            work_orders = work_orders.filter(priority=priority)
        
        if assigned_to:
            work_orders = work_orders.filter(assigned_to=assigned_to)
    
    # Agregar información de permisos a cada orden
    for work_order in work_orders:
        work_order.user_can_edit = work_order.can_edit(request.user)
        work_order.user_can_delete = work_order.can_delete(request.user)
    
    # Paginación
    paginator = Paginator(work_orders, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_obj': page_obj,
        'filter_form': form,
        'page_title': 'Órdenes de Trabajo'
    }
    
    return render(request, 'tickets/work_order_list.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def work_order_create_view(request):
    """Vista para crear nuevas órdenes de trabajo"""
    if request.method == 'POST':
        form = WorkOrderForm(request.POST, request.FILES)
        if form.is_valid():
            work_order = form.save(commit=False)
            work_order.created_by = request.user
            work_order.save()
            messages.success(request, f'Orden de trabajo "{work_order.title}" creada exitosamente.')
            return redirect('work_order_detail', pk=work_order.pk)
    else:
        form = WorkOrderForm()
    
    context = {
        'form': form,
        'page_title': 'Crear Orden de Trabajo'
    }
    
    return render(request, 'tickets/work_order_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def work_order_detail_view(request, pk):
    """Vista para ver detalles de una orden de trabajo"""
    work_order = get_object_or_404(WorkOrder, pk=pk)
    
    context = {
        'work_order': work_order,
        'attachments': work_order.attachments.all(),
        'page_title': f'Orden: {work_order.order_number}'
    }
    
    return render(request, 'tickets/work_order_detail.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def work_order_edit_view(request, pk):
    """Vista para editar órdenes de trabajo"""
    work_order = get_object_or_404(WorkOrder, pk=pk)
    
    # Verificar permisos
    if not work_order.can_edit(request.user):
        messages.error(request, 'No tienes permisos para editar esta orden de trabajo.')
        return redirect('work_order_detail', pk=work_order.pk)
    
    if request.method == 'POST':
        form = WorkOrderForm(request.POST, request.FILES, instance=work_order)
        if form.is_valid():
            form.save(commit=False)
            messages.success(request, f'Orden de trabajo "{work_order.title}" actualizada exitosamente.')
            return redirect('work_order_detail', pk=work_order.pk)
    else:
        form = WorkOrderForm(instance=work_order)
    
    context = {
        'form': form,
        'work_order': work_order,
        'page_title': f'Editar: {work_order.order_number}'
    }
    
    return render(request, 'tickets/work_order_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def work_order_delete_view(request, pk):
    """Vista para eliminar órdenes de trabajo"""
    work_order = get_object_or_404(WorkOrder, pk=pk)
    
    # Verificar permisos
    if not work_order.can_delete(request.user):
        messages.error(request, 'No puedes eliminar esta orden de trabajo. Solo se pueden eliminar órdenes en estado borrador.')
        return redirect('work_order_detail', pk=work_order.pk)
    
    if request.method == 'POST':
        title = work_order.title
        work_order.delete()
        messages.success(request, f'Orden de trabajo "{title}" eliminada exitosamente.')
        return redirect('work_order_list')
    
    context = {
        'work_order': work_order,
        'page_title': f'Eliminar: {work_order.order_number}'
    }
    
    return render(request, 'tickets/work_order_delete.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def work_order_change_status_view(request, pk):
    """Vista AJAX para cambiar el estado de una orden de trabajo"""
    if request.method == 'POST':
        work_order = get_object_or_404(WorkOrder, pk=pk)
        new_status = request.POST.get('status')
        
        if new_status in ['draft', 'accepted', 'finished']:
            old_status = work_order.get_status_display()
            work_order.status = new_status
            
            # Si se marca como terminada, establecer fecha de finalización
            if new_status == 'finished':
                work_order.completed_at = timezone.now()
            else:
                work_order.completed_at = None
            
            work_order.save()
            
            new_status_display = work_order.get_status_display()
            messages.success(request, f'Estado de la orden cambiado de "{old_status}" a "{new_status_display}".')
            
            return JsonResponse({
                'success': True,
                'message': f'Estado actualizado a "{new_status_display}"',
                'new_status': new_status,
                'new_status_display': new_status_display
            })
        
        return JsonResponse({
            'success': False,
            'error': 'Estado inválido'
        })
    
    return JsonResponse({'success': False, 'error': 'Método no permitido'})


def work_order_public_view(request, token):
    """Vista pública para órdenes de trabajo compartidas"""
    work_order = get_object_or_404(WorkOrder, public_share_token=token, is_public=True)
    
    # Manejar aprobación por POST
    if request.method == 'POST' and 'approve_work_order' in request.POST:
        if work_order.status == 'draft':
            work_order.status = 'accepted'
            work_order.save()
            messages.success(request, '¡Orden de trabajo aprobada exitosamente!')
        else:
            messages.info(request, 'Esta orden ya ha sido procesada.')
        
        return redirect('tickets:public_work_order', token=token)
    
    context = {
        'work_order': work_order,
        'attachments': work_order.attachments.all(),
        'page_title': f'Orden: {work_order.order_number}',
        'is_public_view': True
    }
    
    return render(request, 'tickets/work_order_public.html', context)


# ===========================================
# VISTAS PARA REPORTES
# ===========================================

@login_required
@user_passes_test(is_agent, login_url='/')
def daily_report_view(request):
    """Vista para generar reporte de parte diario"""
    
    # Obtener parámetros de fecha
    fecha_desde = request.GET.get('fecha_desde', date.today().strftime('%Y-%m-%d'))
    fecha_hasta = request.GET.get('fecha_hasta', date.today().strftime('%Y-%m-%d'))
    usuario_id = request.GET.get('usuario')
    
    # Convertir fechas
    try:
        fecha_desde_obj = datetime.strptime(fecha_desde, '%Y-%m-%d').date()
        fecha_hasta_obj = datetime.strptime(fecha_hasta, '%Y-%m-%d').date()
    except ValueError:
        fecha_desde_obj = date.today()
        fecha_hasta_obj = date.today()
        fecha_desde = fecha_desde_obj.strftime('%Y-%m-%d')
        fecha_hasta = fecha_hasta_obj.strftime('%Y-%m-%d')
    
    # Obtener registros de tiempo
    time_entries = TimeEntry.objects.filter(
        fecha_entrada__date__gte=fecha_desde_obj,
        fecha_entrada__date__lte=fecha_hasta_obj
    )
    
    # Filtrar por usuario si se especifica
    usuario_nombre = None
    if usuario_id:
        time_entries = time_entries.filter(user_id=usuario_id)
        try:
            usuario = User.objects.get(id=usuario_id)
            usuario_nombre = usuario.get_full_name() or usuario.username
        except User.DoesNotExist:
            pass
    
    time_entries = time_entries.select_related('user', 'project', 'ticket', 'work_order', 'task').order_by('-fecha_entrada')
    
    # Agregar paginación
    from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
    
    paginator = Paginator(time_entries, 25)  # 25 registros por página
    page = request.GET.get('page')
    
    try:
        time_entries_page = paginator.page(page)
    except PageNotAnInteger:
        # Si page no es un entero, mostrar la primera página
        time_entries_page = paginator.page(1)
    except EmptyPage:
        # Si page está fuera de rango, mostrar la última página
        time_entries_page = paginator.page(paginator.num_pages)
    
    # Calcular estadísticas (usando el queryset original, no paginado)
    total_entries = time_entries.count()
    entries_in_progress = time_entries.filter(fecha_salida__isnull=True).count()
    
    # Calcular total de horas completadas usando duracion_trabajada
    total_minutos = 0
    for entry in time_entries:
        total_minutos += entry.duracion_trabajada
    
    # Convertir a horas con formato decimal
    total_hours = round(total_minutos / 60, 1)
    
    # Convertir total de minutos a formato HH:MM
    total_horas_formateado = f"{total_minutos // 60:02d}:{total_minutos % 60:02d}"
    
    # Obtener usuarios únicos
    unique_users = time_entries.values('user').distinct().count()
    
    # Indicadores CRM para la cabecera del reporte
    from .models import Contact, Opportunity, Company, Ticket
    
    # Obtener conteos de elementos creados en el rango de fechas
    contactos_creados = Contact.objects.filter(
        created_at__date__gte=fecha_desde_obj,
        created_at__date__lte=fecha_hasta_obj
    ).count()
    
    oportunidades_creadas = Opportunity.objects.filter(
        created_at__date__gte=fecha_desde_obj,
        created_at__date__lte=fecha_hasta_obj
    ).count()
    
    tickets_creados = Ticket.objects.filter(
        created_at__date__gte=fecha_desde_obj,
        created_at__date__lte=fecha_hasta_obj
    ).count()
    
    empresas_creadas = Company.objects.filter(
        created_at__date__gte=fecha_desde_obj,
        created_at__date__lte=fecha_hasta_obj
    ).count()
    
    # Obtener usuarios para el filtro
    usuarios = User.objects.filter(is_active=True).order_by('first_name', 'last_name', 'username')
    
    context = {
        'time_entries': time_entries,
        'usuarios': usuarios,
        'fecha_desde': fecha_desde,
        'fecha_hasta': fecha_hasta,
        'usuario_seleccionado': usuario_id,
        'usuario_nombre': usuario_nombre,
        'page_title': 'Reporte de Parte Diario',
        'total_entries': total_entries,
        'entries_in_progress': entries_in_progress,
        'total_hours': total_hours,
        'total_horas_formateado': total_horas_formateado,
        'unique_users': unique_users,
        # Indicadores CRM
        'contactos_creados': contactos_creados,
        'oportunidades_creadas': oportunidades_creadas,
        'tickets_creados': tickets_creados,
        'empresas_creadas': empresas_creadas,
    }
    
    return render(request, 'tickets/daily_report.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def daily_report_pdf(request):
    """Vista para generar PDF del reporte diario"""
    from django.http import HttpResponse
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib import colors
    from reportlab.lib.units import inch
    import io
    
    # Obtener parámetros
    fecha_desde = request.GET.get('fecha_desde', date.today().strftime('%Y-%m-%d'))
    fecha_hasta = request.GET.get('fecha_hasta', date.today().strftime('%Y-%m-%d'))
    usuario_id = request.GET.get('usuario')
    
    # Convertir fechas
    try:
        fecha_desde_obj = datetime.strptime(fecha_desde, '%Y-%m-%d').date()
        fecha_hasta_obj = datetime.strptime(fecha_hasta, '%Y-%m-%d').date()
    except ValueError:
        fecha_desde_obj = date.today()
        fecha_hasta_obj = date.today()
    
    # Obtener datos
    time_entries = TimeEntry.objects.filter(
        fecha_entrada__date__gte=fecha_desde_obj,
        fecha_entrada__date__lte=fecha_hasta_obj
    )
    
    if usuario_id:
        time_entries = time_entries.filter(user_id=usuario_id)
        usuario = User.objects.get(id=usuario_id)
        usuario_nombre = f" - {usuario.get_full_name() or usuario.username}"
    else:
        usuario_nombre = " - Todos los usuarios"
    
    time_entries = time_entries.select_related('user', 'project', 'ticket', 'work_order', 'task').order_by('user__username', 'fecha_entrada')
    
    # Crear PDF
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=72, leftMargin=72, topMargin=72, bottomMargin=18)
    
    # Estilos
    styles = getSampleStyleSheet()
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=16,
        spaceAfter=30,
        alignment=1  # Centrado
    )
    
    # Contenido del PDF
    story = []
    
    # Título
    title = f"Reporte de Parte Diario{usuario_nombre}"
    story.append(Paragraph(title, title_style))
    
    # Rango de fechas
    if fecha_desde_obj == fecha_hasta_obj:
        periodo = f"Fecha: {fecha_desde_obj.strftime('%d/%m/%Y')}"
    else:
        periodo = f"Período: {fecha_desde_obj.strftime('%d/%m/%Y')} al {fecha_hasta_obj.strftime('%d/%m/%Y')}"
    
    story.append(Paragraph(periodo, styles['Normal']))
    story.append(Spacer(1, 12))
    
    # Indicadores CRM para la cabecera del reporte
    from .models import Contact, Opportunity, Company, Ticket
    
    # Obtener conteos de elementos creados en el rango de fechas
    contactos_creados = Contact.objects.filter(
        created_at__date__gte=fecha_desde_obj,
        created_at__date__lte=fecha_hasta_obj
    ).count()
    
    oportunidades_creadas = Opportunity.objects.filter(
        created_at__date__gte=fecha_desde_obj,
        created_at__date__lte=fecha_hasta_obj
    ).count()
    
    tickets_creados = Ticket.objects.filter(
        created_at__date__gte=fecha_desde_obj,
        created_at__date__lte=fecha_hasta_obj
    ).count()
    
    empresas_creadas = Company.objects.filter(
        created_at__date__gte=fecha_desde_obj,
        created_at__date__lte=fecha_hasta_obj
    ).count()
    
    # Agregar indicadores CRM como una tabla
    indicadores_data = [
        ['INDICADORES CRM', ''],
        ['Total de Contactos Creados:', str(contactos_creados)],
        ['Total de Oportunidades Creadas:', str(oportunidades_creadas)],
        ['Total de Tickets Creados:', str(tickets_creados)],
        ['Total de Empresas Creadas:', str(empresas_creadas)],
    ]
    
    indicadores_table = Table(indicadores_data, colWidths=[3*inch, 1*inch])
    indicadores_table.setStyle(TableStyle([
        # Estilo para la cabecera
        ('BACKGROUND', (0, 0), (-1, 0), colors.lightblue),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        
        # Estilo para el contenido
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 1), (-1, -1), 10),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
    ]))
    
    story.append(indicadores_table)
    story.append(Spacer(1, 20))
    
    # Tabla de datos
    data = [['Usuario', 'Fecha', 'Asignación', 'Entrada', 'Salida', 'Duración']]
    
    total_minutos = 0  # Variable para acumular el total de minutos
    
    for entry in time_entries:
        # Construir asignación
        asignacion_parts = []
        if entry.project:
            asignacion_parts.append(f"Proyecto: {entry.project.name}")
        if entry.ticket:
            asignacion_parts.append(f"Ticket: #{entry.ticket.id}")
        if entry.work_order:
            asignacion_parts.append(f"Orden: #{entry.work_order.id}")
        if entry.task:
            asignacion_parts.append(f"Tarea: {entry.task.title}")
        
        asignacion = "\n".join(asignacion_parts) if asignacion_parts else "Sin asignación específica"
        
        # Formatear salida
        salida = entry.fecha_salida.strftime('%H:%M') if entry.fecha_salida else "En progreso"
        
        # Acumular minutos trabajados
        total_minutos += entry.duracion_trabajada
        
        data.append([
            entry.user.get_full_name() or entry.user.username,
            entry.fecha_entrada.strftime('%d/%m/%Y'),
            asignacion,
            entry.fecha_entrada.strftime('%H:%M'),
            salida,
            entry.duracion_formateada
        ])
    
    # Agregar fila de totales
    if time_entries.exists():
        # Convertir total de minutos a formato HH:MM
        total_horas = total_minutos // 60
        total_mins = total_minutos % 60
        total_formateado = f"{total_horas:02d}:{total_mins:02d}"
        
        data.append(['', '', '', '', 'TOTAL HORAS:', total_formateado])
    
    # Crear tabla con anchos ajustados para evitar cortes
    table = Table(data, colWidths=[1.3*inch, 0.9*inch, 1.8*inch, 0.7*inch, 1*inch, 1*inch])
    
    # Estilos base de la tabla
    table_style = [
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 10),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 1), (-1, -1), 8),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
    ]
    
    # Si hay datos y por tanto fila de totales, agregar estilo especial para la última fila
    if len(data) > 1:  # Header + al menos una fila de datos
        last_row = len(data) - 1
        table_style.extend([
            ('BACKGROUND', (0, last_row), (-1, last_row), colors.lightgrey),
            ('FONTNAME', (0, last_row), (-1, last_row), 'Helvetica-Bold'),
            ('FONTSIZE', (0, last_row), (-1, last_row), 10),
            ('TEXTCOLOR', (0, last_row), (-1, last_row), colors.black),
        ])
    
    table.setStyle(TableStyle(table_style))
    
    story.append(table)
    
    # Construir PDF
    doc.build(story)
    
    # Respuesta HTTP
    buffer.seek(0)
    response = HttpResponse(buffer.getvalue(), content_type='application/pdf')
    filename = f"parte_diario_{fecha_desde}_{fecha_hasta}.pdf"
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    
    return response


# ==================== VISTAS DE TAREAS ====================

@login_required
def task_list_view(request):
    """Vista para listar tareas"""
    tasks = Task.objects.all()
    
    # Filtros
    search = request.GET.get('search', '')
    status_filter = request.GET.get('status', '')
    priority_filter = request.GET.get('priority', '')
    assigned_to_me = request.GET.get('assigned_to_me', '')
    
    if search:
        tasks = tasks.filter(
            Q(title__icontains=search) | 
            Q(description__icontains=search)
        )
    
    if status_filter:
        tasks = tasks.filter(status=status_filter)
    
    if priority_filter:
        tasks = tasks.filter(priority=priority_filter)
    
    if assigned_to_me:
        tasks = tasks.filter(assigned_users=request.user)
    
    # Paginación
    paginator = Paginator(tasks, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_obj': page_obj,
        'search': search,
        'status_filter': status_filter,
        'priority_filter': priority_filter,
        'assigned_to_me': assigned_to_me,
        'status_choices': Task.STATUS_CHOICES,
        'priority_choices': Task.PRIORITY_CHOICES,
    }
    return render(request, 'tickets/task_list.html', context)


@login_required
def task_create_view(request):
    """Vista para crear una nueva tarea"""
    if request.method == 'POST':
        form = TaskForm(request.POST)
        if form.is_valid():
            task = form.save(commit=False)
            task.created_by = request.user
            task.save()
            form.save_m2m()  # Para guardar los ManyToMany
            
            messages.success(request, f'Tarea "{task.title}" creada exitosamente.')
            return redirect('task_detail', pk=task.pk)
    else:
        form = TaskForm()
    
    context = {
        'form': form,
        'title': 'Crear Nueva Tarea'
    }
    return render(request, 'tickets/task_form.html', context)


@login_required
def task_detail_view(request, pk):
    """Vista para ver detalles de una tarea"""
    task = get_object_or_404(Task, pk=pk)
    
    context = {
        'task': task,
    }
    return render(request, 'tickets/task_detail.html', context)


@login_required
def task_edit_view(request, pk):
    """Vista para editar una tarea"""
    task = get_object_or_404(Task, pk=pk)
    
    # Solo el creador o agentes pueden editar
    if not is_agent(request.user) and task.created_by != request.user:
        messages.error(request, 'No tienes permisos para editar esta tarea.')
        return redirect('task_detail', pk=task.pk)
    
    if request.method == 'POST':
        form = TaskForm(request.POST, instance=task)
        if form.is_valid():
            task = form.save(commit=False)
            task.save()
            form.save_m2m()  # Para guardar los ManyToMany
            messages.success(request, f'Tarea "{task.title}" actualizada exitosamente.')
            return redirect('task_detail', pk=task.pk)
    else:
        form = TaskForm(instance=task)
    
    context = {
        'form': form,
        'task': task,
        'title': f'Editar Tarea: {task.title}'
    }
    return render(request, 'tickets/task_form.html', context)


@login_required
def task_delete_view(request, pk):
    """Vista para eliminar una tarea"""
    task = get_object_or_404(Task, pk=pk)
    
    # Solo el creador o agentes pueden eliminar
    if not is_agent(request.user) and task.created_by != request.user:
        messages.error(request, 'No tienes permisos para eliminar esta tarea.')
        return redirect('task_detail', pk=task.pk)
    
    if request.method == 'POST':
        task_title = task.title
        task.delete()
        messages.success(request, f'Tarea "{task_title}" eliminada exitosamente.')
        return redirect('task_list')
    
    context = {
        'task': task,
    }
    return render(request, 'tickets/task_delete.html', context)


@login_required
def task_toggle_status_view(request, pk):
    """Vista para cambiar el estado de una tarea"""
    task = get_object_or_404(Task, pk=pk)
    
    if request.method == 'POST':
        new_status = request.POST.get('status')
        if new_status in dict(Task.STATUS_CHOICES):
            old_status = task.get_status_display()
            task.status = new_status
            
            if new_status == 'completed':
                task.completed_at = timezone.now()
            elif task.status != 'completed' and task.completed_at:
                task.completed_at = None
            
            task.save()
            
            messages.success(request, f'Estado de la tarea "{task.title}" cambiado de {old_status} a {task.get_status_display()}.')
    
    return redirect('task_detail', pk=task.pk)


# ===========================================
# VISTAS PARA GESTIÓN DIARIA DE TAREAS
# ===========================================

def auto_load_daily_tasks(session, user, date):
    """
    Carga automáticamente tareas relevantes para el día en una nueva sesión.
    Prioriza:
    1. Tareas con fecha límite de hoy
    2. Tareas con alta prioridad sin fecha límite
    3. Tareas en progreso del usuario
    """
    # Tareas con fecha límite de hoy (máxima prioridad)
    tasks_due_today = Task.objects.filter(
        assigned_users=user,
        due_date=date,
        status__in=['pending', 'in_progress']
    ).exclude(
        status__in=['completed', 'cancelled']
    )
    
    # Tareas de alta prioridad sin fecha límite
    high_priority_tasks = Task.objects.filter(
        assigned_users=user,
        priority='high',
        due_date__isnull=True,
        status__in=['pending', 'in_progress']
    ).exclude(
        status__in=['completed', 'cancelled']
    )[:3]  # Máximo 3 tareas de alta prioridad
    
    # Tareas actualmente en progreso del usuario
    in_progress_tasks = Task.objects.filter(
        assigned_users=user,
        status='in_progress'
    ).exclude(
        status__in=['completed', 'cancelled']
    )
    
    # Combinar y eliminar duplicados
    auto_tasks = list(tasks_due_today) + list(high_priority_tasks) + list(in_progress_tasks)
    unique_tasks = []
    seen_ids = set()
    
    for task in auto_tasks:
        if task.id not in seen_ids:
            unique_tasks.append(task)
            seen_ids.add(task.id)
    
    # Crear items de la sesión diaria para estas tareas
    for order, task in enumerate(unique_tasks[:8], 1):  # Máximo 8 tareas auto-cargadas
        DailyTaskItem.objects.create(
            session=session,
            task=task,
            order=order
        )


@login_required
def daily_task_management(request):
    """Vista principal - Lista de gestiones de tareas de todos los usuarios"""
    # Obtener todas las gestiones de tareas ordenadas por fecha
    # Si el usuario es superuser o staff, ve todas las gestiones
    # Si no, solo ve las suyas
    if request.user.is_superuser or request.user.is_staff:
        task_sessions = DailyTaskSession.objects.all()
    else:
        task_sessions = DailyTaskSession.objects.filter(user=request.user)
    
    task_sessions = task_sessions.prefetch_related(
        'daily_task_items__task', 'user'
    ).order_by('-created_at')
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(task_sessions, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'task_sessions': page_obj,
        'page_obj': page_obj,
        'is_paginated': page_obj.has_other_pages(),
    }
    
    return render(request, 'tickets/daily_task_management.html', context)


@login_required
def create_task_session(request):
    """Crear nueva gestión de tareas"""
    if request.method == 'POST':
        # Obtener la fecha del formulario
        session_date = request.POST.get('date')
        notes = request.POST.get('notes', '')
        
        if session_date:
            # Crear nueva sesión
            session = DailyTaskSession.objects.create(
                user=request.user,
                date=session_date,
                notes=notes
            )
            
            # Cargar TODAS las tareas donde el usuario esté involucrado (sin filtros de fecha)
            # Incluir: asignadas al usuario O creadas por el usuario
            assigned_tasks = Task.objects.filter(
                Q(assigned_users=request.user) | Q(created_by=request.user)
            ).exclude(
                status__in=['cancelled']  # Solo excluir canceladas, no completadas
            ).order_by('priority', '-created_at').distinct()
            
            print(f"DEBUG: Usuario {request.user.username}")
            print(f"DEBUG: Tareas totales encontradas: {assigned_tasks.count()}")
            
            # Debug detallado
            all_tasks = Task.objects.all()
            print(f"DEBUG: Total de tareas en el sistema: {all_tasks.count()}")
            
            user_assigned = Task.objects.filter(assigned_users=request.user)
            user_created = Task.objects.filter(created_by=request.user)
            print(f"DEBUG: Tareas asignadas al usuario: {user_assigned.count()}")
            print(f"DEBUG: Tareas creadas por el usuario: {user_created.count()}")
            
            for task in assigned_tasks[:5]:  # Mostrar primeras 5 para debug
                assigned_users = [u.username for u in task.assigned_users.all()]
                print(f"  - {task.title} | Estado: {task.status} | Asignada a: {assigned_users} | Creada por: {task.created_by.username if task.created_by else 'N/A'}")
            
            # Crear items para todas las tareas asignadas
            for order, task in enumerate(assigned_tasks, 1):
                DailyTaskItem.objects.create(
                    session=session,
                    task=task,
                    order=order
                )
            
            messages.success(
                request, 
                f'Nueva gestión de tareas creada con {assigned_tasks.count()} tareas cargadas.'
            )
            return redirect('view_task_session', session_id=session.id)
        else:
            messages.error(request, 'Debes seleccionar una fecha.')
    
    # Pasar la fecha de hoy al template
    today = timezone.now().date()
    return render(request, 'tickets/create_task_session.html', {'today': today})


@login_required
def view_task_session(request, session_id):
    """Ver y gestionar una sesión específica de tareas (checklist)"""
    try:
        session = DailyTaskSession.objects.get(
            id=session_id,
            user=request.user
        )
    except DailyTaskSession.DoesNotExist:
        messages.error(request, 'Gestión de tareas no encontrada.')
        return redirect('daily_task_management')
    
    # Obtener items de la sesión
    session_items = session.daily_task_items.select_related('task').order_by('order')
    
    context = {
        'session': session,
        'session_items': session_items,
    }
    
    return render(request, 'tickets/view_task_session.html', context)


@login_required
def delete_task_session(request, session_id):
    """Eliminar una gestión de tareas"""
    try:
        session = DailyTaskSession.objects.get(id=session_id)
        
        # Verificar permisos: solo el propietario o superusuario puede eliminar
        if session.user != request.user and not request.user.is_superuser:
            messages.error(request, 'No tienes permisos para eliminar esta gestión.')
            return redirect('daily_task_management')
        
        if request.method == 'POST':
            session_date = session.date.strftime('%d/%m/%Y')
            session_user = session.user.get_full_name() or session.user.username
            session.delete()
            messages.success(request, f'Gestión de tareas del {session_date} de {session_user} eliminada correctamente.')
            return redirect('daily_task_management')
        
        context = {
            'session': session,
        }
        
        return render(request, 'tickets/delete_task_session.html', context)
        
    except DailyTaskSession.DoesNotExist:
        messages.error(request, 'Gestión de tareas no encontrada.')
        return redirect('daily_task_management')


@login_required
def add_task_to_daily_session(request):
    """Agregar una tarea a la sesión diaria actual"""
    if request.method == 'POST':
        task_id = request.POST.get('task_id')
        today = timezone.now().date()
        
        try:
            task = Task.objects.get(id=task_id, assigned_users=request.user)
            session, created = DailyTaskSession.objects.get_or_create(
                user=request.user,
                date=today
            )
            
            # Verificar que la tarea no esté ya en la sesión
            if not DailyTaskItem.objects.filter(session=session, task=task).exists():
                # Obtener el siguiente orden
                max_order = session.daily_task_items.aggregate(
                    max_order=models.Max('order')
                )['max_order'] or 0
                
                DailyTaskItem.objects.create(
                    session=session,
                    task=task,
                    order=max_order + 1
                )
                
                messages.success(request, f'Tarea "{task.title}" agregada a tu plan del día.')
            else:
                messages.warning(request, 'Esta tarea ya está en tu plan del día.')
                
        except Task.DoesNotExist:
            messages.error(request, 'Tarea no encontrada o no tienes permisos.')
    
    return redirect('daily_task_management')


@login_required
def toggle_daily_task_completion(request, item_id):
    """Marcar/desmarcar una tarea como completada en la sesión"""
    try:
        item = DailyTaskItem.objects.get(
            id=item_id,
            session__user=request.user
        )
        
        if item.completed:
            item.mark_pending()
            messages.info(request, f'Tarea "{item.task.title}" marcada como pendiente.')
        else:
            item.mark_completed()
            messages.success(request, f'¡Excelente! Tarea "{item.task.title}" completada.')
        
        # Redirigir a la vista de la sesión específica
        return redirect('view_task_session', session_id=item.session.id)
        
    except DailyTaskItem.DoesNotExist:
        messages.error(request, 'Item no encontrado.')
        return redirect('daily_task_management')


@login_required
def remove_task_from_daily_session(request, item_id):
    """Remover una tarea de la sesión diaria"""
    try:
        item = DailyTaskItem.objects.get(
            id=item_id,
            session__user=request.user
        )
        task_title = item.task.title
        item.delete()
        messages.info(request, f'Tarea "{task_title}" removida de tu plan del día.')
        
    except DailyTaskItem.DoesNotExist:
        messages.error(request, 'Item no encontrado.')
    
    return redirect('daily_task_management')


@login_required
def update_daily_session_notes(request):
    """Actualizar las notas de la sesión diaria"""
    if request.method == 'POST':
        today = timezone.now().date()
        notes = request.POST.get('notes', '')
        
        session, created = DailyTaskSession.objects.get_or_create(
            user=request.user,
            date=today
        )
        
        session.notes = notes
        session.save()
        
        messages.success(request, 'Notas del día actualizadas.')
    
    return redirect('daily_task_management')


@login_required
def daily_task_history(request):
    """Vista del historial de sesiones diarias"""
    sessions = DailyTaskSession.objects.filter(
        user=request.user
    ).prefetch_related('daily_task_items__task').order_by('-date')
    
    # Aplicar filtros
    date_from = request.GET.get('date_from')
    date_to = request.GET.get('date_to')
    min_completion = request.GET.get('min_completion')
    
    if date_from:
        sessions = sessions.filter(date__gte=date_from)
    if date_to:
        sessions = sessions.filter(date__lte=date_to)
    
    # Calcular estadísticas de todas las sesiones (sin filtros)
    all_sessions = DailyTaskSession.objects.filter(user=request.user)
    total_sessions = all_sessions.count()
    total_tasks = sum(session.get_total_tasks() for session in all_sessions)
    total_completed_tasks = sum(session.get_completed_tasks() for session in all_sessions)
    
    if total_sessions > 0:
        average_completion = sum(session.get_completion_percentage() for session in all_sessions) / total_sessions
    else:
        average_completion = 0
    
    # Filtrar por porcentaje mínimo de finalización
    if min_completion:
        filtered_sessions = []
        for session in sessions:
            if session.get_completion_percentage() >= int(min_completion):
                filtered_sessions.append(session)
        sessions = filtered_sessions
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(sessions, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'sessions': page_obj,
        'page_obj': page_obj,
        'is_paginated': page_obj.has_other_pages(),
        'total_sessions': total_sessions,
        'total_tasks': total_tasks,
        'total_completed_tasks': total_completed_tasks,
        'average_completion': round(average_completion, 1),
    }
    
    return render(request, 'tickets/daily_task_history.html', context)


@login_required
def refresh_daily_tasks(request):
    """Recargar tareas relevantes del día en la sesión actual"""
    today = timezone.now().date()
    
    try:
        session = DailyTaskSession.objects.get(
            user=request.user,
            date=today
        )
        
        # Obtener tareas ya en la sesión para no duplicar
        existing_task_ids = session.daily_task_items.values_list('task_id', flat=True)
        
        # Tareas con fecha límite de hoy que no están en la sesión
        tasks_due_today = Task.objects.filter(
            assigned_users=request.user,
            due_date=today,
            status__in=['pending', 'in_progress']
        ).exclude(
            id__in=existing_task_ids
        ).exclude(
            status__in=['completed', 'cancelled']
        )
        
        # Tareas de alta prioridad sin fecha que no están en la sesión
        high_priority_tasks = Task.objects.filter(
            assigned_users=request.user,
            priority='high',
            due_date__isnull=True,
            status__in=['pending', 'in_progress']
        ).exclude(
            id__in=existing_task_ids
        ).exclude(
            status__in=['completed', 'cancelled']
        )[:2]  # Máximo 2 adicionales
        
        # Obtener el siguiente orden disponible
        max_order = session.daily_task_items.aggregate(
            max_order=models.Max('order')
        )['max_order'] or 0
        
        # Agregar nuevas tareas
        new_tasks = list(tasks_due_today) + list(high_priority_tasks)
        tasks_added = 0
        
        for task in new_tasks:
            max_order += 1
            DailyTaskItem.objects.create(
                session=session,
                task=task,
                order=max_order
            )
            tasks_added += 1
        
        if tasks_added > 0:
            messages.success(
                request, 
                f'Se agregaron {tasks_added} tarea(s) relevante(s) a tu plan del día.'
            )
        else:
            messages.info(
                request, 
                'No hay nuevas tareas relevantes para agregar hoy.'
            )
            
    except DailyTaskSession.DoesNotExist:
        messages.error(request, 'No tienes una sesión activa para hoy.')
    
    return redirect('daily_task_management')


# ===========================================
# VISTAS PARA CONTROL DIARIO DE TAREAS (MANTENEMOS LAS ANTERIORES)
# ===========================================

@login_required
def task_control_dashboard(request):
    """Dashboard diario de control de tareas para agentes"""
    # Obtener solo las tareas asignadas al usuario actual
    user_tasks = Task.objects.filter(
        assigned_users=request.user
    ).exclude(
        status__in=['cancelled']
    ).prefetch_related('assigned_users', 'created_by').order_by(
        'status', 'priority', 'due_date'
    )
    
    # Separar tareas por estado
    pending_tasks = user_tasks.filter(status='pending')
    in_progress_tasks = user_tasks.filter(status='in_progress')
    completed_tasks = user_tasks.filter(status='completed')
    
    # Estadísticas del día
    today = timezone.now().date()
    today_completed = user_tasks.filter(
        status='completed',
        completed_at__date=today
    ).count()
    
    overdue_tasks = [task for task in user_tasks if task.is_overdue()]
    
    context = {
        'pending_tasks': pending_tasks,
        'in_progress_tasks': in_progress_tasks,
        'completed_tasks': completed_tasks,
        'overdue_tasks': overdue_tasks,
        'today_completed': today_completed,
        'total_tasks': user_tasks.count(),
        'total_pending': pending_tasks.count(),
        'total_in_progress': in_progress_tasks.count(),
        'total_completed': completed_tasks.count(),
    }
    
    return render(request, 'tickets/task_control_dashboard.html', context)


@login_required
def task_control_complete(request, pk):
    """Marcar una tarea como completada desde el dashboard de control"""
    task = get_object_or_404(Task, pk=pk)
    
    # Verificar que el usuario esté asignado a la tarea
    if request.user not in task.assigned_users.all():
        messages.error(request, 'No tienes permisos para completar esta tarea.')
        return redirect('task_control_dashboard')
    
    if request.method == 'POST':
        old_status = task.get_status_display()
        task.mark_as_completed()
        
        messages.success(
            request,
            f'¡Excelente! Has completado la tarea "{task.title}".'
        )
    
    return redirect('task_control_dashboard')


@login_required
def task_control_start(request, pk):
    """Marcar una tarea como en progreso desde el dashboard de control"""
    task = get_object_or_404(Task, pk=pk)
    
    # Verificar que el usuario esté asignado a la tarea
    if request.user not in task.assigned_users.all():
        messages.error(request, 'No tienes permisos para modificar esta tarea.')
        return redirect('task_control_dashboard')
    
    if request.method == 'POST':
        if task.status == 'pending':
            task.status = 'in_progress'
            task.save()
            
            messages.success(
                request,
                f'Has comenzado a trabajar en la tarea "{task.title}".'
            )
        else:
            messages.warning(request, 'Esta tarea ya está en progreso o completada.')
    
    return redirect('task_control_dashboard')


@login_required
def task_control_pause(request, pk):
    """Pausar una tarea (marcar como pendiente) desde el dashboard de control"""
    task = get_object_or_404(Task, pk=pk)
    
    # Verificar que el usuario esté asignado a la tarea
    if request.user not in task.assigned_users.all():
        messages.error(request, 'No tienes permisos para modificar esta tarea.')
        return redirect('task_control_dashboard')
    
    if request.method == 'POST':
        if task.status == 'in_progress':
            task.status = 'pending'
            task.save()
            
            messages.info(
                request,
                f'Has pausado la tarea "{task.title}". Puedes retomarla cuando quieras.'
            )
        else:
            messages.warning(request, 'Solo puedes pausar tareas que estén en progreso.')
    
    return redirect('task_control_dashboard')


def public_task_view(request, token):
    """Vista pública para gestionar tareas sin autenticación"""
    try:
        user_profile = UserProfile.objects.get(public_token=token)
        user = user_profile.user
    except UserProfile.DoesNotExist:
        return render(request, 'tickets/public_tasks_error.html', {
            'error': 'Token no válido'
        })
    
    if request.method == 'POST':
        # Obtener las tareas seleccionadas (completadas)
        selected_task_ids = request.POST.getlist('selected_tasks')
        selected_task_ids = [int(task_id) for task_id in selected_task_ids]
        
        # Obtener TODAS las tareas asignadas al usuario (para crear la gestión completa)
        all_user_tasks = Task.objects.filter(
            Q(assigned_users=user) | Q(created_by=user)
        ).exclude(status__in=['cancelled']).distinct()
        
        if all_user_tasks.exists():
            # Crear nueva sesión con fecha de hoy
            from django.utils import timezone
            session = DailyTaskSession.objects.create(
                user=user,
                date=timezone.now().date(),
                notes='Gestión creada desde acceso público'
            )
            
            # Crear un item para CADA tarea asignada
            completed_count = 0
            order_counter = 1  # Contador para el orden
            for task in all_user_tasks:
                is_completed = task.id in selected_task_ids
                
                DailyTaskItem.objects.create(
                    session=session,
                    task=task,
                    order=order_counter,
                    completed=is_completed,
                    completed_at=timezone.now() if is_completed else None
                )
                
                order_counter += 1
                
                # Si la tarea fue marcada como completada, actualizar su estado
                if is_completed and task.status != 'completed':
                    task.status = 'completed'
                    task.save()
                    completed_count += 1
            
            return render(request, 'tickets/public_task_success.html', {
                'session': session,
                'user': user,
                'token': token,
                'task_count': all_user_tasks.count(),
                'completed_count': completed_count
            })
        else:
            error_message = 'No tienes tareas asignadas para crear una gestión'
    else:
        error_message = None
    
    # Obtener todas las tareas asignadas al usuario (incluyendo completadas)
    tasks = Task.objects.filter(
        Q(assigned_users=user) | Q(created_by=user)
    ).exclude(status='cancelled').distinct().order_by('-created_at')
    
    context = {
        'user': user,
        'tasks': tasks,
        'token': token,
        'error_message': error_message,
    }
    
    return render(request, 'tickets/public_tasks_simple.html', context)


def public_create_task_session(request, token):
    """Redirigir a la vista principal simplificada"""
    return redirect('public_task_view', token=token)


def public_project_view(request, token):
    """Vista pública para mostrar información del proyecto sin autenticación"""
    try:
        project = get_object_or_404(Project, public_share_token=token)
    except Project.DoesNotExist:
        return render(request, 'tickets/public_project_error.html', {
            'error': 'El enlace proporcionado no es válido o ha expirado.'
        })
    
    # Calcular estadísticas del proyecto usando los métodos del modelo
    total_hours = project.get_total_hours()
    tickets_count = project.get_tickets_count()
    resolved_tickets_count = project.get_resolved_tickets_count()
    completed_work_orders_count = project.get_completed_work_orders_count()
    
    # Obtener trabajadores del proyecto con sus datos de contacto
    workers = project.get_project_workers()
    
    # Crear lista de trabajadores con información de contacto
    workers_info = []
    for worker in workers:
        worker_info = {
            'name': f"{worker.first_name} {worker.last_name}".strip() or worker.username,
            'email': worker.email,
            'phone': getattr(worker.profile, 'phone', '') if hasattr(worker, 'profile') else '',
        }
        workers_info.append(worker_info)
    
    # Obtener tickets directamente asignados al proyecto para mostrar
    project_tickets = project.tickets.all().order_by('-created_at')[:10]
    
    # Obtener órdenes de trabajo directamente asignadas al proyecto para mostrar
    project_work_orders = project.work_orders.all().order_by('-created_at')[:10]
    
    context = {
        'project': project,
        'total_hours': total_hours,
        'tickets_count': tickets_count,
        'resolved_tickets_count': resolved_tickets_count,
        'completed_work_orders_count': completed_work_orders_count,
        'workers_info': workers_info,
        'project_tickets': project_tickets,
        'project_work_orders': project_work_orders,
    }
    
    return render(request, 'tickets/public_project.html', context)


# ===== VISTAS DEL CHAT =====

@login_required
def chat_list_view(request):
    """Vista para listar las salas de chat del usuario"""
    user_rooms = request.user.chat_rooms.all().order_by('-last_activity')
    
    # Agregar conteo de mensajes no leídos a cada sala
    for room in user_rooms:
        room.unread_count = room.get_unread_count_for_user(request.user)
    
    context = {
        'rooms': user_rooms,
        'page_title': 'Chat - Mensajes',
    }
    
    return render(request, 'tickets/chat_list.html', context)


@login_required
def chat_room_view(request, room_id):
    """Vista para una sala de chat específica"""
    room = get_object_or_404(ChatRoom, id=room_id, participants=request.user)
    
    # Marcar mensajes como leídos
    room.mark_as_read_for_user(request.user)
    
    # Obtener mensajes de la sala
    messages = room.messages.all().order_by('created_at')
    
    # Procesar envío de mensaje
    if request.method == 'POST':
        form = ChatMessageForm(request.POST, request.FILES)
        if form.is_valid():
            message = form.save(commit=False)
            message.room = room
            message.sender = request.user
            message.save()
            
            # Actualizar última actividad de la sala
            room.last_activity = timezone.now()
            room.save()
            
            # Redirigir para evitar reenvío
            return redirect('chat_room', room_id=room.id)
    else:
        form = ChatMessageForm()
    
    context = {
        'room': room,
        'messages': messages,
        'form': form,
        'page_title': f'Chat - {room}',
    }
    
    return render(request, 'tickets/chat_room.html', context)


@login_required
def chat_start_conversation(request, user_id):
    """Inicia una conversación 1:1 con otro usuario"""
    other_user = get_object_or_404(User, id=user_id, is_active=True)
    
    # Verificar que no es el mismo usuario
    if other_user == request.user:
        messages.error(request, 'No puedes iniciar una conversación contigo mismo.')
        return redirect('chat_list')
    
    # Buscar si ya existe una sala 1:1 entre estos usuarios
    existing_room = ChatRoom.objects.filter(
        is_group=False,
        participants=request.user
    ).filter(participants=other_user).first()
    
    if existing_room:
        return redirect('chat_room', room_id=existing_room.id)
    
    # Crear nueva sala 1:1
    room = ChatRoom.objects.create(is_group=False)
    room.participants.add(request.user, other_user)
    
    return redirect('chat_room', room_id=room.id)


@login_required
def chat_create_group(request):
    """Vista para crear un chat grupal"""
    if request.method == 'POST':
        form = ChatRoomForm(request.POST, user=request.user)
        if form.is_valid():
            room = form.save()
            messages.success(request, f'Grupo "{room}" creado exitosamente.')
            return redirect('chat_room', room_id=room.id)
    else:
        form = ChatRoomForm(user=request.user)
    
    context = {
        'form': form,
        'page_title': 'Crear Grupo de Chat',
    }
    
    return render(request, 'tickets/chat_create_group.html', context)


@login_required
def chat_users_list(request):
    """Vista para listar usuarios disponibles para chat"""
    users = User.objects.filter(is_active=True).exclude(id=request.user.id).order_by(
        'first_name', 'last_name', 'username'
    )
    
    context = {
        'users': users,
        'page_title': 'Usuarios - Chat',
    }
    
    return render(request, 'tickets/chat_users.html', context)


@login_required
def chat_ajax_load_messages(request, room_id):
    """Vista AJAX para cargar mensajes de una sala"""
    room = get_object_or_404(ChatRoom, id=room_id, participants=request.user)
    
    # Obtener mensajes después de cierto timestamp (para polling)
    last_message_id = request.GET.get('last_message_id', 0)
    messages = room.messages.filter(id__gt=last_message_id).order_by('created_at')
    
    messages_data = []
    for message in messages:
        messages_data.append({
            'id': message.id,
            'sender_name': message.sender.get_full_name() or message.sender.username,
            'sender_id': message.sender.id,
            'message': message.message,
            'attachment_name': message.get_attachment_name(),
            'attachment_url': message.attachment.url if message.attachment else None,
            'attachment_size': message.get_attachment_size(),
            'created_at': message.created_at.strftime('%H:%M'),
            'is_own': message.sender == request.user,
        })
    
    return JsonResponse({
        'messages': messages_data,
        'room_id': room.id,
    })


@login_required
def chat_ajax_send_message(request, room_id):
    """Vista AJAX para enviar mensajes"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    room = get_object_or_404(ChatRoom, id=room_id, participants=request.user)
    
    form = ChatMessageForm(request.POST, request.FILES)
    if form.is_valid():
        message = form.save(commit=False)
        message.room = room
        message.sender = request.user
        message.save()
        
        # Actualizar última actividad
        room.last_activity = timezone.now()
        room.save()
        
        return JsonResponse({
            'success': True,
            'message': {
                'id': message.id,
                'sender_name': message.sender.get_full_name() or message.sender.username,
                'sender_id': message.sender.id,
                'message': message.message,
                'attachment_name': message.get_attachment_name(),
                'attachment_url': message.attachment.url if message.attachment else None,
                'attachment_size': message.get_attachment_size(),
                'created_at': message.created_at.strftime('%H:%M'),
                'is_own': True,
            }
        })
    else:
        return JsonResponse({
            'error': 'Formulario inválido',
            'errors': form.errors
        }, status=400)


@login_required
@user_passes_test(is_agent)
def pdf_get_pages_view(request):
    """Vista para extraer páginas específicas de un PDF"""
    if request.method == 'POST':
        if 'pdf_file' not in request.FILES:
            messages.error(request, 'No se ha seleccionado ningún archivo PDF.')
            return render(request, 'tickets/pdf_get_pages.html')
        
        pdf_file = request.FILES['pdf_file']
        pages_input = request.POST.get('pages', '').strip()
        
        # Validar que el archivo sea PDF
        if not pdf_file.name.lower().endswith('.pdf'):
            messages.error(request, 'El archivo debe ser un PDF.')
            return render(request, 'tickets/pdf_get_pages.html')
        
        # Validar entrada de páginas
        if not pages_input:
            messages.error(request, 'Debe especificar las páginas a extraer.')
            return render(request, 'tickets/pdf_get_pages.html')
        
        try:
            # Importar PyPDF2
            from PyPDF2 import PdfReader, PdfWriter
            import io
            
            # Leer el PDF
            pdf_reader = PdfReader(pdf_file)
            total_pages = len(pdf_reader.pages)
            
            # Procesar la entrada de páginas (ej: "1,3,5-7")
            pages_to_extract = []
            for part in pages_input.split(','):
                part = part.strip()
                if '-' in part:
                    # Rango de páginas
                    start, end = part.split('-')
                    start = int(start.strip())
                    end = int(end.strip())
                    if start > end:
                        raise ValueError("Rango inválido")
                    pages_to_extract.extend(range(start, end + 1))
                else:
                    # Página individual
                    pages_to_extract.append(int(part))
            
            # Validar que las páginas estén en el rango válido
            for page_num in pages_to_extract:
                if page_num < 1 or page_num > total_pages:
                    messages.error(request, f'La página {page_num} no existe. El PDF tiene {total_pages} páginas.')
                    return render(request, 'tickets/pdf_get_pages.html')
            
            # Crear nuevo PDF con las páginas seleccionadas
            pdf_writer = PdfWriter()
            for page_num in pages_to_extract:
                page = pdf_reader.pages[page_num - 1]  # PyPDF2 usa índice base 0
                pdf_writer.add_page(page)
            
            # Crear respuesta HTTP con el PDF
            output = io.BytesIO()
            pdf_writer.write(output)
            output.seek(0)
            
            # Preparar nombre del archivo de salida
            original_name = pdf_file.name.rsplit('.', 1)[0]
            pages_str = pages_input.replace(',', '_').replace('-', '_')
            output_filename = f"{original_name}_pages_{pages_str}.pdf"
            
            response = HttpResponse(output.read(), content_type='application/pdf')
            response['Content-Disposition'] = f'attachment; filename="{output_filename}"'
            
            messages.success(request, f'PDF generado exitosamente con las páginas: {pages_input}')
            return response
            
        except ValueError as e:
            messages.error(request, f'Error en el formato de páginas: {str(e)}. Use formato como "1,3,5-7".')
        except Exception as e:
            messages.error(request, f'Error al procesar el PDF: {str(e)}')
        
        return render(request, 'tickets/pdf_get_pages.html')
    
    return render(request, 'tickets/pdf_get_pages.html')


@login_required
@user_passes_test(is_agent)
def pdf_join_view(request):
    """Vista para unir múltiples archivos PDF en uno solo"""
    if request.method == 'POST':
        pdf_files = request.FILES.getlist('pdf_files')
        
        if not pdf_files:
            messages.error(request, 'No se han seleccionado archivos PDF.')
            return render(request, 'tickets/pdf_join.html')
        
        if len(pdf_files) < 2:
            messages.error(request, 'Debe seleccionar al menos 2 archivos PDF para unir.')
            return render(request, 'tickets/pdf_join.html')
        
        # Validar que todos los archivos sean PDF
        for pdf_file in pdf_files:
            if not pdf_file.name.lower().endswith('.pdf'):
                messages.error(request, f'El archivo "{pdf_file.name}" no es un PDF válido.')
                return render(request, 'tickets/pdf_join.html')
        
        try:
            # Importar PyPDF2
            from PyPDF2 import PdfReader, PdfWriter
            import io
            
            # Crear nuevo PDF writer
            pdf_writer = PdfWriter()
            
            # Leer y agregar páginas de cada PDF
            for pdf_file in pdf_files:
                try:
                    pdf_reader = PdfReader(pdf_file)
                    
                    # Agregar todas las páginas del PDF actual
                    for page in pdf_reader.pages:
                        pdf_writer.add_page(page)
                        
                except Exception as e:
                    messages.error(request, f'Error al procesar el archivo "{pdf_file.name}": {str(e)}')
                    return render(request, 'tickets/pdf_join.html')
            
            # Crear respuesta HTTP con el PDF unido
            output = io.BytesIO()
            pdf_writer.write(output)
            output.seek(0)
            
            # Preparar nombre del archivo ZIP
            current_time = timezone.now().strftime('%Y%m%d_%H%M%S')
            output_filename = f"PDF_unido_{current_time}.pdf"
            
            response = HttpResponse(output.read(), content_type='application/pdf')
            response['Content-Disposition'] = f'attachment; filename="{output_filename}"'
            
            messages.success(request, f'PDF unido exitosamente. Se combinaron {len(pdf_files)} archivos.')
            return response
            
        except Exception as e:
            messages.error(request, f'Error al unir los PDFs: {str(e)}')
        
        return render(request, 'tickets/pdf_join.html')
    
    return render(request, 'tickets/pdf_join.html')


@login_required
@user_passes_test(is_agent)
def pdf_split_view(request):
    """Vista para dividir un PDF en archivos individuales por página"""
    if request.method == 'POST':
        if 'pdf_file' not in request.FILES:
            messages.error(request, 'No se ha seleccionado ningún archivo PDF.')
            return render(request, 'tickets/pdf_split.html')
        
        pdf_file = request.FILES['pdf_file']
        
        # Validar que el archivo sea PDF
        if not pdf_file.name.lower().endswith('.pdf'):
            messages.error(request, 'El archivo debe ser un PDF.')
            return render(request, 'tickets/pdf_split.html')
        
        try:
            # Importar PyPDF2 y zipfile
            from PyPDF2 import PdfReader, PdfWriter
            import io
            import zipfile
            from django.utils import timezone
            
            # Leer el PDF
            pdf_reader = PdfReader(pdf_file)
            total_pages = len(pdf_reader.pages)
            
            if total_pages == 0:
                messages.error(request, 'El PDF no contiene páginas válidas.')
                return render(request, 'tickets/pdf_split.html')
            
            if total_pages == 1:
                messages.warning(request, 'El PDF solo tiene una página. No es necesario dividirlo.')
                return render(request, 'tickets/pdf_split.html')
            
            # Crear un archivo ZIP en memoria
            zip_buffer = io.BytesIO()
            
            with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
                # Crear un PDF para cada página
                for page_num in range(total_pages):
                    pdf_writer = PdfWriter()
                    page = pdf_reader.pages[page_num]
                    pdf_writer.add_page(page)
                    
                    # Crear PDF en memoria
                    page_buffer = io.BytesIO()
                    pdf_writer.write(page_buffer)
                    page_buffer.seek(0)
                    
                    # Preparar nombre del archivo de página
                    original_name = pdf_file.name.rsplit('.', 1)[0]
                    page_filename = f"{original_name}_pagina_{page_num + 1:03d}.pdf"
                    
                    # Agregar al ZIP
                    zip_file.writestr(page_filename, page_buffer.read())
            
            zip_buffer.seek(0)
            
            # Preparar nombre del archivo ZIP
            current_time = timezone.now().strftime('%Y%m%d_%H%M%S')
            original_name = pdf_file.name.rsplit('.', 1)[0]
            zip_filename = f"{original_name}_dividido_{current_time}.zip"
            
            # Crear respuesta HTTP con el ZIP
            response = HttpResponse(zip_buffer.read(), content_type='application/zip')
            response['Content-Disposition'] = f'attachment; filename="{zip_filename}"'
            
            messages.success(request, f'PDF dividido exitosamente en {total_pages} archivos individuales.')
            return response
            
        except Exception as e:
            messages.error(request, f'Error al dividir el PDF: {str(e)}')
        
        return render(request, 'tickets/pdf_split.html')
    
    return render(request, 'tickets/pdf_split.html')


@login_required
@user_passes_test(is_agent)
def calculator_view(request):
    """Vista para la calculadora con historial"""
    return render(request, 'tickets/calculator.html')


@login_required
@user_passes_test(is_agent)
def color_picker_view(request):
    """Vista para el selector de colores (Color Picker)"""
    return render(request, 'tickets/color_picker.html')


@login_required
@user_passes_test(is_agent)
def command_library_view(request):
    """Vista principal de la biblioteca de comandos con búsqueda"""
    from .forms import CommandSearchForm
    from .models import Command
    from django.db.models import Q
    
    form = CommandSearchForm(request.GET)
    commands = Command.objects.all()
    
    if form.is_valid():
        query = form.cleaned_data.get('query')
        category = form.cleaned_data.get('category')
        favorites_only = form.cleaned_data.get('favorites_only')
        dangerous_only = form.cleaned_data.get('dangerous_only')
        
        # Búsqueda por texto
        if query:
            commands = commands.filter(
                Q(title__icontains=query) |
                Q(description__icontains=query) |
                Q(command__icontains=query) |
                Q(tags__icontains=query) |
                Q(example_usage__icontains=query) |
                Q(notes__icontains=query)
            )
        
        # Filtrar por categoría
        if category:
            commands = commands.filter(category=category)
        
        # Filtrar solo favoritos
        if favorites_only:
            commands = commands.filter(is_favorite=True)
        
        # Filtrar solo comandos peligrosos
        if dangerous_only:
            commands = commands.filter(is_dangerous=True)
    
    # Estadísticas
    total_commands = Command.objects.count()
    favorites_count = Command.objects.filter(is_favorite=True).count()
    dangerous_count = Command.objects.filter(is_dangerous=True).count()
    
    # Paginación
    paginator = Paginator(commands, 12)  # 12 comandos por página
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'form': form,
        'page_obj': page_obj,
        'total_commands': total_commands,
        'favorites_count': favorites_count,
        'dangerous_count': dangerous_count,
        'query': request.GET.get('query', ''),
    }
    
    return render(request, 'tickets/command_library.html', context)


@login_required
@user_passes_test(is_agent)
def command_create_view(request):
    """Vista para crear un nuevo comando"""
    from .forms import CommandForm
    from .models import Command
    
    if request.method == 'POST':
        form = CommandForm(request.POST)
        if form.is_valid():
            command = form.save(commit=False)
            command.created_by = request.user
            command.save()
            messages.success(request, 'Comando creado exitosamente.')
            return redirect('command_detail', pk=command.pk)
    else:
        form = CommandForm()
    
    return render(request, 'tickets/command_form.html', {
        'form': form,
        'title': 'Crear Comando',
        'action': 'Crear'
    })


@login_required
@user_passes_test(is_agent)
def command_detail_view(request, pk):
    """Vista de detalle de un comando"""
    from .models import Command
    
    command = get_object_or_404(Command, pk=pk)
    
    context = {
        'command': command,
    }
    
    return render(request, 'tickets/command_detail.html', context)


@login_required
@user_passes_test(is_agent)
def command_edit_view(request, pk):
    """Vista para editar un comando"""
    from .forms import CommandForm
    from .models import Command
    
    command = get_object_or_404(Command, pk=pk)
    
    if request.method == 'POST':
        form = CommandForm(request.POST, instance=command)
        if form.is_valid():
            form.save()
            messages.success(request, 'Comando actualizado exitosamente.')
            return redirect('command_detail', pk=command.pk)
    else:
        form = CommandForm(instance=command)
    
    return render(request, 'tickets/command_form.html', {
        'form': form,
        'command': command,
        'title': 'Editar Comando',
        'action': 'Actualizar'
    })


@login_required
@user_passes_test(is_agent)
def command_delete_view(request, pk):
    """Vista para eliminar un comando"""
    from .models import Command
    
    command = get_object_or_404(Command, pk=pk)
    
    if request.method == 'POST':
        command.delete()
        messages.success(request, 'Comando eliminado exitosamente.')
        return redirect('command_library')
    
    return render(request, 'tickets/command_delete.html', {
        'command': command,
    })


@login_required
@user_passes_test(is_agent)
def command_copy_view(request, pk):
    """Vista AJAX para copiar un comando e incrementar contador de uso"""
    from .models import Command
    
    if request.method == 'POST':
        command = get_object_or_404(Command, pk=pk)
        command.increment_usage()
        
        return JsonResponse({
            'success': True,
            'command': command.command,
            'usage_count': command.usage_count,
            'message': 'Comando copiado al portapapeles'
        })
    
    return JsonResponse({'success': False})


@login_required
@user_passes_test(is_agent)
def command_toggle_favorite_view(request, pk):
    """Vista AJAX para alternar favorito de un comando"""
    from .models import Command
    
    if request.method == 'POST':
        command = get_object_or_404(Command, pk=pk)
        command.is_favorite = not command.is_favorite
        command.save()
        
        return JsonResponse({
            'success': True,
            'is_favorite': command.is_favorite,
            'message': 'Favorito actualizado'
        })
    
    return JsonResponse({'success': False})


# ===== VISTAS DE FORMULARIO DE CONTACTO PÚBLICO =====

def public_contact_form_view(request, token):
    """Vista pública para formulario de contacto"""
    from .models import UserProfile, ContactFormSubmission
    from .forms import PublicContactForm
    
    # Buscar el perfil del usuario con el token
    try:
        profile = UserProfile.objects.get(public_token=token, enable_public_contact_form=True)
    except UserProfile.DoesNotExist:
        return render(request, 'tickets/public_contact_error.html', {
            'error_message': 'Formulario de contacto no encontrado o no disponible'
        })
    
    if request.method == 'POST':
        form = PublicContactForm(request.POST)
        if form.is_valid():
            # Crear la submission del formulario
            submission = form.save(commit=False)
            submission.submitted_by_user = profile.user
            
            # Obtener información adicional de la petición
            submission.ip_address = get_client_ip(request)
            submission.user_agent = request.META.get('HTTP_USER_AGENT', '')
            
            submission.save()
            
            # Redireccionar a página de éxito
            return redirect('contact_form_success')
    else:
        form = PublicContactForm()
    
    context = {
        'form': form,
        'profile': profile,
        'user_owner': profile.user,
        'page_title': f'Formulario de Contacto - {profile.user.get_full_name() or profile.user.username}'
    }
    
    return render(request, 'tickets/public_contact_form.html', context)


def contact_form_success(request):
    """Vista de éxito después de enviar formulario de contacto"""
    return render(request, 'tickets/contact_form_success.html')


@login_required
def contact_submissions_list(request):
    """Vista para listar formularios de contacto recibidos"""
    from .models import ContactFormSubmission
    from django.core.paginator import Paginator
    
    # Solo mostrar formularios enviados a este usuario
    submissions = ContactFormSubmission.objects.filter(
        submitted_by_user=request.user
    ).order_by('-submitted_at')
    
    # Filtros
    status_filter = request.GET.get('status')
    if status_filter:
        submissions = submissions.filter(status=status_filter)
    
    # Paginación
    paginator = Paginator(submissions, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Estadísticas
    stats = {
        'total': submissions.count(),
        'pending': submissions.filter(status='pending').count(),
        'approved': submissions.filter(status='approved').count(),
        'rejected': submissions.filter(status='rejected').count(),
        'company_created': submissions.filter(status='company_created').count(),
    }
    
    context = {
        'page_obj': page_obj,
        'submissions': page_obj,
        'stats': stats,
        'status_filter': status_filter,
        'status_choices': ContactFormSubmission.STATUS_CHOICES,
        'page_title': 'Formularios de Contacto Recibidos'
    }
    
    return render(request, 'tickets/contact_submissions_list.html', context)


@login_required
def contact_submission_detail(request, pk):
    """Vista detallada de un formulario de contacto"""
    from .models import ContactFormSubmission
    from .forms import ContactFormManagementForm
    
    submission = get_object_or_404(
        ContactFormSubmission, 
        pk=pk, 
        submitted_by_user=request.user
    )
    
    if request.method == 'POST':
        if 'update_notes' in request.POST:
            # Actualizar solo las notas administrativas
            admin_notes = request.POST.get('admin_notes', '')
            submission.admin_notes = admin_notes
            submission.save()
            messages.success(request, 'Notas administrativas actualizadas exitosamente.')
            return redirect('contact_submission_detail', pk=pk)
        else:
            # Actualizar el formulario completo
            form = ContactFormManagementForm(request.POST, instance=submission)
            if form.is_valid():
                updated_submission = form.save(commit=False)
                if updated_submission.status != submission.status:
                    updated_submission.processed_by = request.user
                    updated_submission.processed_at = timezone.now()
                updated_submission.save()
                
                messages.success(request, 'Formulario de contacto actualizado exitosamente.')
                return redirect('contact_submission_detail', pk=pk)
    else:
        form = ContactFormManagementForm(instance=submission)
    
    context = {
        'submission': submission,
        'form': form,
        'page_title': f'Formulario de Contacto - {submission.company_name}'
    }
    
    return render(request, 'tickets/contact_submission_detail.html', context)


@login_required
def contact_submission_approve(request, pk):
    """Aprobar un formulario de contacto y crear empresa"""
    from .models import ContactFormSubmission, Company
    from .forms import CompanyFromContactForm
    
    submission = get_object_or_404(
        ContactFormSubmission, 
        pk=pk, 
        submitted_by_user=request.user
    )
    
    if request.method == 'POST':
        form = CompanyFromContactForm(request.POST, contact_form=submission)
        
        if form.is_valid():
            # Crear la empresa
            company = form.save()
            
            # Marcar el formulario como procesado
            submission.mark_as_processed(
                user=request.user,
                status='company_created',
                company=company
            )
            
            messages.success(request, f'Empresa "{company.name}" creada exitosamente desde el formulario de contacto.')
            return redirect('company_detail', company_id=company.id)
        else:
            messages.error(request, f'Error al crear la empresa: {form.errors}')
    else:
        form = CompanyFromContactForm(contact_form=submission)
    
    context = {
        'submission': submission,
        'form': form,
        'page_title': f'Crear Empresa - {submission.company_name}'
    }
    
    return render(request, 'tickets/contact_submission_approve.html', context)


@login_required
def contact_submission_reject(request, pk):
    """Rechazar un formulario de contacto"""
    from .models import ContactFormSubmission
    
    submission = get_object_or_404(
        ContactFormSubmission, 
        pk=pk, 
        submitted_by_user=request.user
    )
    
    if request.method == 'POST':
        reason = request.POST.get('reason', '')
        
        # Actualizar el formulario
        submission.mark_as_processed(
            user=request.user,
            status='rejected'
        )
        
        if reason:
            submission.admin_notes = f"Rechazado: {reason}"
            submission.save()
        
        messages.success(request, 'Formulario de contacto rechazado.')
        return redirect('contact_submissions_list')
    
    context = {
        'submission': submission,
        'page_title': f'Rechazar Formulario - {submission.company_name}'
    }
    
    return render(request, 'tickets/contact_submission_reject.html', context)


def get_client_ip(request):
    """Obtener la IP del cliente"""
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0]
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip


@login_required
def tetris_view(request):
    """Vista para el juego Tetris - para todos los usuarios autenticados"""
    context = {
        'page_title': 'Tetris - Juegos',
        'user_role': get_user_role(request.user)
    }
    return render(request, 'tickets/tetris.html', context)


def public_company_stats(request, token):
    """Vista pública para mostrar estadísticas de una empresa usando su token o ID"""
    company = None
    
    try:
        # Intentar primero como UUID token
        company = Company.objects.filter(public_token=token, is_active=True).first()
    except ValueError:
        pass
    
    if not company:
        try:
            # Si falla, intentar como ID numérico
            company = Company.objects.filter(id=int(token), is_active=True).first()
        except (ValueError, TypeError):
            pass
    
    if not company:
        raise Http404("Empresa no encontrada o token inválido")
    
    # Obtener estadísticas públicas
    stats = company.get_public_stats()
    
    # Obtener tickets abiertos de la empresa (limitados a los primeros 10)
    open_tickets = company.tickets.filter(status='open').order_by('-created_at')[:10]
    
    context = {
        'company': company,
        'stats': stats,
        'open_tickets': open_tickets,
        'page_title': f'Estadísticas - {company.name}'
    }
    
    return render(request, 'tickets/public_company_stats.html', context)


# ============= VISTAS CRM =============

@login_required
def crm_dashboard(request):
    """Dashboard principal del CRM"""
    # Obtener configuración del sistema
    system_config = SystemConfiguration.get_config()
    
    # Obtener oportunidades del usuario
    if is_agent(request.user):
        opportunities = Opportunity.objects.all()
    else:
        opportunities = Opportunity.objects.filter(
            Q(created_by=request.user) | Q(assigned_to=request.user)
        )
    
    # Estadísticas generales
    total_opportunities = opportunities.count()
    total_value = opportunities.aggregate(total=Sum('value'))['total'] or 0
    total_expected_value = sum(opp.expected_value for opp in opportunities)
    
    # Oportunidades por estado
    status_stats = {}
    for status in OpportunityStatus.objects.filter(is_active=True):
        count = opportunities.filter(status=status).count()
        value = opportunities.filter(status=status).aggregate(total=Sum('value'))['total'] or 0
        status_stats[status] = {'count': count, 'value': value}
    
    # Oportunidades próximas a vencer (próximos 7 días)
    next_week = timezone.now().date() + timedelta(days=7)
    upcoming_opportunities = opportunities.filter(
        expected_close_date__lte=next_week,
        expected_close_date__gte=timezone.now().date(),
        status__is_final=False
    ).order_by('expected_close_date')[:5]
    
    # Oportunidades vencidas
    overdue_opportunities = opportunities.filter(
        expected_close_date__lt=timezone.now().date(),
        status__is_final=False
    ).count()
    
    context = {
        'total_opportunities': total_opportunities,
        'total_value': total_value,
        'total_expected_value': total_expected_value,
        'status_stats': status_stats,
        'upcoming_opportunities': upcoming_opportunities,
        'overdue_opportunities': overdue_opportunities,
        'page_title': 'CRM Dashboard',
        'system_config': system_config,
    }
    
    return render(request, 'tickets/crm_dashboard.html', context)


@login_required
def opportunity_list(request):
    """Lista de oportunidades"""
    # Obtener oportunidades del usuario
    if is_agent(request.user):
        opportunities = Opportunity.objects.all()
    else:
        opportunities = Opportunity.objects.filter(
            Q(created_by=request.user) | Q(assigned_to=request.user)
        )
    
    # Filtros
    status_filter = request.GET.get('status')
    company_filter = request.GET.get('company')
    assigned_filter = request.GET.get('assigned')
    search = request.GET.get('search')
    overdue_filter = request.GET.get('overdue')
    
    if status_filter:
        opportunities = opportunities.filter(status_id=status_filter)
    
    if company_filter:
        opportunities = opportunities.filter(company_id=company_filter)
    
    if assigned_filter:
        opportunities = opportunities.filter(assigned_to_id=assigned_filter)
    
    if overdue_filter == 'true':
        from django.utils import timezone
        today = timezone.now().date()
        opportunities = opportunities.filter(
            expected_close_date__lt=today,
            status__is_final=False
        )
    
    if search:
        opportunities = opportunities.filter(
            Q(name__icontains=search) |
            Q(description__icontains=search) |
            Q(company__name__icontains=search) |
            Q(contact_name__icontains=search)
        )
    
    # Ordenamiento
    order_by = request.GET.get('order_by', '-created_at')
    opportunities = opportunities.order_by(order_by)
    
    # Paginación
    paginator = Paginator(opportunities, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Agregar información de permisos a cada oportunidad
    for opportunity in page_obj:
        opportunity.user_can_edit = opportunity.can_be_edited_by(request.user)
    
    # Para los filtros
    statuses = OpportunityStatus.objects.filter(is_active=True).order_by('order')
    companies = Company.objects.all()
    users = User.objects.filter(is_active=True)
    
    context = {
        'page_obj': page_obj,
        'statuses': statuses,
        'companies': companies,
        'users': users,
        'current_filters': {
            'status': status_filter,
            'company': company_filter,
            'assigned': assigned_filter,
            'search': search,
            'order_by': order_by,
        },
        'page_title': 'Oportunidades'
    }
    
    return render(request, 'tickets/opportunity_list.html', context)


@login_required
def opportunity_detail(request, pk):
    """Detalle de oportunidad"""
    opportunity = get_object_or_404(Opportunity, pk=pk)
    
    # Verificar permisos
    from . import utils
    if not utils.is_agent(request.user):
        if opportunity.created_by != request.user and opportunity.assigned_to != request.user:
            messages.error(request, 'No tienes permisos para ver esta oportunidad.')
            return redirect('opportunity_list')
    
    # Obtener notas y historial
    notes = opportunity.notes.all()
    history = opportunity.status_history.all()
    
    # Verificar si puede ser editada
    can_be_edited = opportunity.can_be_edited_by(request.user)
    
    context = {
        'opportunity': opportunity,
        'notes': notes,
        'history': history,
        'can_be_edited': can_be_edited,
        'page_title': f'Oportunidad: {opportunity.name}'
    }
    
    return render(request, 'tickets/opportunity_detail.html', context)


@login_required
def opportunity_create(request):
    """Crear nueva oportunidad"""
    if request.method == 'POST':
        # Procesar formulario
        name = request.POST.get('name')
        description = request.POST.get('description', '')
        company_id = request.POST.get('company')
        contact_name = request.POST.get('contact_name')
        contact_position = request.POST.get('contact_position', '')
        contact_email = request.POST.get('contact_email', '')
        contact_phone = request.POST.get('contact_phone', '')
        value = request.POST.get('value')
        probability = request.POST.get('probability', 20)
        status_id = request.POST.get('status')
        expected_close_date = request.POST.get('expected_close_date')
        assigned_to_id = request.POST.get('assigned_to')
        source = request.POST.get('source', '')
        
        try:
            company = Company.objects.get(pk=company_id)
            status = OpportunityStatus.objects.get(pk=status_id)
            assigned_to = User.objects.get(pk=assigned_to_id) if assigned_to_id else None
            
            opportunity = Opportunity.objects.create(
                name=name,
                description=description,
                company=company,
                contact_name=contact_name,
                contact_position=contact_position,
                contact_email=contact_email,
                contact_phone=contact_phone,
                value=value,
                probability=probability,
                status=status,
                expected_close_date=expected_close_date,
                assigned_to=assigned_to,
                created_by=request.user,
                source=source
            )
            
            # Crear historial inicial
            OpportunityStatusHistory.objects.create(
                opportunity=opportunity,
                new_status=status,
                changed_by=request.user,
                comment="Oportunidad creada"
            )
            
            messages.success(request, 'Oportunidad creada exitosamente.')
            return redirect('opportunity_detail', pk=opportunity.pk)
            
        except Exception as e:
            messages.error(request, f'Error al crear la oportunidad: {str(e)}')
    
    # Para GET request
    companies = Company.objects.all()
    statuses = OpportunityStatus.objects.filter(is_active=True).order_by('order')
    users = User.objects.filter(is_active=True)
    
    # Valores por defecto
    default_close_date = (timezone.now().date() + timedelta(days=90)).strftime('%Y-%m-%d')  # 3 meses
    default_status = statuses.first()  # Estado con menor secuencia (order)
    default_assigned_to = request.user  # Usuario que crea la oportunidad
    
    # Si viene un contact_id, precargar datos del contacto
    contact_data = {}
    contact_id = request.GET.get('contact_id')
    if contact_id:
        try:
            contact = Contact.objects.get(pk=contact_id)
            contact_data = {
                'contact_name': contact.name,
                'contact_email': contact.email or '',
                'contact_phone': contact.phone or '',
                'contact_position': contact.position or '',
                'source': f"Contacto: {contact.source}" if contact.source else "Contacto previo",
            }
            # Si el contacto tiene empresa, buscar si existe en Company
            if contact.company:
                try:
                    company = Company.objects.filter(name__iexact=contact.company).first()
                    if company:
                        contact_data['default_company'] = company
                except:
                    pass
        except Contact.DoesNotExist:
            pass
    
    # Opciones de probabilidad
    probability_choices = [
        (0, '0%'), (10, '10%'), (20, '20%'), (30, '30%'), (40, '40%'),
        (50, '50%'), (60, '60%'), (70, '70%'), (80, '80%'), (90, '90%'), (100, '100%')
    ]
    
    context = {
        'companies': companies,
        'statuses': statuses,
        'users': users,
        'probability_choices': probability_choices,
        'page_title': 'Nueva Oportunidad',
        'default_close_date': default_close_date,
        'default_status': default_status,
        'default_assigned_to': default_assigned_to,
        'contact_data': contact_data,
    }
    
    return render(request, 'tickets/opportunity_form.html', context)


@login_required
def opportunity_edit(request, pk):
    """Editar oportunidad"""
    opportunity = get_object_or_404(Opportunity, pk=pk)
    
    # Verificar permisos
    if not opportunity.can_be_edited_by(request.user):
        messages.error(request, 'No tienes permisos para editar esta oportunidad.')
        return redirect('opportunity_detail', pk=pk)
    
    if request.method == 'POST':
        # Procesar formulario
        previous_status = opportunity.status
        
        opportunity.name = request.POST.get('name')
        opportunity.description = request.POST.get('description', '')
        opportunity.company_id = request.POST.get('company')
        opportunity.contact_name = request.POST.get('contact_name')
        opportunity.contact_position = request.POST.get('contact_position', '')
        opportunity.contact_email = request.POST.get('contact_email', '')
        opportunity.contact_phone = request.POST.get('contact_phone', '')
        opportunity.value = request.POST.get('value')
        opportunity.probability = request.POST.get('probability', 20)
        opportunity.status_id = request.POST.get('status')
        opportunity.expected_close_date = request.POST.get('expected_close_date')
        opportunity.assigned_to_id = request.POST.get('assigned_to') or None
        opportunity.source = request.POST.get('source', '')
        
        # Si el estado cambió, crear historial
        if previous_status.pk != int(request.POST.get('status')):
            comment = request.POST.get('status_comment', '')
            OpportunityStatusHistory.objects.create(
                opportunity=opportunity,
                previous_status=previous_status,
                new_status=opportunity.status,
                changed_by=request.user,
                comment=comment
            )
        
        opportunity.save()
        messages.success(request, 'Oportunidad actualizada exitosamente.')
        return redirect('opportunity_detail', pk=pk)
    
    # Para GET request
    companies = Company.objects.all()
    statuses = OpportunityStatus.objects.filter(is_active=True)
    users = User.objects.filter(is_active=True)
    
    # Opciones de probabilidad
    probability_choices = [
        (0, '0%'), (10, '10%'), (20, '20%'), (30, '30%'), (40, '40%'),
        (50, '50%'), (60, '60%'), (70, '70%'), (80, '80%'), (90, '90%'), (100, '100%')
    ]
    
    context = {
        'opportunity': opportunity,
        'companies': companies,
        'statuses': statuses,
        'users': users,
        'probability_choices': probability_choices,
        'page_title': f'Editar: {opportunity.name}'
    }
    
    return render(request, 'tickets/opportunity_form.html', context)


@login_required
def opportunity_delete(request, pk):
    """Eliminar oportunidad"""
    opportunity = get_object_or_404(Opportunity, pk=pk)
    
    # Verificar permisos
    from . import utils
    if not utils.is_agent(request.user) and opportunity.created_by != request.user:
        messages.error(request, 'No tienes permisos para eliminar esta oportunidad.')
        return redirect('opportunity_detail', pk=pk)
    
    if request.method == 'POST':
        opportunity.delete()
        messages.success(request, 'Oportunidad eliminada exitosamente.')
        return redirect('opportunity_list')
    
    context = {
        'opportunity': opportunity,
        'page_title': f'Eliminar: {opportunity.name}'
    }
    
    return render(request, 'tickets/opportunity_delete.html', context)


@login_required
def opportunity_status_list(request):
    """Lista de estados de oportunidades"""
    from . import utils
    if not utils.is_agent(request.user):
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('crm_dashboard')
    
    statuses = OpportunityStatus.objects.all().order_by('order', 'name')
    
    context = {
        'statuses': statuses,
        'page_title': 'Estados de Oportunidades'
    }
    
    return render(request, 'tickets/opportunity_status_list.html', context)


@login_required
def opportunity_status_create(request):
    """Crear estado de oportunidad"""
    from . import utils
    if not utils.is_agent(request.user):
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('crm_dashboard')
    
    if request.method == 'POST':
        name = request.POST.get('name')
        description = request.POST.get('description', '')
        color = request.POST.get('color', '#007bff')
        is_final = request.POST.get('is_final') == 'on'
        is_won = request.POST.get('is_won') == 'on'
        order = request.POST.get('order', 0)
        
        try:
            status = OpportunityStatus.objects.create(
                name=name,
                description=description,
                color=color,
                is_final=is_final,
                is_won=is_won,
                order=order,
                created_by=request.user
            )
            messages.success(request, 'Estado creado exitosamente.')
            return redirect('opportunity_status_list')
        except Exception as e:
            messages.error(request, f'Error al crear el estado: {str(e)}')
    
    context = {
        'page_title': 'Nuevo Estado'
    }
    
    return render(request, 'tickets/opportunity_status_form.html', context)


@login_required
def opportunity_status_edit(request, pk):
    """Editar estado de oportunidad"""
    from .models import OpportunityStatus
    from . import utils
    
    status = get_object_or_404(OpportunityStatus, pk=pk)
    
    if not utils.is_agent(request.user):
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('crm_dashboard')
    
    if request.method == 'POST':
        status.name = request.POST.get('name')
        status.description = request.POST.get('description', '')
        status.color = request.POST.get('color', '#007bff')
        status.is_final = request.POST.get('is_final') == 'on'
        status.is_won = request.POST.get('is_won') == 'on'
        status.order = request.POST.get('order', 0)
        status.is_active = request.POST.get('is_active') == 'on'
        
        status.save()
        messages.success(request, 'Estado actualizado exitosamente.')
        return redirect('opportunity_status_list')
    
    context = {
        'status': status,
        'page_title': f'Editar: {status.name}'
    }
    
    return render(request, 'tickets/opportunity_status_form.html', context)


@login_required
def opportunity_status_delete(request, pk):
    """Eliminar estado de oportunidad"""
    from .models import OpportunityStatus
    
    status = get_object_or_404(OpportunityStatus, pk=pk)
    
    # Verificar si hay oportunidades usando este estado
    if status.opportunities.exists():
        messages.error(request, 'No se puede eliminar este estado porque hay oportunidades que lo utilizan.')
        return redirect('opportunity_status_list')
    
    if request.method == 'POST':
        status.delete()
        messages.success(request, 'Estado eliminado exitosamente.')
        return redirect('opportunity_status_list')
    
    context = {
        'status': status,
        'page_title': f'Eliminar: {status.name}'
    }
    
    return render(request, 'tickets/opportunity_status_delete.html', context)


@login_required
def opportunity_add_note(request, pk):
    """Agregar nota a oportunidad"""
    opportunity = get_object_or_404(Opportunity, pk=pk)
    
    # Verificar permisos
    from . import utils
    if not utils.is_agent(request.user):
        if opportunity.created_by != request.user and opportunity.assigned_to != request.user:
            messages.error(request, 'No tienes permisos para agregar notas a esta oportunidad.')
            return redirect('opportunity_detail', pk=pk)
    
    if request.method == 'POST':
        content = request.POST.get('content')
        is_important = request.POST.get('is_important') == 'on'
        
        if content:
            OpportunityNote.objects.create(
                opportunity=opportunity,
                content=content,
                is_important=is_important,
                created_by=request.user
            )
            messages.success(request, 'Nota agregada exitosamente.')
        else:
            messages.error(request, 'El contenido de la nota es requerido.')
    
    return redirect('opportunity_detail', pk=pk)


# ============================
# VISTAS DE ACTIVIDADES DE OPORTUNIDADES
# ============================

@login_required
def opportunity_activity_create(request, opportunity_id):
    """Crear nueva actividad para oportunidad"""
    from .models import Opportunity, OpportunityActivity
    from .forms import OpportunityActivityForm
    
    opportunity = get_object_or_404(Opportunity, pk=opportunity_id)
    
    # Verificar permisos
    from . import utils
    if not utils.is_agent(request.user):
        if opportunity.created_by != request.user and opportunity.assigned_to != request.user:
            messages.error(request, 'No tienes permisos para crear actividades en esta oportunidad.')
            return redirect('opportunity_detail', pk=opportunity_id)
    
    if request.method == 'POST':
        form = OpportunityActivityForm(request.POST, opportunity=opportunity, current_user=request.user)
        if form.is_valid():
            activity = form.save(commit=False)
            activity.opportunity = opportunity
            activity.created_by = request.user
            activity.save()
            
            messages.success(request, f'Actividad "{activity.title}" creada exitosamente.')
            return redirect('opportunity_detail', pk=opportunity_id)
    else:
        form = OpportunityActivityForm(opportunity=opportunity, current_user=request.user)
    
    context = {
        'form': form,
        'opportunity': opportunity,
        'page_title': f'Nueva Actividad - {opportunity.name}'
    }
    
    return render(request, 'tickets/opportunity_activity_form.html', context)


@login_required
def opportunity_activity_list(request, opportunity_id):
    """Listar actividades de una oportunidad"""
    from .models import Opportunity
    
    opportunity = get_object_or_404(Opportunity, pk=opportunity_id)
    
    # Verificar permisos
    from . import utils
    if not utils.is_agent(request.user):
        if opportunity.created_by != request.user and opportunity.assigned_to != request.user:
            messages.error(request, 'No tienes permisos para ver las actividades de esta oportunidad.')
            return redirect('opportunity_detail', pk=opportunity_id)
    
    activities = opportunity.activities.all()
    
    # Filtros
    status = request.GET.get('status')
    if status:
        activities = activities.filter(status=status)
    
    activity_type = request.GET.get('type')
    if activity_type:
        activities = activities.filter(activity_type=activity_type)
    
    context = {
        'opportunity': opportunity,
        'activities': activities,
        'page_title': f'Actividades - {opportunity.name}'
    }
    
    return render(request, 'tickets/opportunity_activity_list.html', context)


@login_required
def opportunity_activity_detail(request, pk):
    """Detalle de actividad"""
    from .models import OpportunityActivity
    
    activity = get_object_or_404(OpportunityActivity, pk=pk)
    
    # Verificar permisos
    from . import utils
    if not utils.is_agent(request.user):
        if (activity.created_by != request.user and 
            activity.assigned_to != request.user):
            messages.error(request, 'No tienes permisos para ver esta actividad.')
            return redirect('opportunity_detail', pk=activity.opportunity.pk)
    
    context = {
        'activity': activity,
        'page_title': f'Actividad: {activity.title}'
    }
    
    return render(request, 'tickets/opportunity_activity_detail.html', context)


@login_required
def opportunity_activity_edit(request, pk):
    """Editar actividad"""
    from .models import OpportunityActivity
    from .forms import OpportunityActivityForm
    
    activity = get_object_or_404(OpportunityActivity, pk=pk)
    
    # Verificar permisos
    from . import utils
    if not utils.is_agent(request.user):
        if (activity.created_by != request.user and 
            activity.assigned_to != request.user):
            messages.error(request, 'No tienes permisos para editar esta actividad.')
            return redirect('opportunity_activity_detail', pk=pk)
    
    if request.method == 'POST':
        form = OpportunityActivityForm(request.POST, instance=activity, opportunity=activity.opportunity)
        if form.is_valid():
            form.save()
            messages.success(request, 'Actividad actualizada exitosamente.')
            return redirect('opportunity_activity_detail', pk=pk)
    else:
        form = OpportunityActivityForm(instance=activity, opportunity=activity.opportunity)
    
    context = {
        'form': form,
        'activity': activity,
        'opportunity': activity.opportunity,
        'page_title': f'Editar: {activity.title}'
    }
    
    return render(request, 'tickets/opportunity_activity_form.html', context)


@login_required
def opportunity_activity_complete(request, pk):
    """Completar actividad"""
    from .models import OpportunityActivity
    from .forms import OpportunityActivityCompleteForm
    
    activity = get_object_or_404(OpportunityActivity, pk=pk)
    
    # Verificar permisos
    if activity.assigned_to != request.user:
        messages.error(request, 'Solo el asignado puede completar esta actividad.')
        return redirect('opportunity_activity_detail', pk=pk)
    
    if request.method == 'POST':
        form = OpportunityActivityCompleteForm(request.POST, instance=activity)
        if form.is_valid():
            activity = form.save(commit=False)
            if activity.status == 'completed':
                activity.completed_date = timezone.now()
            activity.save()
            
            messages.success(request, 'Actividad completada exitosamente.')
            return redirect('opportunity_activity_detail', pk=pk)
    else:
        form = OpportunityActivityCompleteForm(instance=activity)
    
    context = {
        'form': form,
        'activity': activity,
        'page_title': f'Completar: {activity.title}'
    }
    
    return render(request, 'tickets/opportunity_activity_complete.html', context)


@login_required
def opportunity_activity_delete(request, pk):
    """Eliminar actividad"""
    from .models import OpportunityActivity
    
    activity = get_object_or_404(OpportunityActivity, pk=pk)
    opportunity_id = activity.opportunity.pk
    
    # Verificar permisos
    from . import utils
    if not utils.is_agent(request.user):
        if activity.created_by != request.user:
            messages.error(request, 'No tienes permisos para eliminar esta actividad.')
            return redirect('opportunity_activity_detail', pk=pk)
    
    if request.method == 'POST':
        activity_title = activity.title
        activity.delete()
        messages.success(request, f'Actividad "{activity_title}" eliminada exitosamente.')
        return redirect('opportunity_detail', pk=opportunity_id)
    
    context = {
        'activity': activity,
        'page_title': f'Eliminar: {activity.title}'
    }
    
    return render(request, 'tickets/opportunity_activity_delete.html', context)


@login_required
def my_activities_dashboard(request):
    """Panel de actividades del usuario"""
    from .models import OpportunityActivity
    from django.db.models import Q
    
    # Actividades asignadas al usuario
    activities = OpportunityActivity.objects.filter(assigned_to=request.user)
    
    # Filtros
    status = request.GET.get('status')
    if status:
        activities = activities.filter(status=status)
    
    # Separar por estado y fecha
    today = timezone.now().date()
    
    overdue_activities = activities.filter(
        status__in=['pending', 'in_progress'],
        scheduled_date__date__lt=today
    )
    
    today_activities = activities.filter(
        scheduled_date__date=today
    )
    
    upcoming_activities = activities.filter(
        status__in=['pending', 'in_progress'],
        scheduled_date__date__gt=today
    ).order_by('scheduled_date')[:10]
    
    completed_recent = activities.filter(
        status='completed',
        completed_date__gte=today - timezone.timedelta(days=7)
    ).order_by('-completed_date')[:5]
    
    # Estadísticas
    stats = {
        'total_pending': activities.filter(status='pending').count(),
        'total_in_progress': activities.filter(status='in_progress').count(),
        'total_overdue': overdue_activities.count(),
        'total_today': today_activities.count(),
        'total_completed_week': completed_recent.count(),
    }
    
    context = {
        'overdue_activities': overdue_activities,
        'today_activities': today_activities,
        'upcoming_activities': upcoming_activities,
        'completed_recent': completed_recent,
        'stats': stats,
        'page_title': 'Mis Actividades'
    }
    
    return render(request, 'tickets/my_activities_dashboard.html', context)


# ============================
# VISTAS DE REUNIONES
# ============================

@login_required
@user_passes_test(is_agent, login_url='/')
def meeting_list_view(request):
    """Vista para listar reuniones"""
    from .models import Meeting
    
    meetings = Meeting.objects.filter(organizer=request.user)
    
    # Filtros
    status = request.GET.get('status')
    if status:
        meetings = meetings.filter(status=status)
    
    search = request.GET.get('search')
    if search:
        meetings = meetings.filter(
            models.Q(title__icontains=search) | 
            models.Q(description__icontains=search)
        )
    
    meetings = meetings.order_by('-date')
    
    # Estadísticas
    stats = {
        'total': Meeting.objects.filter(organizer=request.user).count(),
        'scheduled': Meeting.objects.filter(organizer=request.user, status='scheduled').count(),
        'in_progress': Meeting.objects.filter(organizer=request.user, status='in_progress').count(),
        'finished': Meeting.objects.filter(organizer=request.user, status='finished').count(),
    }
    
    context = {
        'page_title': 'Reuniones',
        'meetings': meetings,
        'stats': stats,
        'current_status': status,
        'search_query': search,
    }
    return render(request, 'tickets/meeting_list.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def meeting_create_view(request):
    """Vista para crear reuniones"""
    from .forms import MeetingForm
    
    if request.method == 'POST':
        form = MeetingForm(request.POST, user=request.user)
        if form.is_valid():
            meeting = form.save(commit=False)
            meeting.organizer = request.user
            meeting.save()
            messages.success(request, f'Reunión "{meeting.title}" creada exitosamente.')
            return redirect('meeting_detail', pk=meeting.pk)
    else:
        form = MeetingForm(user=request.user)
    
    context = {
        'page_title': 'Nueva Reunión',
        'form': form,
    }
    return render(request, 'tickets/meeting_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def meeting_detail_view(request, pk):
    """Vista detallada de una reunión"""
    from .models import Meeting
    
    meeting = get_object_or_404(Meeting, pk=pk, organizer=request.user)
    
    # Obtener asistentes y preguntas
    attendees = meeting.meetingattendee_set.all().order_by('registered_at')
    questions = meeting.meetingquestion_set.all().order_by('-asked_at')
    
    # Estadísticas
    stats = {
        'total_attendees': attendees.count(),
        'total_questions': questions.count(),
        'pending_questions': questions.filter(status='pending').count(),
        'answered_questions': questions.filter(status='answered').count(),
    }
    
    context = {
        'page_title': f'Reunión: {meeting.title}',
        'meeting': meeting,
        'attendees': attendees,
        'questions': questions,
        'stats': stats,
    }
    return render(request, 'tickets/meeting_detail.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def meeting_print_view(request, pk):
    """Vista para imprimir reunión"""
    from .models import Meeting
    
    meeting = get_object_or_404(Meeting, pk=pk, organizer=request.user)
    
    # Obtener asistentes y preguntas
    attendees = meeting.meetingattendee_set.all().order_by('registered_at')
    questions = meeting.meetingquestion_set.all().order_by('-asked_at')
    
    # Estadísticas
    stats = {
        'total_attendees': attendees.count(),
        'total_questions': questions.count(),
        'pending_questions': questions.filter(status='pending').count(),
        'answered_questions': questions.filter(status='answered').count(),
    }
    
    context = {
        'page_title': f'Informe: {meeting.title}',
        'meeting': meeting,
        'attendees': attendees,
        'questions': questions,
        'stats': stats,
    }
    return render(request, 'tickets/meeting_print.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def meeting_edit_view(request, pk):
    """Vista para editar reuniones"""
    from .forms import MeetingForm
    from .models import Meeting
    
    meeting = get_object_or_404(Meeting, pk=pk, organizer=request.user)
    
    if request.method == 'POST':
        form = MeetingForm(request.POST, instance=meeting, user=request.user)
        if form.is_valid():
            form.save()
            messages.success(request, f'Reunión "{meeting.title}" actualizada exitosamente.')
            return redirect('meeting_detail', pk=meeting.pk)
    else:
        form = MeetingForm(instance=meeting, user=request.user)
    
    context = {
        'page_title': f'Editar: {meeting.title}',
        'form': form,
        'meeting': meeting,
    }
    return render(request, 'tickets/meeting_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def meeting_delete_view(request, pk):
    """Vista para eliminar reuniones"""
    from .models import Meeting
    
    meeting = get_object_or_404(Meeting, pk=pk, organizer=request.user)
    
    if request.method == 'POST':
        meeting_title = meeting.title
        meeting.delete()
        messages.success(request, f'Reunión "{meeting_title}" eliminada exitosamente.')
        return redirect('meeting_list')
    
    context = {
        'page_title': f'Eliminar: {meeting.title}',
        'meeting': meeting,
    }
    return render(request, 'tickets/meeting_delete.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def meeting_questions_view(request, pk):
    """Vista para gestionar preguntas de una reunión"""
    from .models import Meeting
    
    meeting = get_object_or_404(Meeting, pk=pk, organizer=request.user)
    questions = meeting.meetingquestion_set.all().order_by('-asked_at')
    
    # Filtros
    status = request.GET.get('status')
    if status:
        questions = questions.filter(status=status)
    
    context = {
        'page_title': f'Preguntas: {meeting.title}',
        'meeting': meeting,
        'questions': questions,
        'current_status': status,
    }
    return render(request, 'tickets/meeting_questions.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def meeting_attendees_view(request, pk):
    """Vista para gestionar asistentes de una reunión"""
    from .models import Meeting
    
    meeting = get_object_or_404(Meeting, pk=pk, organizer=request.user)
    attendees = meeting.meetingattendee_set.all().order_by('registered_at')
    
    context = {
        'page_title': f'Asistentes: {meeting.title}',
        'meeting': meeting,
        'attendees': attendees,
    }
    return render(request, 'tickets/meeting_attendees.html', context)


# ============================
# VISTAS PÚBLICAS DE REUNIONES
# ============================

def meeting_public_view(request, token):
    """Vista pública de una reunión"""
    from .models import Meeting, MeetingAttendee, MeetingQuestion
    from .forms import MeetingAttendeeForm, MeetingQuestionForm
    
    meeting = get_object_or_404(Meeting, public_token=token, is_active=True)
    
    # Verificar si hay un usuario registrado en la sesión para esta reunión
    session_key = f'meeting_{meeting.id}_attendee_id'
    user_attendee = None
    user_registered = False
    user_questions = []
    
    if session_key in request.session:
        try:
            attendee_id = request.session[session_key]
            user_attendee = MeetingAttendee.objects.get(id=attendee_id, meeting=meeting)
            user_registered = True
            user_questions = MeetingQuestion.objects.filter(
                meeting=meeting, 
                attendee=user_attendee
            ).order_by('-asked_at')
        except MeetingAttendee.DoesNotExist:
            # Limpiar la sesión si el asistente no existe
            del request.session[session_key]
    
    # Solo mostrar el formulario de registro si no hay nadie registrado en la sesión
    register_form = None
    if not user_registered:
        register_form = MeetingAttendeeForm(meeting=meeting)
    
    question_form = MeetingQuestionForm() if meeting.allow_questions and user_registered else None
    
    context = {
        'page_title': f'Reunión: {meeting.title}',
        'meeting': meeting,
        'user_registered': user_registered,
        'user_attendee': user_attendee,
        'user_questions': user_questions,
        'register_form': register_form,
        'question_form': question_form,
    }
    return render(request, 'tickets/meeting_public.html', context)


def meeting_register_view(request, token):
    """Vista pública para registrarse en una reunión"""
    from .models import Meeting
    from .forms import MeetingAttendeeForm
    
    meeting = get_object_or_404(Meeting, public_token=token, is_active=True)
    
    # Verificar si ya hay un usuario registrado en esta sesión
    session_key = f'meeting_{meeting.id}_attendee_id'
    if session_key in request.session:
        messages.warning(request, 'Ya hay una persona registrada en esta sesión. Solo se permite un registro por sesión.')
        return redirect('meeting_public', token=token)
    
    if request.method == 'POST':
        form = MeetingAttendeeForm(request.POST, meeting=meeting)
        if form.is_valid():
            attendee = form.save(commit=False)
            attendee.meeting = meeting
            attendee.ip_address = request.META.get('REMOTE_ADDR')
            attendee.save()
            
            # Guardar el ID del asistente en la sesión
            request.session[session_key] = attendee.id
            
            messages.success(request, '¡Te has registrado exitosamente en la reunión!')
            return redirect('meeting_public', token=token)
    else:
        form = MeetingAttendeeForm(meeting=meeting)
    
    context = {
        'page_title': f'Registrarse: {meeting.title}',
        'meeting': meeting,
        'form': form,
    }
    return render(request, 'tickets/meeting_register.html', context)


def meeting_questions_public_view(request, token):
    """Vista pública para ver preguntas de una reunión"""
    from .models import Meeting
    
    meeting = get_object_or_404(Meeting, public_token=token, is_active=True)
    
    if not meeting.allow_questions:
        messages.error(request, 'Esta reunión no permite preguntas.')
        return redirect('meeting_public', token=token)
    
    questions = meeting.meetingquestion_set.filter(status__in=['pending', 'answered']).order_by('-asked_at')
    
    context = {
        'page_title': f'Preguntas: {meeting.title}',
        'meeting': meeting,
        'questions': questions,
    }
    return render(request, 'tickets/meeting_questions_public.html', context)


def meeting_ask_question_view(request, token):
    """Vista pública para hacer una pregunta"""
    from .models import Meeting, MeetingAttendee
    from .forms import MeetingQuestionForm
    
    meeting = get_object_or_404(Meeting, public_token=token, is_active=True)
    
    if not meeting.allow_questions:
        messages.error(request, 'Esta reunión no permite preguntas.')
        return redirect('meeting_public', token=token)
    
    # Verificar si hay un asistente registrado en la sesión
    session_key = f'meeting_{meeting.id}_attendee_id'
    user_attendee = None
    
    if session_key in request.session:
        try:
            attendee_id = request.session[session_key]
            user_attendee = MeetingAttendee.objects.get(id=attendee_id, meeting=meeting)
        except MeetingAttendee.DoesNotExist:
            pass
    
    if request.method == 'POST':
        form = MeetingQuestionForm(request.POST)
        if form.is_valid():
            question = form.save(commit=False)
            question.meeting = meeting
            question.attendee = user_attendee  # Asociar con el asistente de la sesión
            question.ip_address = request.META.get('REMOTE_ADDR')
            
            # Si no hay asistente en sesión, usar los datos del formulario
            if not user_attendee:
                question.asker_name = question.asker_name or 'Anónimo'
                question.asker_email = question.asker_email or ''
            else:
                question.asker_name = user_attendee.name
                question.asker_email = user_attendee.email
            
            question.save()
            messages.success(request, '¡Tu pregunta ha sido enviada!')
            return redirect('meeting_public', token=token)
    else:
        form = MeetingQuestionForm()
    
    context = {
        'page_title': f'Hacer Pregunta: {meeting.title}',
        'meeting': meeting,
        'form': form,
    }
    return render(request, 'tickets/meeting_ask_question.html', context)
    
    context = {
        'page_title': f'Hacer Pregunta: {meeting.title}',
        'meeting': meeting,
        'form': form,
    }
    return render(request, 'tickets/meeting_ask_question.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def meeting_answer_question_view(request, pk, question_id):
    """Vista AJAX para responder preguntas"""
    from .models import Meeting, MeetingQuestion
    import json
    
    meeting = get_object_or_404(Meeting, pk=pk, organizer=request.user)
    question = get_object_or_404(MeetingQuestion, pk=question_id, meeting=meeting)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            answer = data.get('answer', '').strip()
            
            if not answer:
                return JsonResponse({
                    'success': False,
                    'error': 'La respuesta no puede estar vacía.'
                })
            
            question.answer = answer
            question.answered_by = request.user
            question.answered_at = timezone.now()
            question.status = 'answered'
            question.save()
            
            return JsonResponse({
                'success': True,
                'message': 'Pregunta respondida exitosamente.'
            })
            
        except json.JSONDecodeError:
            return JsonResponse({
                'success': False,
                'error': 'Datos JSON inválidos.'
            })
        except Exception as e:
            return JsonResponse({
                'success': False,
                'error': f'Error al procesar la respuesta: {str(e)}'
            })
    
    return JsonResponse({'success': False, 'error': 'Método no permitido.'})


# ========================
# SISTEMA DE CAPACITACIÓN
# ========================

@login_required
def debug_user_access(request):
    """Vista de debug para verificar acceso de usuarios a cursos"""
    from .models import Course, Company
    from django.http import HttpResponse
    
    debug_info = []
    debug_info.append(f"Usuario actual: {request.user.username}")
    debug_info.append(f"Es agente: {request.user.groups.filter(name='Agentes').exists()}")
    
    try:
        profile = request.user.userprofile
        debug_info.append(f"UserProfile existe: Sí")
        debug_info.append(f"Empresa del usuario: {profile.company}")
        debug_info.append(f"ID de empresa del usuario: {profile.company.id if profile.company else 'None'}")
    except Exception as e:
        debug_info.append(f"Error con UserProfile: {e}")
    
    debug_info.append("\n--- CURSOS ---")
    courses = Course.objects.filter(is_active=True)
    for course in courses:
        debug_info.append(f"\nCurso: {course.title}")
        debug_info.append(f"Empresa del curso: {course.company}")
        debug_info.append(f"ID empresa del curso: {course.company.id if course.company else 'None'}")
        debug_info.append(f"Puede acceder: {course.can_user_access(request.user)}")
    
    debug_info.append("\n--- EMPRESAS ---")
    companies = Company.objects.all()
    for company in companies:
        debug_info.append(f"Empresa: {company.name} (ID: {company.id})")
    
    return HttpResponse("<pre>" + "\n".join(debug_info) + "</pre>")

@login_required
def course_generate_public_token(request, pk):
    """Generar token público para un curso"""
    from .models import Course
    from django.contrib import messages
    from django.http import JsonResponse
    
    course = get_object_or_404(Course, pk=pk, is_active=True)
    
    # Verificar permisos - solo el creador o superusuario
    if course.created_by != request.user and not request.user.is_superuser:
        # Verificar si es una petición AJAX usando headers
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return JsonResponse({'success': False, 'error': 'No tienes permisos para esta acción'})
        messages.error(request, 'No tienes permisos para generar enlaces públicos.')
        return redirect('course_detail', pk=pk)
    
    # Generar token
    token = course.generate_public_token()
    public_url = course.get_public_url(request)
    
    # Verificar si es una petición AJAX usando headers
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        return JsonResponse({
            'success': True, 
            'token': str(token),
            'public_url': public_url,
            'message': 'Enlace público generado exitosamente'
        })
    
    messages.success(request, f'Enlace público generado: {public_url}')
    return redirect('course_detail', pk=pk)

@login_required
def course_disable_public_access(request, pk):
    """Deshabilitar acceso público a un curso"""
    from .models import Course
    from django.contrib import messages
    from django.http import JsonResponse
    
    course = get_object_or_404(Course, pk=pk, is_active=True)
    
    # Verificar permisos
    if course.created_by != request.user and not request.user.is_superuser:
        # Verificar si es una petición AJAX usando headers
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return JsonResponse({'success': False, 'error': 'No tienes permisos para esta acción'})
        messages.error(request, 'No tienes permisos para deshabilitar el acceso público.')
        return redirect('course_detail', pk=pk)
    
    course.disable_public_access()
    
    # Verificar si es una petición AJAX usando headers
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        return JsonResponse({'success': True, 'message': 'Acceso público deshabilitado'})
    
    messages.success(request, 'Acceso público deshabilitado correctamente.')
    return redirect('course_detail', pk=pk)

def course_public(request, token):
    """Vista pública del curso (sin autenticación requerida)"""
    from .models import Course, CourseClassView
    from django.shortcuts import get_object_or_404
    
    course = get_object_or_404(
        Course, 
        public_token=token, 
        is_public_enabled=True, 
        is_active=True
    )
    
    classes = course.classes.filter(is_active=True).order_by('order', 'title')
    
    # Agregar información de visualizaciones para cada clase
    classes_with_views = []
    for course_class in classes:
        view_count = course_class.get_view_count()
        user_has_viewed = False
        
        # Si hay usuario autenticado, verificar si ha visto la clase
        if request.user.is_authenticated:
            user_has_viewed = course_class.is_viewed_by_user(request.user)
        
        classes_with_views.append({
            'class': course_class,
            'view_count': view_count,
            'user_has_viewed': user_has_viewed,
            'status': 'vista' if user_has_viewed else 'sin ver'
        })
    
    context = {
        'course': course,
        'classes_with_views': classes_with_views,
        'page_title': f'Curso: {course.title}',
        'is_public_view': True
    }
    
    return render(request, 'tickets/course_public.html', context)

def course_class_public(request, token, class_id):
    """Vista pública de una clase específica"""
    from .models import Course, CourseClass, CourseClassView
    
    course = get_object_or_404(
        Course, 
        public_token=token, 
        is_public_enabled=True, 
        is_active=True
    )
    course_class = get_object_or_404(CourseClass, pk=class_id, course=course, is_active=True)
    
    # Verificar si el usuario autenticado ha visto la clase
    user_has_viewed = False
    if request.user.is_authenticated:
        user_has_viewed = course_class.is_viewed_by_user(request.user)
    
    # Registrar la visualización solo si hay usuario autenticado
    if request.user.is_authenticated:
        view_obj, created = CourseClassView.objects.get_or_create(
            course_class=course_class,
            user=request.user,
            defaults={
                'ip_address': get_client_ip(request)
            }
        )
        
        # Incrementar contador de vistas solo si es una nueva visualización
        if created:
            course_class.save()
    
    # Obtener clases siguientes y anteriores
    all_classes = course.classes.filter(is_active=True).order_by('order', 'title')
    current_index = None
    
    for i, class_item in enumerate(all_classes):
        if class_item.pk == course_class.pk:
            current_index = i
            break
    
    prev_class = None
    next_class = None
    
    if current_index is not None:
        if current_index > 0:
            prev_class = all_classes[current_index - 1]
        if current_index < len(all_classes) - 1:
            next_class = all_classes[current_index + 1]
    
    context = {
        'course': course,
        'course_class': course_class,
        'page_title': f'{course.title} - {course_class.title}',
        'user_has_viewed': user_has_viewed,
        'prev_class': prev_class,
        'next_class': next_class,
    }
    
    return render(request, 'tickets/course_class_public.html', context)

@login_required
def course_list(request):
    """Lista todos los cursos disponibles"""
    from .models import Course
    from . import utils
    
    # Verificar si el usuario puede gestionar cursos (agentes y profesores)
    can_manage = utils.can_manage_courses(request.user)
    
    # Filtrar cursos según la empresa del usuario
    courses = Course.objects.filter(is_active=True)
    
    if can_manage:
        # Los gestores (agentes y profesores) siempre ven todos los cursos (públicos y empresariales)
        user_accessible_courses = list(courses)
    else:
        # Filtrar según empresa del usuario para usuarios no gestores
        user_accessible_courses = []
        for course in courses:
            if course.can_user_access(request.user):
                user_accessible_courses.append(course)
    
    context = {
        'courses': user_accessible_courses,
        'can_manage_courses': can_manage,
        'page_title': 'Cursos de Capacitación'
    }
    
    return render(request, 'tickets/course_list.html', context)


@login_required
def course_detail(request, pk):
    """Detalle de un curso con sus clases"""
    from .models import Course
    from . import utils
    
    course = get_object_or_404(Course, pk=pk, is_active=True)
    
    # Verificar si el usuario puede gestionar cursos (agentes y profesores)
    can_manage = utils.can_manage_courses(request.user)
    
    # Verificar si el usuario puede acceder a este curso
    if not can_manage and not course.can_user_access(request.user):
        messages.error(request, 'No tienes permisos para acceder a este curso.')
        return redirect('course_list')
    
    classes = course.classes.filter(is_active=True).order_by('order', 'title')
    
    # Agregar información de visualizaciones para cada clase
    classes_with_views = []
    for course_class in classes:
        view_count = course_class.get_view_count()
        user_has_viewed = course_class.is_viewed_by_user(request.user)
        
        classes_with_views.append({
            'class': course_class,
            'view_count': view_count,
            'user_has_viewed': user_has_viewed,
        })
    
    context = {
        'course': course,
        'classes': classes,
        'classes_with_views': classes_with_views,
        'can_manage_courses': can_manage,
        'page_title': f'Curso: {course.title}'
    }
    
    return render(request, 'tickets/course_detail.html', context)


@login_required
def course_create(request):
    """Crear nuevo curso (agentes y profesores)"""
    from .models import Course
    from .forms import CourseForm
    from . import utils
    
    if not utils.can_manage_courses(request.user):
        messages.error(request, 'Solo los agentes y profesores pueden crear cursos.')
        return redirect('course_list')
    
    if request.method == 'POST':
        form = CourseForm(request.POST)
        if form.is_valid():
            course = form.save(commit=False)
            course.created_by = request.user
            course.save()
            messages.success(request, f'Curso "{course.title}" creado exitosamente.')
            return redirect('course_detail', pk=course.pk)
    else:
        form = CourseForm()
    
    context = {
        'form': form,
        'page_title': 'Crear Nuevo Curso'
    }
    
    return render(request, 'tickets/course_form.html', context)


@login_required
def course_edit(request, pk):
    """Editar curso (agentes y profesores)"""
    from .models import Course
    from .forms import CourseForm
    from . import utils
    
    course = get_object_or_404(Course, pk=pk)
    
    if not utils.can_manage_courses(request.user):
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('crm_dashboard')
    
    if request.method == 'POST':
        form = CourseForm(request.POST, instance=course)
        if form.is_valid():
            form.save()
            messages.success(request, f'Curso "{course.title}" actualizado exitosamente.')
            return redirect('course_detail', pk=pk)
    else:
        form = CourseForm(instance=course)
    
    context = {
        'form': form,
        'course': course,
        'page_title': f'Editar: {course.title}'
    }
    
    return render(request, 'tickets/course_form.html', context)


@login_required
def course_delete(request, pk):
    """Eliminar curso (agentes y profesores)"""
    from .models import Course
    from . import utils
    
    course = get_object_or_404(Course, pk=pk)
    
    if not utils.can_manage_courses(request.user):
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('crm_dashboard')
    
    if request.method == 'POST':
        course_title = course.title
        course.delete()
        messages.success(request, f'Curso "{course_title}" eliminado exitosamente.')
        return redirect('course_list')
    
    context = {
        'course': course,
        'page_title': f'Eliminar: {course.title}'
    }
    
    return render(request, 'tickets/course_delete.html', context)


@login_required
def course_class_create(request, course_id):
    """Crear nueva clase para un curso (agentes y profesores)"""
    from .models import Course, CourseClass
    from .forms import CourseClassForm
    from . import utils
    
    course = get_object_or_404(Course, pk=course_id)
    
    if not utils.can_manage_courses(request.user):
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('crm_dashboard')
    
    if request.method == 'POST':
        form = CourseClassForm(request.POST)
        if form.is_valid():
            course_class = form.save(commit=False)
            course_class.course = course
            course_class.created_by = request.user
            course_class.save()
            messages.success(request, f'Clase "{course_class.title}" agregada exitosamente.')
            return redirect('course_detail', pk=course_id)
    else:
        # Sugerir el siguiente número de orden
        next_order = course.classes.count() + 1
        form = CourseClassForm(initial={'order': next_order})
    
    context = {
        'form': form,
        'course': course,
        'page_title': f'Nueva Clase - {course.title}'
    }
    
    return render(request, 'tickets/course_class_form.html', context)


@login_required
def course_class_edit(request, course_id, pk):
    """Editar clase (agentes y profesores)"""
    from .models import Course, CourseClass
    from .forms import CourseClassForm
    from . import utils
    
    course = get_object_or_404(Course, pk=course_id)
    course_class = get_object_or_404(CourseClass, pk=pk, course=course)
    
    if not utils.can_manage_courses(request.user):
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('crm_dashboard')
    
    if request.method == 'POST':
        form = CourseClassForm(request.POST, instance=course_class)
        if form.is_valid():
            form.save()
            messages.success(request, f'Clase "{course_class.title}" actualizada exitosamente.')
            return redirect('course_detail', pk=course_id)
    else:
        form = CourseClassForm(instance=course_class)
    
    context = {
        'form': form,
        'course': course,
        'course_class': course_class,
        'page_title': f'Editar: {course_class.title}'
    }
    
    return render(request, 'tickets/course_class_form.html', context)


@login_required
def course_class_delete(request, course_id, pk):
    """Eliminar clase (agentes y profesores)"""
    from .models import Course, CourseClass
    from . import utils
    
    course = get_object_or_404(Course, pk=course_id)
    course_class = get_object_or_404(CourseClass, pk=pk, course=course)
    
    if not utils.can_manage_courses(request.user):
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('crm_dashboard')
    
    if request.method == 'POST':
        class_title = course_class.title
        course_class.delete()
        messages.success(request, f'Clase "{class_title}" eliminada exitosamente.')
        return redirect('course_detail', pk=course_id)
    
    context = {
        'course': course,
        'course_class': course_class,
        'page_title': f'Eliminar: {course_class.title}'
    }
    
    return render(request, 'tickets/course_class_delete.html', context)


@login_required
def course_class_detail(request, course_id, pk):
    """Ver detalle de una clase específica"""
    from .models import Course, CourseClass, CourseClassView
    
    course = get_object_or_404(Course, pk=course_id, is_active=True)
    course_class = get_object_or_404(CourseClass, pk=pk, course=course, is_active=True)
    
    # Verificar si el usuario es agente
    is_agent = request.user.groups.filter(name='Agentes').exists()
    
    # Verificar si el usuario puede acceder a este curso
    if not is_agent and not course.can_user_access(request.user):
        messages.error(request, 'No tienes permisos para acceder a este curso.')
        return redirect('course_list')
    
    # Registrar la visualización si no existe
    view_obj, created = CourseClassView.objects.get_or_create(
        course_class=course_class,
        user=request.user,
        defaults={
            'ip_address': get_client_ip(request)
        }
    )
    
    # Obtener clases anterior y siguiente para navegación
    all_classes = course.classes.filter(is_active=True).order_by('order', 'title')
    current_index = None
    
    for i, class_item in enumerate(all_classes):
        if class_item.pk == course_class.pk:
            current_index = i
            break
    
    prev_class = None
    next_class = None
    
    if current_index is not None:
        if current_index > 0:
            prev_class = all_classes[current_index - 1]
        if current_index < len(all_classes) - 1:
            next_class = all_classes[current_index + 1]
    
    context = {
        'course': course,
        'course_class': course_class,
        'page_title': f'{course.title} - {course_class.title}',
        'user_has_viewed': True,  # Siempre True ya que acabamos de registrar la vista
        'prev_class': prev_class,
        'next_class': next_class,
    }
    
    return render(request, 'tickets/course_class_detail.html', context)


def get_client_ip(request):
    """Obtiene la IP del cliente"""
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0]
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip


@login_required
def mark_class_as_viewed(request, course_id, class_id):
    """Marcar una clase como vista via AJAX"""
    from .models import Course, CourseClass, CourseClassView
    from django.http import JsonResponse
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'})
    
    try:
        course = get_object_or_404(Course, pk=course_id, is_active=True)
        course_class = get_object_or_404(CourseClass, pk=class_id, course=course, is_active=True)
        
        # Verificar si el usuario es agente
        is_agent = request.user.groups.filter(name='Agentes').exists()
        
        # Verificar si el usuario puede acceder a este curso
        if not is_agent and not course.can_user_access(request.user):
            return JsonResponse({'success': False, 'error': 'No tienes permisos para acceder a este curso'})
        
        # Crear o actualizar la visualización
        view_obj, created = CourseClassView.objects.get_or_create(
            course_class=course_class,
            user=request.user,
            defaults={
                'ip_address': get_client_ip(request)
            }
        )
        
        return JsonResponse({
            'success': True,
            'created': created,
            'view_count': course_class.get_view_count(),
            'message': 'Clase marcada como vista' if created else 'Ya habías visto esta clase'
        })
        
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)})


# ===== VISTAS DE CONTACTOS =====

@login_required
def contact_list(request):
    """Lista de contactos con filtros"""
    contacts = Contact.objects.all()
    
    # Filtros
    status = request.GET.get('status')
    if status:
        contacts = contacts.filter(status=status)
    
    source = request.GET.get('source')
    if source:
        contacts = contacts.filter(source__icontains=f"Generador: {source}")
    
    search = request.GET.get('search')
    if search:
        contacts = contacts.filter(
            Q(name__icontains=search) |
            Q(email__icontains=search) |
            Q(company__icontains=search) |
            Q(phone__icontains=search) |
            Q(erp__icontains=search)
        )
    
    date_from = request.GET.get('date_from')
    if date_from:
        contacts = contacts.filter(contact_date__date__gte=date_from)
    
    date_to = request.GET.get('date_to')
    if date_to:
        contacts = contacts.filter(contact_date__date__lte=date_to)
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(contacts, 25)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Estadísticas
    total_contacts = Contact.objects.count()
    positive_contacts = Contact.objects.filter(status='positive').count()
    negative_contacts = Contact.objects.filter(status='negative').count()
    today_contacts = Contact.objects.filter(contact_date__date=timezone.now().date()).count()
    
    context = {
        'page_obj': page_obj,
        'contacts': page_obj.object_list,
        'total_contacts': total_contacts,
        'positive_contacts': positive_contacts,
        'negative_contacts': negative_contacts,
        'today_contacts': today_contacts,
        'page_title': 'Contactos'
    }
    
    return render(request, 'tickets/contact_list.html', context)


@login_required
def contact_create(request):
    """Crear nuevo contacto"""
    from .forms import ContactForm
    
    if request.method == 'POST':
        form = ContactForm(request.POST)
        if form.is_valid():
            contact = form.save(commit=False)
            contact.created_by = request.user
            contact.save()
            
            messages.success(request, f'Contacto "{contact.name}" creado exitosamente.')
            return redirect('contact_detail', pk=contact.pk)
    else:
        form = ContactForm()
    
    context = {
        'form': form,
        'page_title': 'Nuevo Contacto'
    }
    
    return render(request, 'tickets/contact_form.html', context)


@login_required
def contact_detail(request, pk):
    """Ver detalles de un contacto"""
    contact = get_object_or_404(Contact, pk=pk)
    
    context = {
        'contact': contact,
        'page_title': f'Contacto: {contact.name}'
    }
    
    return render(request, 'tickets/contact_detail.html', context)


@login_required
def contact_edit(request, pk):
    """Editar contacto"""
    from .forms import ContactForm
    
    contact = get_object_or_404(Contact, pk=pk)
    
    if request.method == 'POST':
        form = ContactForm(request.POST, instance=contact)
        if form.is_valid():
            form.save()
            
            messages.success(request, f'Contacto "{contact.name}" actualizado exitosamente.')
            return redirect('contact_detail', pk=contact.pk)
    else:
        form = ContactForm(instance=contact)
    
    context = {
        'form': form,
        'contact': contact,
        'page_title': f'Editar: {contact.name}'
    }
    
    return render(request, 'tickets/contact_form.html', context)


@login_required
def contact_delete(request, pk):
    """Eliminar contacto"""
    contact = get_object_or_404(Contact, pk=pk)
    
    if request.method == 'POST':
        contact_name = contact.name
        contact.delete()
        messages.success(request, f'Contacto "{contact_name}" eliminado exitosamente.')
        return redirect('contact_list')
    
    context = {
        'contact': contact,
        'page_title': f'Eliminar: {contact.name}'
    }
    
    return render(request, 'tickets/contact_delete.html', context)


# ===== VISTAS DEL BLOG =====

def blog_list(request):
    """Lista pública de artículos del blog"""
    posts = BlogPost.objects.filter(status='published').select_related('category', 'created_by')
    
    # Filtros
    category_slug = request.GET.get('category')
    if category_slug:
        posts = posts.filter(category__slug=category_slug)
    
    search = request.GET.get('search')
    if search:
        posts = posts.filter(
            Q(title__icontains=search) |
            Q(excerpt__icontains=search) |
            Q(content__icontains=search) |
            Q(tags__icontains=search)
        )
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(posts, 12)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Categorías para el menú
    categories = BlogCategory.objects.filter(is_active=True)
    
    # Artículos destacados
    featured_posts = BlogPost.objects.filter(
        status='published', 
        is_featured=True
    ).select_related('category')[:3]
    
    context = {
        'page_obj': page_obj,
        'posts': page_obj.object_list,
        'categories': categories,
        'featured_posts': featured_posts,
        'current_category': category_slug,
        'page_title': 'Blog',
        'is_authenticated': request.user.is_authenticated,
    }
    
    return render(request, 'tickets/blog_list.html', context)


def blog_post_detail(request, slug):
    """Vista detalle de un artículo del blog"""
    post = get_object_or_404(BlogPost, slug=slug, status='published')
    
    # Incrementar contador de visualizaciones
    post.increment_views()
    
    # Procesar comentarios
    if request.method == 'POST':
        from .forms import BlogCommentForm
        comment_form = BlogCommentForm(request.POST)
        if comment_form.is_valid():
            comment = comment_form.save(commit=False)
            comment.post = post
            
            # Obtener IP del usuario
            x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
            if x_forwarded_for:
                comment.ip_address = x_forwarded_for.split(',')[0]
            else:
                comment.ip_address = request.META.get('REMOTE_ADDR')
            
            comment.save()
            messages.success(request, 'Tu comentario ha sido enviado y está pendiente de aprobación.')
            return redirect('blog_post_detail', slug=slug)
    else:
        from .forms import BlogCommentForm
        comment_form = BlogCommentForm()
    
    # Comentarios aprobados
    comments = post.comments.filter(is_approved=True).order_by('created_at')
    
    # Artículos relacionados
    related_posts = BlogPost.objects.filter(
        status='published',
        category=post.category
    ).exclude(pk=post.pk)[:3]
    
    context = {
        'post': post,
        'comments': comments,
        'comment_form': comment_form,
        'related_posts': related_posts,
        'page_title': post.title,
        'is_authenticated': request.user.is_authenticated,
    }
    
    return render(request, 'tickets/blog_post_detail.html', context)


@login_required
def blog_category_list(request):
    """Lista de categorías del blog (admin)"""
    categories = BlogCategory.objects.all().order_by('name')
    
    context = {
        'categories': categories,
        'page_title': 'Categorías de Blog'
    }
    
    return render(request, 'tickets/blog_category_list.html', context)


@login_required
def blog_category_create(request):
    """Crear nueva categoría de blog"""
    from .forms import BlogCategoryForm
    
    if request.method == 'POST':
        print(f"POST data: {request.POST}")
        form = BlogCategoryForm(request.POST)
        print(f"Form is valid: {form.is_valid()}")
        if not form.is_valid():
            print(f"Form errors: {form.errors}")
        
        if form.is_valid():
            try:
                category = form.save(commit=False)
                category.created_by = request.user
                
                # Auto-generar slug único
                from django.utils.text import slugify
                base_slug = slugify(category.name)
                slug = base_slug
                counter = 1
                
                # Verificar si el slug ya existe y crear uno único
                while BlogCategory.objects.filter(slug=slug).exists():
                    slug = f"{base_slug}-{counter}"
                    counter += 1
                
                category.slug = slug
                category.save()
                print(f"Categoría creada: {category.name} - {category.slug}")
                
                messages.success(request, f'Categoría "{category.name}" creada exitosamente.')
                return redirect('blog_category_list')
                
            except Exception as e:
                print(f"Exception al crear categoría: {str(e)}")
                messages.error(request, f'Error al crear la categoría: {str(e)}')
        else:
            messages.error(request, 'Por favor corrige los errores en el formulario.')
    else:
        form = BlogCategoryForm()
    
    context = {
        'form': form,
        'page_title': 'Nueva Categoría'
    }
    
    return render(request, 'tickets/blog_category_form.html', context)


@login_required
def blog_post_list_admin(request):
    """Lista de artículos del blog (admin)"""
    posts = BlogPost.objects.all().select_related('category', 'created_by')
    
    # Filtros
    status = request.GET.get('status')
    if status:
        posts = posts.filter(status=status)
    
    category_id = request.GET.get('category')
    if category_id:
        posts = posts.filter(category_id=category_id)
    
    search = request.GET.get('search')
    if search:
        posts = posts.filter(
            Q(title__icontains=search) |
            Q(excerpt__icontains=search)
        )
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(posts, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    categories = BlogCategory.objects.filter(is_active=True)
    
    context = {
        'page_obj': page_obj,
        'posts': page_obj.object_list,
        'categories': categories,
        'page_title': 'Gestión de Blog'
    }
    
    return render(request, 'tickets/blog_post_list_admin.html', context)


@login_required
def blog_post_create(request):
    """Crear nuevo artículo de blog"""
    from .forms import BlogPostForm
    
    if request.method == 'POST':
        form = BlogPostForm(request.POST, request.FILES)
        if form.is_valid():
            post = form.save(commit=False)
            post.created_by = request.user
            post.save()
            
            messages.success(request, f'Artículo "{post.title}" creado exitosamente.')
            return redirect('blog_post_detail_admin', pk=post.pk)
    else:
        form = BlogPostForm()
    
    context = {
        'form': form,
        'page_title': 'Nuevo Artículo'
    }
    
    return render(request, 'tickets/blog_post_form.html', context)


@login_required
def blog_post_detail_admin(request, pk):
    """Vista detalle de artículo (admin)"""
    post = get_object_or_404(BlogPost, pk=pk)
    
    # Comentarios pendientes
    pending_comments = post.comments.filter(is_approved=False).order_by('-created_at')
    approved_comments = post.comments.filter(is_approved=True).order_by('-created_at')
    
    context = {
        'post': post,
        'pending_comments': pending_comments,
        'approved_comments': approved_comments,
        'page_title': f'Artículo: {post.title}'
    }
    
    return render(request, 'tickets/blog_post_detail_admin.html', context)


@login_required
def blog_comment_approve(request, pk):
    """Aprobar comentario"""
    comment = get_object_or_404(BlogComment, pk=pk)
    comment.is_approved = True
    comment.save()
    
    messages.success(request, 'Comentario aprobado exitosamente.')
    return redirect('blog_post_detail_admin', pk=comment.post.pk)


@login_required
def blog_comment_delete(request, pk):
    """Eliminar comentario"""
    comment = get_object_or_404(BlogComment, pk=pk)
    post_pk = comment.post.pk
    comment.delete()
    
    messages.success(request, 'Comentario eliminado exitosamente.')
    return redirect('blog_post_detail_admin', pk=post_pk)


@login_required
def blog_post_edit(request, pk):
    """Editar artículo de blog"""
    from .forms import BlogPostForm
    
    post = get_object_or_404(BlogPost, pk=pk)
    
    if request.method == 'POST':
        form = BlogPostForm(request.POST, request.FILES, instance=post)
        if form.is_valid():
            post = form.save(commit=False)
            
            # Si se está publicando por primera vez, establecer fecha de publicación
            if post.status == 'published' and not post.published_at:
                from django.utils import timezone
                post.published_at = timezone.now()
            
            post.save()
            messages.success(request, f'Artículo "{post.title}" actualizado exitosamente.')
            return redirect('blog_post_detail_admin', pk=post.pk)
    else:
        form = BlogPostForm(instance=post)
    
    context = {
        'form': form,
        'post': post,
        'page_title': f'Editar: {post.title}',
        'action': 'Actualizar'
    }
    
    return render(request, 'tickets/blog_post_form.html', context)


@login_required
def blog_post_toggle_status(request, pk):
    """Cambiar estado de publicación del artículo"""
    post = get_object_or_404(BlogPost, pk=pk)
    
    if post.status == 'published':
        post.status = 'draft'
        post.published_at = None
        messages.success(request, f'Artículo "{post.title}" despublicado.')
    else:
        post.status = 'published'
        if not post.published_at:
            from django.utils import timezone
            post.published_at = timezone.now()
        messages.success(request, f'Artículo "{post.title}" publicado exitosamente.')
    
    post.save()
    return redirect('blog_post_detail_admin', pk=post.pk)


@login_required
def blog_post_delete(request, pk):
    """Eliminar artículo de blog"""
    post = get_object_or_404(BlogPost, pk=pk)
    
    if request.method == 'POST':
        title = post.title
        post.delete()
        messages.success(request, f'Artículo "{title}" eliminado exitosamente.')
        return redirect('blog_post_list_admin')
    
    context = {
        'post': post,
        'page_title': f'Eliminar: {post.title}'
    }
    
    return render(request, 'tickets/blog_post_delete.html', context)


# ===========================================
# VISTAS PARA CHAT CON IA
# ===========================================

@login_required
def ai_chat_list_view(request):
    """Vista principal del chat con IA - lista de sesiones"""
    config = SystemConfiguration.get_config()
    
    # Verificar si el chat IA está habilitado
    if not config.ai_chat_enabled:
        messages.warning(request, 'El chat con IA no está habilitado en el sistema.')
        return redirect('dashboard')
    
    # Verificar si hay API key configurada
    if not config.openai_api_key:
        messages.warning(request, 'El chat con IA no está configurado. Contacta al administrador.')
        return redirect('dashboard')
    
    # Obtener sesiones del usuario
    sessions = AIChatSession.objects.filter(user=request.user, is_active=True)
    
    # Formulario para nueva sesión
    if request.method == 'POST':
        form = AIChatSessionForm(request.POST)
        if form.is_valid():
            session = form.save(commit=False)
            session.user = request.user
            session.save()
            messages.success(request, f'Nueva conversación creada: {session.title}')
            return redirect('ai_chat_live', session_id=session.id)
    else:
        form = AIChatSessionForm(initial={'ai_model': config.openai_model})
    
    context = {
        'sessions': sessions,
        'form': form,
        'config': config,
    }
    
    return render(request, 'tickets/ai_chat_list.html', context)


@login_required
def ai_chat_session_view(request, session_id):
    """Vista para una sesión específica de chat con IA"""
    config = SystemConfiguration.get_config()
    
    # Verificar si el chat IA está habilitado
    if not config.ai_chat_enabled or not config.openai_api_key:
        messages.warning(request, 'El chat con IA no está disponible.')
        return redirect('dashboard')
    
    # Obtener la sesión
    session = get_object_or_404(AIChatSession, id=session_id, user=request.user, is_active=True)
    
    # Obtener mensajes de la sesión
    messages_list = session.messages.all()
    
    # Formulario para nuevo mensaje
    if request.method == 'POST':
        print(f"DEBUG: POST recibido para sesión {session_id}")
        print(f"DEBUG: request.POST completo: {dict(request.POST)}")
        print(f"DEBUG: request.POST.get('message'): '{request.POST.get('message', 'NO_ENCONTRADO')}'")
        print(f"DEBUG: Content-Type: {request.content_type}")
        print(f"DEBUG: POST keys: {list(request.POST.keys())}")
        
        form = AIChatMessageForm(request.POST)
        print(f"DEBUG: Formulario creado con datos: {form.data}")
        print(f"DEBUG: Formulario es válido: {form.is_valid()}")
        
        if form.is_valid():
            user_message = form.cleaned_data['message']
            print(f"DEBUG: Mensaje del usuario: {user_message}")
            
            # Guardar mensaje del usuario
            user_msg = AIChatMessage.objects.create(
                session=session,
                role='user',
                content=user_message
            )
            print(f"DEBUG: Mensaje del usuario guardado con ID: {user_msg.id}")
            
            # Llamar a la API de OpenAI
            try:
                print("DEBUG: Llamando a OpenAI API...")
                ai_response = call_openai_api(session, user_message)
                print(f"DEBUG: Respuesta de OpenAI recibida: {ai_response['content'][:50]}...")
                
                # Guardar respuesta de la IA
                ai_msg = AIChatMessage.objects.create(
                    session=session,
                    role='assistant',
                    content=ai_response['content'],
                    tokens_used=ai_response.get('tokens_used', 0)
                )
                print(f"DEBUG: Respuesta de IA guardada con ID: {ai_msg.id}")
                
                messages.success(request, 'Mensaje enviado correctamente.')
                
            except Exception as e:
                print(f"DEBUG: Error en OpenAI API: {str(e)}")
                messages.error(request, f'Error al comunicarse con la IA: {str(e)}')
            
            return redirect('ai_chat_session', session_id=session.id)
        else:
            print(f"DEBUG: Formulario no válido. Errores: {form.errors}")
            print(f"DEBUG: Errores por campo: {dict(form.errors)}")
            for field, errors in form.errors.items():
                print(f"DEBUG: Campo '{field}': {errors}")
    else:
        form = AIChatMessageForm()
    
    context = {
        'session': session,
        'messages_list': messages_list,
        'form': form,
        'config': config,
    }
    
    return render(request, 'tickets/ai_chat_session.html', context)


@login_required
def ai_chat_delete_session_view(request, session_id):
    """Vista para eliminar una sesión de chat"""
    session = get_object_or_404(AIChatSession, id=session_id, user=request.user)
    
    if request.method == 'POST':
        session.is_active = False
        session.save()
        messages.success(request, f'Conversación "{session.title}" eliminada.')
        return redirect('ai_chat_list')
    
    context = {
        'session': session,
    }
    
    return render(request, 'tickets/ai_chat_delete_session.html', context)


@login_required
def ai_chat_debug_view(request, session_id):
    """Vista de debug para chat IA"""
    config = SystemConfiguration.get_config()
    
    # Obtener la sesión
    session = get_object_or_404(AIChatSession, id=session_id, user=request.user, is_active=True)
    
    # Obtener mensajes de la sesión
    messages_list = session.messages.all()
    
    # Formulario para nuevo mensaje
    if request.method == 'POST':
        print(f"DEBUG: POST recibido para sesión {session_id}")
        print(f"DEBUG: Datos POST: {request.POST}")
        
        form = AIChatMessageForm(request.POST)
        if form.is_valid():
            user_message = form.cleaned_data['message']
            print(f"DEBUG: Mensaje del usuario: {user_message}")
            
            # Guardar mensaje del usuario
            user_msg = AIChatMessage.objects.create(
                session=session,
                role='user',
                content=user_message
            )
            print(f"DEBUG: Mensaje del usuario guardado con ID: {user_msg.id}")
            
            # Llamar a la API de OpenAI
            try:
                print("DEBUG: Llamando a OpenAI API...")
                ai_response = call_openai_api(session, user_message)
                print(f"DEBUG: Respuesta de OpenAI recibida: {ai_response['content'][:50]}...")
                
                # Guardar respuesta de la IA
                ai_msg = AIChatMessage.objects.create(
                    session=session,
                    role='assistant',
                    content=ai_response['content'],
                    tokens_used=ai_response.get('tokens_used', 0)
                )
                print(f"DEBUG: Respuesta de IA guardada con ID: {ai_msg.id}")
                
                messages.success(request, 'Mensaje enviado correctamente.')
                
            except Exception as e:
                print(f"DEBUG: Error en OpenAI API: {str(e)}")
                messages.error(request, f'Error al comunicarse con la IA: {str(e)}')
            
            return redirect('ai_chat_debug', session_id=session.id)
        else:
            print(f"DEBUG: Formulario no válido: {form.errors}")
    else:
        form = AIChatMessageForm()
    
    context = {
        'session': session,
        'messages_list': messages_list,
        'form': form,
        'page_title': f'Debug Chat IA - {session.title}',
    }
    
    return render(request, 'tickets/ai_chat_debug.html', context)


@login_required
def ai_chat_simple_view(request, session_id):
    """Vista simple del chat IA para debugging"""
    config = SystemConfiguration.get_config()
    
    # Verificar configuración
    if not config.ai_chat_enabled or not config.openai_api_key:
        messages.warning(request, 'El chat con IA no está disponible.')
        return redirect('dashboard')
    
    # Obtener sesión
    session = get_object_or_404(AIChatSession, id=session_id, user=request.user, is_active=True)
    messages_list = session.messages.all()
    
    # Procesar formulario
    if request.method == 'POST':
        print(f"=== POST SIMPLE RECIBIDO ===")
        print(f"request.POST: {dict(request.POST)}")
        print(f"message value: '{request.POST.get('message', 'NO_ENCONTRADO')}'")
        
        message_content = request.POST.get('message', '').strip()
        
        if len(message_content) >= 5:
            try:
                # Guardar mensaje del usuario
                user_msg = AIChatMessage.objects.create(
                    session=session,
                    role='user',
                    content=message_content
                )
                print(f"Usuario mensaje guardado: {user_msg.id}")
                
                # Llamar a OpenAI
                ai_response = call_openai_api(session, message_content)
                
                # Guardar respuesta IA
                ai_msg = AIChatMessage.objects.create(
                    session=session,
                    role='assistant',
                    content=ai_response['content'],
                    tokens_used=ai_response.get('tokens_used', 0)
                )
                print(f"IA mensaje guardado: {ai_msg.id}")
                
                messages.success(request, 'Mensaje enviado correctamente.')
                return redirect('ai_chat_simple', session_id=session.id)
                
            except Exception as e:
                print(f"Error: {e}")
                messages.error(request, f'Error: {str(e)}')
        else:
            messages.error(request, 'El mensaje debe tener al menos 5 caracteres.')
    
    # Crear formulario vacío para los errores
    form = AIChatMessageForm()
    
    context = {
        'session': session,
        'messages_list': messages_list,
        'form': form,
        'page_title': f'Chat Simple - {session.title}',
    }
    
    return render(request, 'tickets/ai_chat_simple.html', context)


@login_required
def ai_chat_ajax_send_message(request, session_id):
    """Vista AJAX para enviar mensajes al chat IA"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        config = SystemConfiguration.get_config()
        
        # Verificar configuración
        if not config.ai_chat_enabled or not config.openai_api_key:
            return JsonResponse({'error': 'Chat IA no disponible'}, status=400)
        
        # Obtener sesión
        try:
            session = AIChatSession.objects.get(id=session_id, user=request.user, is_active=True)
        except AIChatSession.DoesNotExist:
            return JsonResponse({'error': 'Sesión no encontrada'}, status=404)
        
        # Obtener mensaje
        message_content = request.POST.get('message', '').strip()
        
        if len(message_content) < 5:
            return JsonResponse({'error': 'El mensaje debe tener al menos 5 caracteres'}, status=400)
        
        # Guardar mensaje del usuario
        user_msg = AIChatMessage.objects.create(
            session=session,
            role='user',
            content=message_content
        )
        
        # Llamar a OpenAI
        ai_response = call_openai_api(session, message_content)
        
        # Guardar respuesta IA
        ai_msg = AIChatMessage.objects.create(
            session=session,
            role='assistant',
            content=ai_response['content'],
            tokens_used=ai_response.get('tokens_used', 0)
        )
        
        return JsonResponse({
            'success': True,
            'user_message': {
                'id': user_msg.id,
                'content': user_msg.content,
                'created_at': user_msg.created_at.strftime('%H:%M')
            },
            'ai_message': {
                'id': ai_msg.id,
                'content': ai_msg.content,
                'created_at': ai_msg.created_at.strftime('%H:%M'),
                'tokens_used': ai_msg.tokens_used
            }
        })
        
    except Exception as e:
        import traceback
        print(f"Error completo: {traceback.format_exc()}")
        return JsonResponse({'error': f'Error al procesar mensaje: {str(e)}'}, status=500)


@login_required
def ai_chat_live_view(request, session_id):
    """Vista mejorada del chat IA con AJAX y UX mejorada"""
    config = SystemConfiguration.get_config()
    
    # Verificar configuración
    if not config.ai_chat_enabled:
        messages.warning(request, 'El chat con IA no está habilitado en el sistema.')
        return redirect('dashboard')
    
    if not config.openai_api_key:
        messages.warning(request, 'El chat con IA no está configurado. Contacta al administrador.')
        return redirect('dashboard')
    
    # Obtener sesión
    session = get_object_or_404(AIChatSession, id=session_id, user=request.user, is_active=True)
    
    # Obtener mensajes
    messages_list = session.messages.all()
    
    context = {
        'session': session,
        'messages_list': messages_list,
        'page_title': f'{session.title} - Chat IA',
    }
    
    return render(request, 'tickets/ai_chat_live.html', context)


@login_required
def ai_chat_modern_view(request, session_id):
    """Vista del chat IA con diseño moderno (Telegram/Discord style)"""
    config = SystemConfiguration.get_config()
    
    # Verificar configuración
    if not config.ai_chat_enabled:
        messages.warning(request, 'El chat con IA no está habilitado en el sistema.')
        return redirect('dashboard')
    
    if not config.openai_api_key:
        messages.warning(request, 'El chat con IA no está configurado. Contacta al administrador.')
        return redirect('dashboard')
    
    # Obtener sesión
    session = get_object_or_404(AIChatSession, id=session_id, user=request.user, is_active=True)
    
    # Obtener mensajes
    messages_list = session.messages.all()
    
    context = {
        'session': session,
        'messages': messages_list,  # Cambio de nombre para el template moderno
        'page_title': f'{session.title} - Chat IA',
    }
    
    return render(request, 'tickets/ai_chat_modern.html', context)


# Helper function for AI analysis
def call_openai_api(session, message_content):
    """
    Función auxiliar para llamar a la API de OpenAI
    """
    config = SystemConfiguration.get_config()
    
    if not config.openai_api_key:
        raise Exception('API key de OpenAI no configurada')
    
    from openai import OpenAI
    client = OpenAI(api_key=config.openai_api_key)
    
    # Obtener historial de mensajes para contexto
    previous_messages = session.messages.order_by('created_at')[:10]  # Últimos 10 mensajes
    messages = [{"role": "system", "content": "Eres un asistente IA útil y conversacional."}]
    
    # Agregar mensajes previos para contexto
    for msg in previous_messages:
        messages.append({
            "role": msg.role,
            "content": msg.content
        })
    
    # Agregar mensaje actual
    messages.append({
        "role": "user",
        "content": message_content
    })
    
    response = client.chat.completions.create(
        model=config.openai_model or 'gpt-4o-mini',
        messages=messages,
        max_tokens=2000,
        temperature=0.7
    )
    
    return {
        'content': response.choices[0].message.content,
        'tokens_used': response.usage.total_tokens
    }


@login_required
def improve_ticket_with_ai(request, ticket_id):
    """Vista AJAX para mejorar el título y descripción de un ticket usando IA"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        # Verificar permisos del ticket
        if is_agent(request.user):
            ticket = get_object_or_404(Ticket, pk=ticket_id)
        else:
            # Los usuarios pueden solo editar sus propios tickets o tickets de su empresa/proyectos
            user_projects = request.user.assigned_projects.all()
            user_company = None
            
            try:
                user_company = request.user.profile.company
            except:
                pass
            
            query_conditions = Q(created_by=request.user)
            if user_projects.exists():
                query_conditions |= Q(project__in=user_projects)
            if user_company:
                query_conditions |= Q(company=user_company)
            
            ticket = get_object_or_404(Ticket, pk=ticket_id)
            if not Ticket.objects.filter(pk=ticket_id).filter(query_conditions).exists():
                return JsonResponse({'error': 'No tienes permisos para mejorar este ticket'}, status=403)
        
        # Verificar configuración de OpenAI
        config = SystemConfiguration.get_config()
        if not config.openai_api_key:
            return JsonResponse({'error': 'API key de OpenAI no configurada'}, status=500)
        
        # Obtener tipo de mejora solicitada
        improvement_type = request.POST.get('type', 'both')  # 'title', 'description', 'both'
        
        # Preparar el prompt según el tipo de mejora
        if improvement_type == 'title':
            prompt = f"""
            Mejora el siguiente título de ticket de soporte técnico para que sea más claro, específico y profesional:

            Título actual: "{ticket.title}"
            Descripción del problema: "{ticket.description}"
            
            Proporciona ÚNICAMENTE un título mejorado, sin explicaciones adicionales.
            El título debe ser:
            - Claro y específico
            - Profesional pero comprensible
            - Máximo 100 caracteres
            - Debe reflejar exactamente el problema descrito
            """
        elif improvement_type == 'description':
            prompt = f"""
            Mejora la siguiente descripción de ticket de soporte técnico para que sea más clara, detallada y estructurada:

            Título: "{ticket.title}"
            Descripción actual: "{ticket.description}"
            
            Proporciona ÚNICAMENTE una descripción mejorada, sin explicaciones adicionales.
            La descripción debe ser:
            - Clara y bien estructurada
            - Incluir pasos para reproducir si es relevante
            - Mencionar el impacto del problema
            - Ser específica y detallada
            - Mantener el contenido original pero mejor organizado
            """
        else:  # both
            prompt = f"""
            Mejora el siguiente ticket de soporte técnico para que el título y descripción sean más claros, específicos y profesionales:

            Título actual: "{ticket.title}"
            Descripción actual: "{ticket.description}"
            
            Responde ÚNICAMENTE con el siguiente formato JSON sin texto adicional:
            {{
                "title": "título mejorado aquí",
                "description": "descripción mejorada aquí"
            }}
            
            Criterios:
            - Título: Claro, específico, profesional, máximo 100 caracteres
            - Descripción: Clara, estructurada, detallada, bien organizada
            - Mantener el contenido original pero mejorado
            """
        
        # Llamar a OpenAI
        try:
            from openai import OpenAI
            client = OpenAI(api_key=config.openai_api_key)
        except Exception as e:
            return JsonResponse({'error': f'Error al inicializar cliente OpenAI: {str(e)}'}, status=500)
        
        try:
            response = client.chat.completions.create(
                model=config.openai_model or 'gpt-4o-mini',
                messages=[
                    {"role": "system", "content": "Eres un experto en soporte técnico que mejora la comunicación de tickets para hacerlos más claros y profesionales."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=1000,
                temperature=0.3
            )
            
            ai_response = response.choices[0].message.content.strip()
        except Exception as e:
            return JsonResponse({'error': f'Error al llamar a OpenAI: {str(e)}'}, status=500)
        
        # Procesar respuesta según el tipo
        if improvement_type == 'both':
            try:
                import json
                # Limpiar respuesta si tiene marcadores de código
                if ai_response.startswith('```json'):
                    ai_response = ai_response.replace('```json', '').replace('```', '').strip()
                elif ai_response.startswith('```'):
                    ai_response = ai_response.replace('```', '').strip()
                
                result = json.loads(ai_response)
                return JsonResponse({
                    'success': True,
                    'title': result.get('title', ''),
                    'description': result.get('description', ''),
                    'tokens_used': response.usage.total_tokens
                })
            except json.JSONDecodeError:
                return JsonResponse({'error': 'Error al procesar la respuesta de IA'}, status=500)
        else:
            return JsonResponse({
                'success': True,
                improvement_type: ai_response,
                'tokens_used': response.usage.total_tokens
            })
            
    except Exception as e:
        return JsonResponse({'error': f'Error al mejorar ticket: {str(e)}'}, status=500)


@login_required
def improve_ticket_text_with_ai(request):
    """Vista AJAX para mejorar texto de ticket durante la creación (sin ticket existente)"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        # Verificar configuración de OpenAI
        config = SystemConfiguration.get_config()
        if not config.openai_api_key:
            return JsonResponse({'error': 'API key de OpenAI no configurada'}, status=500)
        
        # Obtener datos del request
        improvement_type = request.POST.get('type', 'both')
        current_text = request.POST.get('text', '')
        current_title = request.POST.get('title', '')
        current_description = request.POST.get('description', '')
        
        # Preparar el prompt según el tipo de mejora
        if improvement_type == 'title':
            if not current_text:
                return JsonResponse({'error': 'No se proporcionó texto para mejorar'}, status=400)
            
            prompt = f"""
            Mejora el siguiente título de ticket de soporte técnico para que sea más claro, específico y profesional:

            Título actual: "{current_text}"
            
            Proporciona ÚNICAMENTE un título mejorado, sin explicaciones adicionales.
            El título debe ser:
            - Claro y específico
            - Profesional pero comprensible
            - Máximo 100 caracteres
            - Debe reflejar exactamente el problema
            """
            
        elif improvement_type == 'description':
            if not current_text:
                return JsonResponse({'error': 'No se proporcionó texto para mejorar'}, status=400)
            
            prompt = f"""
            Mejora la siguiente descripción de ticket de soporte técnico para que sea más clara, detallada y estructurada:

            Descripción actual: "{current_text}"
            
            Proporciona ÚNICAMENTE una descripción mejorada, sin explicaciones adicionales.
            La descripción debe ser:
            - Clara y bien estructurada
            - Incluir pasos para reproducir si es relevante
            - Mencionar el impacto del problema
            - Ser específica y detallada
            - Mantener el contenido original pero mejor organizado
            """
            
        else:  # both
            if not current_title or not current_description:
                return JsonResponse({'error': 'Se requiere título y descripción para mejorar ambos'}, status=400)
            
            prompt = f"""
            Mejora el siguiente ticket de soporte técnico para que el título y descripción sean más claros, específicos y profesionales:

            Título actual: "{current_title}"
            Descripción actual: "{current_description}"
            
            Responde ÚNICAMENTE con el siguiente formato JSON sin texto adicional:
            {{
                "title": "título mejorado aquí",
                "description": "descripción mejorada aquí"
            }}
            
            Criterios:
            - Título: Claro, específico, profesional, máximo 100 caracteres
            - Descripción: Clara, estructurada, detallada, bien organizada
            - Mantener el contenido original pero mejorado
            """
        
        # Llamar a OpenAI
        try:
            from openai import OpenAI
            client = OpenAI(api_key=config.openai_api_key)
        except Exception as e:
            return JsonResponse({'error': f'Error al inicializar cliente OpenAI: {str(e)}'}, status=500)
        
        try:
            response = client.chat.completions.create(
                model=config.openai_model or 'gpt-4o-mini',
                messages=[
                    {"role": "system", "content": "Eres un experto en soporte técnico que mejora la comunicación de tickets para hacerlos más claros y profesionales."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=1000,
                temperature=0.3
            )
            
            ai_response = response.choices[0].message.content.strip()
        except Exception as e:
            return JsonResponse({'error': f'Error al llamar a OpenAI: {str(e)}'}, status=500)
        
        # Procesar respuesta según el tipo
        if improvement_type == 'both':
            try:
                import json
                # Limpiar respuesta si tiene marcadores de código
                if ai_response.startswith('```json'):
                    ai_response = ai_response.replace('```json', '').replace('```', '').strip()
                elif ai_response.startswith('```'):
                    ai_response = ai_response.replace('```', '').strip()
                
                result = json.loads(ai_response)
                return JsonResponse({
                    'success': True,
                    'improved_title': result.get('title', ''),
                    'improved_description': result.get('description', ''),
                    'tokens_used': response.usage.total_tokens
                })
            except json.JSONDecodeError:
                return JsonResponse({'error': 'Error al procesar la respuesta de IA'}, status=500)
        else:
            return JsonResponse({
                'success': True,
                'improved_text': ai_response,
                'tokens_used': response.usage.total_tokens
            })
            
    except Exception as e:
        return JsonResponse({'error': f'Error al mejorar texto: {str(e)}'}, status=500)


@login_required
def improve_alcance_text_with_ai(request):
    """Vista AJAX para mejorar texto de alcance usando IA"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        # Verificar configuración de OpenAI
        config = SystemConfiguration.get_config()
        if not config.openai_api_key:
            return JsonResponse({'error': 'API key de OpenAI no configurada'}, status=500)
        
        # Obtener datos del request
        improvement_type = request.POST.get('type', 'all')
        current_text = request.POST.get('text', '')
        current_title = request.POST.get('title', '')
        current_category = request.POST.get('category', '')
        current_description = request.POST.get('description', '')
        
        # Preparar el prompt según el tipo de mejora
        if improvement_type == 'title':
            if not current_text:
                return JsonResponse({'error': 'No se proporcionó texto para mejorar'}, status=400)
            
            prompt = f"""
            Mejora el siguiente título de alcance de servicios para que sea más claro, profesional y atractivo:

            Título actual: "{current_text}"
            
            Proporciona ÚNICAMENTE un título mejorado, sin explicaciones adicionales.
            El título debe ser:
            - Claro y específico
            - Profesional y atractivo
            - Máximo 100 caracteres
            - Que transmita valor y profesionalismo
            """
            
        elif improvement_type == 'category':
            if not current_text:
                return JsonResponse({'error': 'No se proporcionó texto para mejorar'}, status=400)
            
            prompt = f"""
            Mejora la siguiente categoría de alcance de servicios para que sea más clara y profesional:

            Categoría actual: "{current_text}"
            
            Proporciona ÚNICAMENTE una categoría mejorada, sin explicaciones adicionales.
            La categoría debe ser:
            - Clara y concisa
            - Profesional
            - Máximo 50 caracteres
            - Usar terminología estándar de la industria
            """
            
        elif improvement_type == 'description':
            if not current_text:
                return JsonResponse({'error': 'No se proporcionó texto para mejorar'}, status=400)
            
            prompt = f"""
            Mejora la siguiente descripción de alcance de servicios para que sea más clara, detallada y profesional:

            Descripción actual: "{current_text}"
            
            Proporciona ÚNICAMENTE una descripción mejorada, sin explicaciones adicionales.
            La descripción debe ser:
            - Clara y bien estructurada
            - Profesional y persuasiva
            - Detallada pero concisa
            - Destacar beneficios y valor
            - Usar viñetas o párrafos cortos si es apropiado
            """
            
        else:  # all
            if not current_title or not current_category or not current_description:
                return JsonResponse({'error': 'Se requiere título, categoría y descripción para mejorar todo'}, status=400)
            
            prompt = f"""
            Mejora el siguiente alcance de servicios para que el título, categoría y descripción sean más claros, profesionales y atractivos:

            Título actual: "{current_title}"
            Categoría actual: "{current_category}"
            Descripción actual: "{current_description}"
            
            Responde ÚNICAMENTE con el siguiente formato JSON sin texto adicional:
            {{
                "title": "título mejorado aquí",
                "category": "categoría mejorada aquí",
                "description": "descripción mejorada aquí"
            }}
            
            Criterios:
            - Título: Claro, específico, profesional, máximo 100 caracteres, atractivo
            - Categoría: Clara, concisa, profesional, máximo 50 caracteres, terminología estándar
            - Descripción: Clara, estructurada, detallada, profesional, persuasiva, destacar valor
            - Mantener el contenido original pero mejorado significativamente
            """
        
        # Llamar a OpenAI
        try:
            from openai import OpenAI
            client = OpenAI(api_key=config.openai_api_key)
        except Exception as e:
            return JsonResponse({'error': f'Error al inicializar cliente OpenAI: {str(e)}'}, status=500)
        
        try:
            response = client.chat.completions.create(
                model=config.openai_model or 'gpt-4o-mini',
                messages=[
                    {"role": "system", "content": "Eres un experto en marketing y comunicación de servicios profesionales que mejora textos para hacerlos más claros, profesionales y persuasivos."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=1000,
                temperature=0.3
            )
            
            ai_response = response.choices[0].message.content.strip()
        except Exception as e:
            return JsonResponse({'error': f'Error al llamar a OpenAI: {str(e)}'}, status=500)
        
        # Procesar respuesta según el tipo
        if improvement_type == 'all':
            try:
                import json
                # Limpiar respuesta si tiene marcadores de código
                if ai_response.startswith('```json'):
                    ai_response = ai_response.replace('```json', '').replace('```', '').strip()
                elif ai_response.startswith('```'):
                    ai_response = ai_response.replace('```', '').strip()
                
                result = json.loads(ai_response)
                return JsonResponse({
                    'success': True,
                    'improved_title': result.get('title', ''),
                    'improved_category': result.get('category', ''),
                    'improved_description': result.get('description', ''),
                    'tokens_used': response.usage.total_tokens
                })
            except json.JSONDecodeError:
                return JsonResponse({'error': 'Error al procesar la respuesta de IA'}, status=500)
        else:
            return JsonResponse({
                'success': True,
                'improved_text': ai_response,
                'tokens_used': response.usage.total_tokens
            })
            
    except Exception as e:
        return JsonResponse({'error': f'Error al mejorar texto: {str(e)}'}, status=500)


@login_required
@user_passes_test(is_agent, login_url='/')
def search_company_info_with_ai(request, company_id):
    """Vista AJAX para buscar información de una empresa en la web usando IA"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        company = get_object_or_404(Company, pk=company_id)
        
        # Verificar configuración de OpenAI
        config = SystemConfiguration.get_config()
        if not config.openai_api_key:
            return JsonResponse({'error': 'API key de OpenAI no configurada'}, status=500)
        
        # Obtener nombre de la empresa del request o usar el actual
        company_name = request.POST.get('company_name', company.name).strip()
        
        if not company_name:
            return JsonResponse({'error': 'Nombre de empresa requerido'}, status=400)
        
        # Prompt para buscar información de la empresa
        prompt = f"""
        Busca información detallada sobre la empresa "{company_name}". 
        
        Proporciona la información en el siguiente formato JSON exacto (sin texto adicional):
        {{
            "name": "nombre oficial completo de la empresa",
            "website": "sitio web principal (con https://)",
            "email": "email principal de contacto",
            "phone": "teléfono principal",
            "address": "dirección completa de la sede principal",
            "description": "descripción detallada de la empresa, sus servicios y actividades",
            "industry": "sector o industria principal",
            "founded": "año de fundación si está disponible",
            "employees": "número aproximado de empleados si está disponible",
            "social_media": {{
                "linkedin": "URL de LinkedIn",
                "twitter": "URL de Twitter",
                "facebook": "URL de Facebook"
            }},
            "additional_info": "información adicional relevante como premios, certificaciones, etc."
        }}
        
        IMPORTANTE:
        - Si no encuentras información específica, usa "No disponible" para ese campo
        - Asegúrate de que el website tenga formato completo (https://)
        - La descripción debe ser informativa y profesional
        - Incluye solo información verificable y actualizada
        """
        
        # Llamar a OpenAI
        from openai import OpenAI
        client = OpenAI(api_key=config.openai_api_key)
        
        response = client.chat.completions.create(
            model=config.openai_model or 'gpt-4o-mini',
            messages=[
                {"role": "system", "content": "Eres un experto investigador de empresas que busca información precisa y actualizada sobre compañías usando fuentes públicas disponibles. Respondes únicamente con JSON válido."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=1500,
            temperature=0.3
        )
        
        ai_response = response.choices[0].message.content.strip()
        
        # Limpiar respuesta si tiene marcadores de código
        if ai_response.startswith('```json'):
            ai_response = ai_response.replace('```json', '').replace('```', '').strip()
        elif ai_response.startswith('```'):
            ai_response = ai_response.replace('```', '').strip()
        
        try:
            import json
            result = json.loads(ai_response)
            
            # Validar que los campos requeridos estén presentes
            required_fields = ['name', 'website', 'email', 'phone', 'address', 'description']
            for field in required_fields:
                if field not in result:
                    result[field] = 'No disponible'
            
            return JsonResponse({
                'success': True,
                'data': result,
                'tokens_used': response.usage.total_tokens
            })
            
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Error al procesar la respuesta de IA'}, status=500)
            
    except Exception as e:
        return JsonResponse({'error': f'Error al buscar información: {str(e)}'}, status=500)


@login_required
@user_passes_test(is_agent, login_url='/')
def search_company_info_general(request):
    """Vista AJAX para buscar información de una empresa sin requerir ID específico"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        # Verificar configuración de OpenAI
        config = SystemConfiguration.get_config()
        if not config.openai_api_key:
            return JsonResponse({'error': 'API key de OpenAI no configurada'}, status=500)
        
        # Obtener nombre de la empresa del request
        company_name = request.POST.get('company_name', '').strip()
        
        if not company_name:
            return JsonResponse({'error': 'Nombre de empresa requerido'}, status=400)
        
        # Prompt para buscar información de la empresa
        prompt = f"""
        Busca información detallada sobre la empresa "{company_name}". 
        
        Proporciona la información en el siguiente formato JSON exacto (sin texto adicional):
        {{
            "name": "nombre oficial completo de la empresa",
            "website": "sitio web principal (con https://)",
            "email": "email principal de contacto",
            "phone": "teléfono principal",
            "address": "dirección completa de la sede principal",
            "description": "descripción detallada de la empresa, sus servicios y actividades",
            "industry": "sector o industria principal",
            "founded": "año de fundación si está disponible",
            "employees": "número aproximado de empleados si está disponible",
            "social_media": {{
                "linkedin": "URL de LinkedIn",
                "twitter": "URL de Twitter",
                "facebook": "URL de Facebook"
            }},
            "additional_info": "información adicional relevante como premios, certificaciones, etc."
        }}
        
        IMPORTANTE:
        - Si no encuentras información específica, usa "No disponible" para ese campo
        - Asegúrate de que el website tenga formato completo (https://)
        - La descripción debe ser informativa y profesional
        - Incluye solo información verificable y actualizada
        """
        
        # Llamar a OpenAI
        from openai import OpenAI
        client = OpenAI(api_key=config.openai_api_key)
        
        response = client.chat.completions.create(
            model=config.openai_model or 'gpt-4o-mini',
            messages=[
                {"role": "system", "content": "Eres un experto investigador de empresas que busca información precisa y actualizada sobre compañías usando fuentes públicas disponibles. Respondes únicamente con JSON válido."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=1500,
            temperature=0.3
        )
        
        ai_response = response.choices[0].message.content.strip()
        
        # Limpiar respuesta si tiene marcadores de código
        if ai_response.startswith('```json'):
            ai_response = ai_response.replace('```json', '').replace('```', '').strip()
        elif ai_response.startswith('```'):
            ai_response = ai_response.replace('```', '').strip()
        
        try:
            import json
            result = json.loads(ai_response)
            
            # Validar que los campos requeridos estén presentes
            required_fields = ['name', 'website', 'email', 'phone', 'address', 'description']
            for field in required_fields:
                if field not in result:
                    result[field] = 'No disponible'
            
            return JsonResponse({
                'success': True,
                'data': result,
                'tokens_used': response.usage.total_tokens
            })
            
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Error al procesar la respuesta de IA'}, status=500)
            
    except Exception as e:
        return JsonResponse({'error': f'Error al buscar información: {str(e)}'}, status=500)


@login_required
@user_passes_test(is_agent, login_url='/')
def enhance_contact_with_ai(request, contact_id):
    """Vista AJAX para mejorar información de un contacto usando IA"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        contact = get_object_or_404(Contact, pk=contact_id)
        
        # Verificar configuración de OpenAI
        config = SystemConfiguration.get_config()
        if not config.openai_api_key:
            return JsonResponse({'error': 'API key de OpenAI no configurada'}, status=500)
        
        # Obtener datos actuales del contacto del request
        import json
        contact_data = json.loads(request.body)
        
        # Construir información existente
        existing_info = []
        if contact_data.get('name'):
            existing_info.append(f"Nombre: {contact_data['name']}")
        if contact_data.get('email'):
            existing_info.append(f"Email: {contact_data['email']}")
        if contact_data.get('phone'):
            existing_info.append(f"Teléfono: {contact_data['phone']}")
        if contact_data.get('position'):
            existing_info.append(f"Posición: {contact_data['position']}")
        if contact_data.get('company'):
            existing_info.append(f"Empresa: {contact_data['company']}")
        if contact_data.get('notes'):
            existing_info.append(f"Notas actuales: {contact_data['notes']}")
        
        if not existing_info:
            return JsonResponse({'error': 'No hay información suficiente para mejorar'}, status=400)
        
        existing_info_text = "\n".join(existing_info)
        
        # Prompt para mejorar información del contacto
        prompt = f"""
        Tienes la siguiente información parcial de un contacto profesional:
        
        {existing_info_text}
        
        Basándote en esta información, busca y proporciona datos adicionales que podrían ser útiles para completar el perfil del contacto. 
        
        Proporciona la respuesta en el siguiente formato JSON exacto (sin texto adicional):
        {{
            "full_name": "nombre completo si es diferente o más completo que el actual",
            "position": "título o posición profesional más específica o completa",
            "professional_title": "título profesional o especialización",
            "email": "email profesional si no está disponible",
            "phone": "teléfono profesional si no está disponible",
            "linkedin": "URL del perfil de LinkedIn si está disponible",
            "company_info": {{
                "name": "nombre completo y correcto de la empresa",
                "industry": "industria o sector de la empresa", 
                "size": "tamaño aproximado de la empresa",
                "location": "ubicación principal de la empresa"
            }},
            "additional_info": "información adicional relevante sobre el contacto, su rol, experiencia, etc.",
            "suggested_notes": "sugerencias de notas profesionales para agregar al contacto basadas en la información encontrada"
        }}
        
        IMPORTANTE:
        - Si no encuentras información específica o no puedes mejorar un campo, usa "No disponible"
        - Proporciona solo información que sea profesionalmente relevante
        - Las sugerencias de notas deben ser útiles para seguimiento comercial o profesional
        - Usa fuentes públicas y profesionales para la información
        - Sé preciso y evita especulaciones
        """
        
        # Llamar a OpenAI
        from openai import OpenAI
        client = OpenAI(api_key=config.openai_api_key)
        
        response = client.chat.completions.create(
            model=config.openai_model or 'gpt-4o-mini',
            messages=[
                {"role": "system", "content": "Eres un experto asistente de CRM que ayuda a completar información de contactos profesionales usando fuentes públicas y conocimiento general del mundo empresarial. Respondes únicamente con JSON válido."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=1200,
            temperature=0.3
        )
        
        ai_response = response.choices[0].message.content.strip()
        
        # Limpiar respuesta si tiene marcadores de código
        if ai_response.startswith('```json'):
            ai_response = ai_response.replace('```json', '').replace('```', '').strip()
        elif ai_response.startswith('```'):
            ai_response = ai_response.replace('```', '').strip()
        
        try:
            result = json.loads(ai_response)
            
            # Validar que los campos requeridos estén presentes
            required_fields = ['full_name', 'position', 'email', 'phone', 'additional_info', 'suggested_notes']
            for field in required_fields:
                if field not in result:
                    result[field] = 'No disponible'
            
            return JsonResponse({
                'success': True,
                'data': result,
                'tokens_used': response.usage.total_tokens
            })
            
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Error al procesar la respuesta de IA'}, status=500)
            
    except Exception as e:
        return JsonResponse({'error': f'Error al mejorar contacto: {str(e)}'}, status=500)


# =============================================
# VISTAS DE CONCEPTOS
# =============================================

@login_required
@user_passes_test(is_agent)
def concept_list_view(request):
    """Vista para listar todos los conceptos"""
    concepts = Concept.objects.all().order_by('order', 'term')
    
    context = {
        'concepts': concepts,
        'title': 'Gestión de Conceptos'
    }
    return render(request, 'tickets/concept_list.html', context)


@login_required
@user_passes_test(is_agent)
def concept_create_view(request):
    """Vista para crear un nuevo concepto"""
    if request.method == 'POST':
        form = ConceptForm(request.POST)
        if form.is_valid():
            concept = form.save(commit=False)
            concept.created_by = request.user
            concept.save()
            messages.success(request, f'Concepto "{concept.term}" creado exitosamente.')
            return redirect('concept_list')
    else:
        form = ConceptForm()
    
    context = {
        'form': form,
        'title': 'Crear Concepto'
    }
    return render(request, 'tickets/concept_form.html', context)


@login_required
@user_passes_test(is_agent)
def concept_edit_view(request, pk):
    """Vista para editar un concepto existente"""
    concept = get_object_or_404(Concept, pk=pk)
    
    if request.method == 'POST':
        form = ConceptForm(request.POST, instance=concept)
        if form.is_valid():
            form.save()
            messages.success(request, f'Concepto "{concept.term}" actualizado exitosamente.')
            return redirect('concept_list')
    else:
        form = ConceptForm(instance=concept)
    
    context = {
        'form': form,
        'concept': concept,
        'title': 'Editar Concepto'
    }
    return render(request, 'tickets/concept_form.html', context)


@login_required
@user_passes_test(is_agent)
def concept_delete_view(request, pk):
    """Vista para eliminar un concepto"""
    concept = get_object_or_404(Concept, pk=pk)
    
    if request.method == 'POST':
        concept_term = concept.term
        concept.delete()
        messages.success(request, f'Concepto "{concept_term}" eliminado exitosamente.')
        return redirect('concept_list')
    
    context = {
        'concept': concept,
        'title': 'Eliminar Concepto'
    }
    return render(request, 'tickets/concept_delete.html', context)


@login_required
def concept_detail_view(request, pk):
    """Vista para ver los detalles de un concepto"""
    concept = get_object_or_404(Concept, pk=pk)
    
    context = {
        'concept': concept,
        'title': f'Concepto: {concept.term}'
    }
    return render(request, 'tickets/concept_detail.html', context)


def public_concepts_view(request):
    """Vista pública para mostrar el glosario de conceptos"""
    concepts = Concept.objects.filter(is_active=True).order_by('order', 'term')
    
    context = {
        'concepts': concepts,
        'title': 'Glosario de Conceptos'
    }
    return render(request, 'tickets/public_concepts.html', context)


# =====================================================
# FUNCIONALIDADES DE IA PARA BLOG
# =====================================================

@login_required
@require_http_methods(["POST"])
def blog_ai_improve_content(request, pk):
    """Mejorar contenido del artículo con IA"""
    try:
        from .ai_utils import AIContentOptimizer
        from .utils import is_agent
        
        post = get_object_or_404(BlogPost, pk=pk)
        
        # Verificar permisos
        if not is_agent(request.user):
            return JsonResponse({'error': 'Permisos insuficientes'}, status=403)
        
        optimizer = AIContentOptimizer()
        result = optimizer.improve_content(post.title, post.content)
        
        return JsonResponse(result)
    except Exception as e:
        return JsonResponse({'error': f'Error interno: {str(e)}'}, status=500)


@login_required
@require_http_methods(["POST"])
def blog_ai_generate_meta_description(request, pk):
    """Generar meta descripción con IA"""
    try:
        from .ai_utils import AIContentOptimizer
        from .utils import is_agent
        
        post = get_object_or_404(BlogPost, pk=pk)
        
        # Verificar permisos
        if not is_agent(request.user):
            return JsonResponse({'error': 'Permisos insuficientes'}, status=403)
        
        optimizer = AIContentOptimizer()
        result = optimizer.generate_meta_description(post.title, post.content)
        
        return JsonResponse(result)
    except Exception as e:
        return JsonResponse({'error': f'Error interno: {str(e)}'}, status=500)


@login_required
@require_http_methods(["POST"])
def blog_ai_suggest_titles(request, pk):
    """Sugerir títulos alternativos con IA"""
    try:
        from .ai_utils import AIContentOptimizer
        from .utils import is_agent
        
        post = get_object_or_404(BlogPost, pk=pk)
        
        # Verificar permisos
        if not is_agent(request.user):
            return JsonResponse({'error': 'Permisos insuficientes'}, status=403)
        
        optimizer = AIContentOptimizer()
        result = optimizer.suggest_titles(post.content)
        
        return JsonResponse(result)
    except Exception as e:
        return JsonResponse({'error': f'Error interno: {str(e)}'}, status=500)


@login_required
@require_http_methods(["POST"])
def blog_ai_generate_tags(request, pk):
    """Generar etiquetas con IA"""
    try:
        from .ai_utils import AIContentOptimizer
        from .utils import is_agent
        
        post = get_object_or_404(BlogPost, pk=pk)
        
        # Verificar permisos
        if not is_agent(request.user):
            return JsonResponse({'error': 'Permisos insuficientes'}, status=403)
        
        optimizer = AIContentOptimizer()
        result = optimizer.generate_tags(post.title, post.content)
        
        return JsonResponse(result)
    except Exception as e:
        return JsonResponse({'error': f'Error interno: {str(e)}'}, status=500)


@login_required
@require_http_methods(["POST"])
def blog_ai_analyze_readability(request, pk):
    """Analizar legibilidad del contenido con IA"""
    try:
        from .ai_utils import AIContentOptimizer
        from .utils import is_agent
        
        post = get_object_or_404(BlogPost, pk=pk)
        
        # Verificar permisos
        if not is_agent(request.user):
            return JsonResponse({'error': 'Permisos insuficientes'}, status=403)
        
        optimizer = AIContentOptimizer()
        result = optimizer.analyze_readability(post.content)
        
        return JsonResponse(result)
    except Exception as e:
        return JsonResponse({'error': f'Error interno: {str(e)}'}, status=500)


@login_required
def blog_ai_test_connection(request):
    """Probar conexión con IA"""
    try:
        from .ai_utils import test_ai_connection
        from .utils import is_agent
        
        # Verificar permisos
        if not is_agent(request.user):
            return JsonResponse({'error': 'Permisos insuficientes'}, status=403)
        
        result = test_ai_connection()
        return JsonResponse(result)
    except Exception as e:
        return JsonResponse({'success': False, 'message': f'Error interno: {str(e)}'}, status=500)


@login_required
@require_http_methods(["POST"])
def blog_ai_improve_complete_article(request, pk):
    """Mejorar completamente el artículo (título + contenido) con IA"""
    try:
        from .ai_utils import AIContentOptimizer
        from .utils import is_agent
        
        post = get_object_or_404(BlogPost, pk=pk)
        
        # Verificar permisos
        if not is_agent(request.user):
            return JsonResponse({'error': 'Permisos insuficientes'}, status=403)
        
        optimizer = AIContentOptimizer()
        result = optimizer.improve_complete_article(post.title, post.content)
        
        return JsonResponse(result)
    except Exception as e:
        return JsonResponse({'error': f'Error interno: {str(e)}'}, status=500)


@login_required
@require_http_methods(["POST"])
def blog_ai_generate_image(request, pk):
    """Generar imagen para el artículo con IA basándose en el título"""
    try:
        from .ai_utils import AIContentOptimizer
        from .utils import is_agent
        
        post = get_object_or_404(BlogPost, pk=pk)
        
        # Verificar permisos
        if not is_agent(request.user):
            return JsonResponse({'error': 'Permisos insuficientes'}, status=403)
        
        optimizer = AIContentOptimizer()
        result = optimizer.generate_article_image(post.title, post.content)
        
        if result.get("success"):
            # Actualizar el post con la nueva imagen
            post.featured_image = result["file_path"]
            post.save()
            
            return JsonResponse({
                "success": True,
                "image_url": result["local_url"],
                "file_path": result["file_path"],
                "message": "Imagen generada y guardada exitosamente"
            })
        else:
            return JsonResponse(result)
            
    except Exception as e:
        return JsonResponse({'error': f'Error interno: {str(e)}'}, status=500)


@login_required
@require_http_methods(["POST"])
def blog_ai_apply_improvements(request, pk):
    """Aplicar mejoras sugeridas por IA al artículo"""
    try:
        from .utils import is_agent
        
        post = get_object_or_404(BlogPost, pk=pk)
        
        # Verificar permisos
        if not is_agent(request.user):
            return JsonResponse({'error': 'Permisos insuficientes'}, status=403)
        
        data = json.loads(request.body)
        
        # Aplicar cambios si están presentes
        if 'content' in data and data['content']:
            post.content = data['content']
        
        if 'meta_description' in data and data['meta_description']:
            post.meta_description = data['meta_description']
        
        if 'tags' in data and data['tags']:
            post.tags = data['tags']
        
        if 'title' in data and data['title']:
            post.title = data['title']
            # Regenerar slug si se cambia el título
            from django.utils.text import slugify
            post.slug = slugify(post.title)
        
        post.save()
        
        return JsonResponse({
            'success': True, 
            'message': 'Artículo actualizado exitosamente con las mejoras de IA'
        })
        
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Datos JSON inválidos'}, status=400)
    except Exception as e:
        return JsonResponse({'error': f'Error interno: {str(e)}'}, status=500)


# =============================================================================
# VISTAS DE EXÁMENES
# =============================================================================

@login_required
def exam_list(request):
    """Lista de exámenes"""
    exams = Exam.objects.all().order_by('-created_at')
    
    # Agregar información del último intento del usuario para cada examen
    for exam in exams:
        exam.user_last_attempt = exam.attempts.filter(
            user=request.user
        ).order_by('-completed_at').first()
    
    context = {
        'exams': exams
    }
    return render(request, 'tickets/exam_list.html', context)


@login_required
def exam_create(request):
    """Crear nuevo examen (agentes y profesores)"""
    from .utils import can_manage_courses
    
    if not can_manage_courses(request.user):
        messages.error(request, 'No tienes permisos para crear exámenes')
        return redirect('exam_list')
    
    if request.method == 'POST':
        title = request.POST.get('title')
        description = request.POST.get('description', '')
        passing_score = request.POST.get('passing_score', 70)
        time_limit = request.POST.get('time_limit') or None
        is_public = request.POST.get('is_public') == 'on'
        
        exam = Exam.objects.create(
            title=title,
            description=description,
            passing_score=int(passing_score),
            time_limit=int(time_limit) if time_limit else None,
            is_public=is_public,
            created_by=request.user
        )
        
        messages.success(request, f'Examen "{exam.title}" creado exitosamente')
        return redirect('exam_detail', pk=exam.pk)
    
    return render(request, 'tickets/exam_form.html')


@login_required
def exam_detail(request, pk):
    """Detalle del examen"""
    from .utils import is_agent
    
    exam = get_object_or_404(Exam, pk=pk)
    questions = exam.questions.all().order_by('order')
    
    # Filtrar intentos según el tipo de usuario
    if is_agent(request.user) or exam.created_by == request.user:
        # Agentes y creadores ven todos los intentos
        attempts = exam.attempts.all().order_by('-completed_at')[:10]
    else:
        # Usuarios normales solo ven sus propios intentos
        attempts = exam.attempts.filter(user=request.user).order_by('-completed_at')[:5]
    
    # Obtener el último intento del usuario actual
    user_last_attempt = None
    if request.user.is_authenticated:
        user_last_attempt = exam.attempts.filter(
            user=request.user
        ).order_by('-completed_at').first()
    
    context = {
        'exam': exam,
        'questions': questions,
        'attempts': attempts,
        'user_last_attempt': user_last_attempt,
        'can_edit': is_agent(request.user) or exam.created_by == request.user
    }
    return render(request, 'tickets/exam_detail.html', context)


@login_required
def exam_edit(request, pk):
    """Editar examen"""
    from .utils import can_manage_courses
    
    exam = get_object_or_404(Exam, pk=pk)
    
    if not (can_manage_courses(request.user) or exam.created_by == request.user):
        messages.error(request, 'No tienes permisos para editar este examen')
        return redirect('exam_detail', pk=exam.pk)
    
    if request.method == 'POST':
        exam.title = request.POST.get('title')
        exam.description = request.POST.get('description', '')
        exam.passing_score = int(request.POST.get('passing_score', 70))
        exam.time_limit = int(request.POST.get('time_limit')) if request.POST.get('time_limit') else None
        exam.is_public = request.POST.get('is_public') == 'on'
        exam.save()
        
        messages.success(request, 'Examen actualizado exitosamente')
        return redirect('exam_detail', pk=exam.pk)
    
    context = {'exam': exam}
    return render(request, 'tickets/exam_form.html', context)


@login_required
def exam_delete(request, pk):
    """Eliminar examen"""
    from .utils import can_manage_courses
    
    exam = get_object_or_404(Exam, pk=pk)
    
    if not (can_manage_courses(request.user) or exam.created_by == request.user):
        messages.error(request, 'No tienes permisos para eliminar este examen')
        return redirect('exam_detail', pk=exam.pk)
    
    if request.method == 'POST':
        exam_title = exam.title
        exam.delete()
        messages.success(request, f'Examen "{exam_title}" eliminado exitosamente')
        return redirect('exam_list')
    
    context = {'exam': exam}
    return render(request, 'tickets/exam_delete.html', context)


def exam_take_public(request, token):
    """Tomar examen público (sin autenticación)"""
    exam = get_object_or_404(Exam, public_token=token, is_public=True)
    
    if request.method == 'POST':
        # Registrar datos del participante
        participant_name = request.POST.get('participant_name')
        participant_email = request.POST.get('participant_email')
        
        if not participant_name or not participant_email:
            messages.error(request, 'Nombre y email son requeridos')
            return render(request, 'tickets/exam_public_start.html', {'exam': exam})
        
        # Redirigir al examen con los datos en sesión
        request.session['exam_participant'] = {
            'name': participant_name,
            'email': participant_email,
            'exam_id': exam.id,
            'started_at': timezone.now().isoformat()
        }
        
        return redirect('exam_take_questions', token=token)
    
    return render(request, 'tickets/exam_public_start.html', {'exam': exam})


def exam_take_questions(request, token):
    """Mostrar preguntas del examen público"""
    exam = get_object_or_404(Exam, public_token=token, is_public=True)
    
    # Verificar datos del participante en sesión
    participant_data = request.session.get('exam_participant')
    if not participant_data or participant_data.get('exam_id') != exam.id:
        return redirect('exam_take_public', token=token)
    
    questions = exam.questions.all().order_by('order')
    
    if request.method == 'POST':
        # Procesar respuestas
        from django.utils import timezone
        from datetime import datetime
        
        started_at = datetime.fromisoformat(participant_data['started_at'])
        completed_at = timezone.now()
        time_taken = int((completed_at - started_at).total_seconds())
        
        # Crear intento de examen
        attempt = ExamAttempt.objects.create(
            exam=exam,
            participant_name=participant_data['name'],
            participant_email=participant_data['email'],
            total_questions=questions.count(),
            started_at=started_at,
            completed_at=completed_at,
            time_taken=time_taken,
            score=0,  # Se calculará después
            correct_answers=0
        )
        
        # Procesar respuestas
        correct_count = 0
        for question in questions:
            selected_option = request.POST.get(f'question_{question.id}')
            if selected_option:
                is_correct = selected_option == question.correct_option
                if is_correct:
                    correct_count += 1
                
                ExamAnswer.objects.create(
                    attempt=attempt,
                    question=question,
                    selected_option=selected_option,
                    is_correct=is_correct
                )
        
        # Calcular puntuación
        score = (correct_count / questions.count()) * 100 if questions.count() > 0 else 0
        attempt.correct_answers = correct_count
        attempt.score = score
        attempt.passed = score >= exam.passing_score
        attempt.save()
        
        # Limpiar sesión
        del request.session['exam_participant']
        
        return redirect('exam_results', attempt_id=attempt.id)
    
    context = {
        'exam': exam,
        'questions': questions,
        'participant_data': participant_data
    }
    return render(request, 'tickets/exam_take.html', context)


@login_required
def exam_take_authenticated(request, pk):
    """Tomar examen autenticado"""
    exam = get_object_or_404(Exam, pk=pk)
    questions = exam.questions.all().order_by('order')
    
    if request.method == 'POST':
        # Procesar respuestas
        from django.utils import timezone
        
        started_at = timezone.now() - timezone.timedelta(
            seconds=int(request.POST.get('time_taken', 0))
        )
        completed_at = timezone.now()
        time_taken = int(request.POST.get('time_taken', 0))
        
        # Crear intento de examen
        attempt = ExamAttempt.objects.create(
            exam=exam,
            user=request.user,
            participant_name=f"{request.user.first_name} {request.user.last_name}".strip() or request.user.username,
            participant_email=request.user.email,
            total_questions=questions.count(),
            started_at=started_at,
            completed_at=completed_at,
            time_taken=time_taken,
            score=0,
            correct_answers=0
        )
        
        # Procesar respuestas
        correct_count = 0
        for question in questions:
            selected_option = request.POST.get(f'question_{question.id}')
            if selected_option:
                is_correct = selected_option == question.correct_option
                if is_correct:
                    correct_count += 1
                
                ExamAnswer.objects.create(
                    attempt=attempt,
                    question=question,
                    selected_option=selected_option,
                    is_correct=is_correct
                )
        
        # Calcular puntuación
        score = (correct_count / questions.count()) * 100 if questions.count() > 0 else 0
        attempt.correct_answers = correct_count
        attempt.score = score
        attempt.passed = score >= exam.passing_score
        attempt.save()
        
        return redirect('exam_results', attempt_id=attempt.id)
    
    context = {
        'exam': exam,
        'questions': questions
    }
    return render(request, 'tickets/exam_take.html', context)


def exam_results(request, attempt_id):
    """Mostrar resultados del examen"""
    from .utils import is_agent
    
    attempt = get_object_or_404(ExamAttempt, id=attempt_id)
    answers = attempt.answers.all().select_related('question')
    
    # Solo los agentes pueden ver las respuestas correctas
    can_view_answers = request.user.is_authenticated and is_agent(request.user)
    
    # Generar token del certificado si es necesario
    if attempt.passed and not attempt.certificate_token:
        attempt.generate_certificate_token()
    
    context = {
        'attempt': attempt,
        'answers': answers,
        'exam': attempt.exam,
        'can_view_answers': can_view_answers
    }
    return render(request, 'tickets/exam_results.html', context)


def download_certificate(request, attempt_id):
    """Descargar certificado de examen aprobado"""
    from .certificate_utils import create_certificate_response
    
    attempt = get_object_or_404(ExamAttempt, id=attempt_id)
    
    # Verificar que el usuario puede descargar este certificado
    # Para exámenes públicos, cualquiera puede descargar el certificado si tiene el ID
    # Para exámenes privados, solo el usuario o agentes pueden descargarlo
    if not attempt.exam.is_public and request.user.is_authenticated:
        if not (attempt.user == request.user or 
                request.user.groups.filter(name='Agentes').exists()):
            messages.error(request, 'No tienes permisos para descargar este certificado')
            return redirect('exam_results', attempt_id=attempt_id)
    elif not attempt.exam.is_public and not request.user.is_authenticated:
        messages.error(request, 'Debes iniciar sesión para descargar este certificado')
        return redirect('exam_results', attempt_id=attempt_id)
    
    # Verificar que el examen fue aprobado
    if not attempt.passed:
        messages.error(request, 'Solo se pueden generar certificados para exámenes aprobados')
        return redirect('exam_results', attempt_id=attempt_id)
    
    # Generar y retornar el certificado
    response = create_certificate_response(attempt)
    if response:
        return response
    else:
        messages.error(request, 'Error al generar el certificado')
        return redirect('exam_results', attempt_id=attempt_id)


def verify_certificate(request, token):
    """Verificar autenticidad de un certificado"""
    from .certificate_utils import verify_certificate_data
    
    cert_data = verify_certificate_data(token)
    
    context = {
        'cert_data': cert_data,
        'token': token
    }
    return render(request, 'tickets/certificate_verify.html', context)


@login_required
def question_create(request, exam_pk):
    """Crear pregunta para examen"""
    from .utils import can_manage_courses
    
    exam = get_object_or_404(Exam, pk=exam_pk)
    
    if not (can_manage_courses(request.user) or exam.created_by == request.user):
        messages.error(request, 'No tienes permisos para agregar preguntas')
        return redirect('exam_detail', pk=exam.pk)
    
    if request.method == 'POST':
        question = ExamQuestion.objects.create(
            exam=exam,
            question_text=request.POST.get('question_text'),
            option_a=request.POST.get('option_a'),
            option_b=request.POST.get('option_b'),
            option_c=request.POST.get('option_c'),
            correct_option=request.POST.get('correct_option'),
            order=exam.questions.count() + 1
        )
        
        messages.success(request, 'Pregunta agregada exitosamente')
        return redirect('exam_detail', pk=exam.pk)
    
    context = {'exam': exam}
    return render(request, 'tickets/question_form.html', context)


@login_required
def question_edit(request, pk):
    """Editar pregunta"""
    from .utils import can_manage_courses
    
    question = get_object_or_404(ExamQuestion, pk=pk)
    exam = question.exam
    
    if not (can_manage_courses(request.user) or exam.created_by == request.user):
        messages.error(request, 'No tienes permisos para editar esta pregunta')
        return redirect('exam_detail', pk=exam.pk)
    
    if request.method == 'POST':
        question.question_text = request.POST.get('question_text')
        question.option_a = request.POST.get('option_a')
        question.option_b = request.POST.get('option_b')
        question.option_c = request.POST.get('option_c')
        question.correct_option = request.POST.get('correct_option')
        question.save()
        
        messages.success(request, 'Pregunta actualizada exitosamente')
        return redirect('exam_detail', pk=exam.pk)
    
    context = {'question': question, 'exam': exam}
    return render(request, 'tickets/question_form.html', context)


@login_required
def question_delete(request, pk):
    """Eliminar pregunta"""
    from .utils import can_manage_courses
    
    question = get_object_or_404(ExamQuestion, pk=pk)
    exam = question.exam
    
    if not (can_manage_courses(request.user) or exam.created_by == request.user):
        messages.error(request, 'No tienes permisos para eliminar esta pregunta')
        return redirect('exam_detail', pk=exam.pk)
    
    if request.method == 'POST':
        question.delete()
        messages.success(request, 'Pregunta eliminada exitosamente')
        return redirect('exam_detail', pk=exam.pk)
    
    context = {'question': question, 'exam': exam}
    return render(request, 'tickets/question_delete.html', context)


@login_required
def exam_attempts_list(request):
    """Listado de todos los intentos de exámenes (solo para agentes)"""
    from .utils import is_agent
    
    if not is_agent(request.user):
        messages.error(request, 'No tienes permisos para acceder a esta sección')
        return redirect('dashboard')
    
    # Obtener parámetros de filtrado
    exam_filter = request.GET.get('exam', '')
    status_filter = request.GET.get('status', '')
    date_from = request.GET.get('date_from', '')
    date_to = request.GET.get('date_to', '')
    search = request.GET.get('search', '')
    
    # Filtrar intentos
    attempts = ExamAttempt.objects.select_related('exam', 'user').filter(
        completed_at__isnull=False
    ).order_by('-completed_at')
    
    # Aplicar filtros
    if exam_filter:
        attempts = attempts.filter(exam_id=exam_filter)
    
    if status_filter == 'passed':
        attempts = attempts.filter(passed=True)
    elif status_filter == 'failed':
        attempts = attempts.filter(passed=False)
    
    if date_from:
        try:
            from datetime import datetime
            date_from_obj = datetime.strptime(date_from, '%Y-%m-%d')
            attempts = attempts.filter(completed_at__date__gte=date_from_obj.date())
        except ValueError:
            pass
    
    if date_to:
        try:
            from datetime import datetime
            date_to_obj = datetime.strptime(date_to, '%Y-%m-%d')
            attempts = attempts.filter(completed_at__date__lte=date_to_obj.date())
        except ValueError:
            pass
    
    if search:
        from django.db.models import Q
        attempts = attempts.filter(
            Q(participant_name__icontains=search) |
            Q(participant_email__icontains=search) |
            Q(exam__title__icontains=search)
        )
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(attempts, 25)  # 25 intentos por página
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Obtener lista de exámenes para el filtro
    exams = Exam.objects.all().order_by('title')
    
    # Estadísticas generales
    total_attempts = attempts.count()
    passed_attempts = attempts.filter(passed=True).count()
    failed_attempts = attempts.filter(passed=False).count()
    pass_rate = (passed_attempts / total_attempts * 100) if total_attempts > 0 else 0
    
    context = {
        'page_obj': page_obj,
        'attempts': page_obj,
        'exams': exams,
        'current_filters': {
            'exam': exam_filter,
            'status': status_filter,
            'date_from': date_from,
            'date_to': date_to,
            'search': search,
        },
        'stats': {
            'total_attempts': total_attempts,
            'passed_attempts': passed_attempts,
            'failed_attempts': failed_attempts,
            'pass_rate': pass_rate,
        }
    }
    
    return render(request, 'tickets/exam_attempts_list.html', context)


# ==================== CONTACTO WEB ====================

def contacto_web(request):
    """Vista pública para formulario de contacto"""
    from .forms import ContactoWebForm
    from .models import ContactoWeb
    from datetime import datetime, timedelta
    from django.utils import timezone
    
    # Obtener IP del usuario para control de spam
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        user_ip = x_forwarded_for.split(',')[0]
    else:
        user_ip = request.META.get('REMOTE_ADDR')
    
    # Verificar límite de envíos (máximo 3 por hora por IP)
    one_hour_ago = timezone.now() - timedelta(hours=1)
    recent_contacts = ContactoWeb.objects.filter(
        ip_address=user_ip,
        fecha_creacion__gte=one_hour_ago
    ).count()
    
    if recent_contacts >= 3:
        messages.error(request, 'Has alcanzado el límite de contactos por hora. Por favor, inténtalo más tarde.')
        form = ContactoWebForm()
        # Generar CAPTCHA aunque no se pueda enviar
        import random
        num1 = random.randint(1, 10)
        num2 = random.randint(1, 10)
        operation = random.choice(['+', '-', '*'])
        
        if operation == '+':
            question = f"¿Cuánto es {num1} + {num2}?"
            correct_answer = num1 + num2
        elif operation == '-':
            if num1 < num2:
                num1, num2 = num2, num1
            question = f"¿Cuánto es {num1} - {num2}?"
            correct_answer = num1 - num2
        else:
            question = f"¿Cuánto es {num1} × {num2}?"
            correct_answer = num1 * num2
        
        request.session['captcha_answer'] = correct_answer
        form.fields['captcha_question'].initial = question
        
        context = {
            'form': form,
            'page_title': 'Contáctanos',
            'rate_limited': True
        }
        return render(request, 'tickets/contacto_web.html', context)
    
    if request.method == 'POST':
        form = ContactoWebForm(request.POST)
        
        # Verificar CAPTCHA
        captcha_answer = request.POST.get('captcha_answer')
        correct_answer = request.session.get('captcha_answer')
        
        if not captcha_answer or not correct_answer:
            form.add_error('captcha_answer', 'Error en la verificación. Recarga la página e inténtalo de nuevo.')
        else:
            try:
                if int(captcha_answer) != correct_answer:
                    form.add_error('captcha_answer', 'La respuesta del CAPTCHA es incorrecta. Inténtalo de nuevo.')
            except (ValueError, TypeError):
                form.add_error('captcha_answer', 'Por favor, introduce solo números en el resultado.')
        
        if form.is_valid():
            # Guardar el contacto con información adicional
            contacto = form.save(commit=False)
            
            # Obtener IP del usuario
            contacto.ip_address = user_ip
            
            # Obtener User Agent
            contacto.user_agent = request.META.get('HTTP_USER_AGENT', '')
            
            contacto.save()
            
            # Enviar notificación por email
            try:
                from .utils import send_contact_notification
                send_contact_notification(contacto)
            except Exception as e:
                # Log del error pero no interrumpir el flujo
                import logging
                logger = logging.getLogger(__name__)
                logger.error(f"Error enviando notificación de contacto: {str(e)}")
            
            # Limpiar CAPTCHA de la sesión después del envío exitoso
            if 'captcha_answer' in request.session:
                del request.session['captcha_answer']
            
            messages.success(request, '¡Gracias por contactarnos! Hemos recibido tu mensaje y te responderemos pronto.')
            return redirect('contacto_web')
    else:
        form = ContactoWebForm()
        
    # Generar nuevo CAPTCHA y guardarlo en la sesión
    import random
    num1 = random.randint(1, 10)
    num2 = random.randint(1, 10)
    operation = random.choice(['+', '-', '*'])
    
    if operation == '+':
        question = f"¿Cuánto es {num1} + {num2}?"
        correct_answer = num1 + num2
    elif operation == '-':
        # Asegurar que el resultado sea positivo
        if num1 < num2:
            num1, num2 = num2, num1
        question = f"¿Cuánto es {num1} - {num2}?"
        correct_answer = num1 - num2
    else:  # multiplicación
        question = f"¿Cuánto es {num1} × {num2}?"
        correct_answer = num1 * num2
    
    # Guardar la respuesta correcta en la sesión
    request.session['captcha_answer'] = correct_answer
    
    # Establecer la pregunta en el formulario
    form.fields['captcha_question'].initial = question
    
    context = {
        'form': form,
        'page_title': 'Contáctanos'
    }
    
    return render(request, 'tickets/contacto_web.html', context)


@login_required
def contactos_web_list(request):
    """Vista para listar contactos web - solo para agentes"""
    from .utils import is_agent
    from .models import ContactoWeb
    
    if not is_agent(request.user):
        messages.error(request, 'No tienes permisos para acceder a esta sección')
        return redirect('dashboard')
    
    # Filtros
    search = request.GET.get('search', '')
    status_filter = request.GET.get('status', 'all')
    date_from = request.GET.get('date_from', '')
    date_to = request.GET.get('date_to', '')
    
    # Obtener contactos
    contactos = ContactoWeb.objects.all().order_by('-fecha_creacion')
    
    # Aplicar filtros
    if search:
        from django.db.models import Q
        contactos = contactos.filter(
            Q(nombre__icontains=search) |
            Q(email__icontains=search) |
            Q(empresa__icontains=search) |
            Q(asunto__icontains=search) |
            Q(mensaje__icontains=search)
        )
    
    if status_filter == 'no_leido':
        contactos = contactos.filter(leido=False)
    elif status_filter == 'leido':
        contactos = contactos.filter(leido=True)
    elif status_filter == 'respondido':
        contactos = contactos.filter(respondido=True)
    elif status_filter == 'pendiente':
        contactos = contactos.filter(respondido=False)
    
    if date_from:
        try:
            from datetime import datetime
            date_from_obj = datetime.strptime(date_from, '%Y-%m-%d')
            contactos = contactos.filter(fecha_creacion__date__gte=date_from_obj.date())
        except ValueError:
            pass
    
    if date_to:
        try:
            from datetime import datetime
            date_to_obj = datetime.strptime(date_to, '%Y-%m-%d')
            contactos = contactos.filter(fecha_creacion__date__lte=date_to_obj.date())
        except ValueError:
            pass
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(contactos, 25)  # 25 contactos por página
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Estadísticas
    total_contactos = ContactoWeb.objects.count()
    no_leidos = ContactoWeb.objects.filter(leido=False).count()
    respondidos = ContactoWeb.objects.filter(respondido=True).count()
    pendientes = ContactoWeb.objects.filter(respondido=False).count()
    
    context = {
        'page_obj': page_obj,
        'contactos': page_obj,
        'current_filters': {
            'search': search,
            'status': status_filter,
            'date_from': date_from,
            'date_to': date_to,
        },
        'stats': {
            'total_contactos': total_contactos,
            'no_leidos': no_leidos,
            'respondidos': respondidos,
            'pendientes': pendientes,
        },
        'page_title': 'Contactos Web'
    }
    
    return render(request, 'tickets/contactos_web_list.html', context)


@login_required
def contacto_web_detail(request, pk):
    """Vista para ver detalle de un contacto web"""
    from .utils import is_agent
    from .models import ContactoWeb
    
    if not is_agent(request.user):
        messages.error(request, 'No tienes permisos para acceder a esta sección')
        return redirect('dashboard')
    
    contacto = get_object_or_404(ContactoWeb, pk=pk)
    
    # Marcar como leído si no lo estaba
    if not contacto.leido:
        contacto.leido = True
        contacto.save()
    
    # Si es POST, actualizar estado de respondido
    if request.method == 'POST':
        if 'marcar_respondido' in request.POST:
            contacto.respondido = True
            contacto.save()
            messages.success(request, 'Contacto marcado como respondido')
        elif 'marcar_pendiente' in request.POST:
            contacto.respondido = False
            contacto.save()
            messages.success(request, 'Contacto marcado como pendiente')
        
        return redirect('contacto_web_detail', pk=pk)
    
    context = {
        'contacto': contacto,
        'page_title': f'Contacto: {contacto.nombre}'
    }
    
    return render(request, 'tickets/contacto_web_detail.html', context)


# =================================
# URLS PÚBLICAS DE SUBIDA DE DOCUMENTOS
# =================================

@login_required
@user_passes_test(is_agent)
def public_upload_url_list(request):
    """Lista las URLs públicas de subida de documentos"""
    upload_urls = PublicDocumentUpload.objects.filter(created_by=request.user)
    
    context = {
        'upload_urls': upload_urls,
        'page_title': 'URLs Públicas de Subida'
    }
    
    return render(request, 'tickets/public_upload_url_list.html', context)


@login_required
@user_passes_test(is_agent)
def public_upload_url_create(request):
    """Crea una nueva URL pública de subida"""
    if request.method == 'POST':
        title = request.POST.get('title')
        description = request.POST.get('description', '')
        company_id = request.POST.get('company')
        expires_at = request.POST.get('expires_at')
        max_uploads = request.POST.get('max_uploads')
        
        # Crear la URL pública
        upload_url = PublicDocumentUpload(
            title=title,
            description=description,
            created_by=request.user
        )
        
        if company_id:
            upload_url.company_id = company_id
        
        if expires_at:
            upload_url.expires_at = expires_at
        
        if max_uploads:
            upload_url.max_uploads = int(max_uploads)
        
        upload_url.save()
        
        messages.success(request, f'URL pública creada exitosamente. Token: {upload_url.upload_token}')
        return redirect('public_upload_url_detail', pk=upload_url.pk)
    
    companies = Company.objects.all()
    
    context = {
        'companies': companies,
        'page_title': 'Crear URL Pública de Subida'
    }
    
    return render(request, 'tickets/public_upload_url_form.html', context)


@login_required
@user_passes_test(is_agent)
def public_upload_url_detail(request, pk):
    """Detalle de una URL pública de subida"""
    upload_url = get_object_or_404(PublicDocumentUpload, pk=pk, created_by=request.user)
    
    # Obtener documentos subidos usando esta URL
    uploaded_documents = Document.objects.filter(
        tags__icontains=f'upload-token:{upload_url.upload_token}'
    ).order_by('-created_at')
    
    # Generar URL completa
    public_url = request.build_absolute_uri(upload_url.get_public_url())
    
    context = {
        'upload_url': upload_url,
        'uploaded_documents': uploaded_documents,
        'public_url': public_url,
        'page_title': f'URL Pública: {upload_url.title}'
    }
    
    return render(request, 'tickets/public_upload_url_detail.html', context)


@login_required
@user_passes_test(is_agent)
def public_upload_url_toggle(request, pk):
    """Activa/desactiva una URL pública"""
    upload_url = get_object_or_404(PublicDocumentUpload, pk=pk, created_by=request.user)
    
    upload_url.is_active = not upload_url.is_active
    upload_url.save()
    
    status = "activada" if upload_url.is_active else "desactivada"
    messages.success(request, f'URL pública {status} exitosamente')
    
    return redirect('public_upload_url_detail', pk=pk)


def public_document_upload(request, token):
    """Vista pública para subir documentos (no requiere login)"""
    upload_url = get_object_or_404(PublicDocumentUpload, upload_token=token)
    
    # Verificar si la URL es válida
    if not upload_url.is_valid():
        context = {
            'error': 'Esta URL de subida ha expirado o ya no está disponible.',
            'upload_url': upload_url
        }
        return render(request, 'tickets/public_upload_error.html', context)
    
    if request.method == 'POST':
        title = request.POST.get('title', '').strip()
        description = request.POST.get('description', '').strip()
        uploaded_file = request.FILES.get('file')
        
        if not title:
            messages.error(request, 'El título es obligatorio')
        elif not uploaded_file:
            messages.error(request, 'Debe seleccionar un archivo')
        else:
            try:
                # Crear el documento
                document = Document(
                    title=title,
                    description=description,
                    file=uploaded_file,
                    created_by=upload_url.created_by,
                    company=upload_url.company,
                    tags=f'upload-token:{upload_url.upload_token},public-upload'
                )
                
                # Establecer metadatos del archivo
                document.file_size = uploaded_file.size
                document.file_type = uploaded_file.content_type or 'unknown'
                
                document.save()
                
                # Actualizar contador y última fecha de uso
                upload_url.upload_count += 1
                upload_url.last_used_at = timezone.now()
                upload_url.save()
                
                messages.success(request, '¡Archivo subido exitosamente!')
                
                # Redirigir a una página de éxito
                context = {
                    'document': document,
                    'upload_url': upload_url,
                    'success': True
                }
                return render(request, 'tickets/public_upload_success.html', context)
                
            except Exception as e:
                messages.error(request, f'Error al subir el archivo: {str(e)}')
    
    context = {
        'upload_url': upload_url,
        'page_title': f'Subir Documento: {upload_url.title}'
    }
    
    return render(request, 'tickets/public_upload_form.html', context)


# === VISTAS DE REGISTRO PÚBLICO DE CURSOS ===

@login_required
def course_generate_registration_token(request, pk):
    """Generar token de registro público para un curso"""
    from .models import Course, CourseRegistrationToken
    from . import utils
    
    course = get_object_or_404(Course, pk=pk)
    
    if not utils.can_manage_courses(request.user):
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('course_detail', pk=pk)
    
    if request.method == 'POST':
        # Obtener parámetros del formulario
        expires_in_days = request.POST.get('expires_in_days')
        max_registrations = request.POST.get('max_registrations')
        
        # Calcular fecha de expiración
        expires_at = None
        if expires_in_days:
            try:
                days = int(expires_in_days)
                expires_at = timezone.now() + timezone.timedelta(days=days)
            except ValueError:
                pass
        
        # Validar max_registrations
        max_regs = None
        if max_registrations:
            try:
                max_regs = int(max_registrations)
            except ValueError:
                pass
        
        # Crear el token
        token = CourseRegistrationToken.objects.create(
            course=course,
            created_by=request.user,
            expires_at=expires_at,
            max_registrations=max_regs
        )
        
        messages.success(request, f'Token de registro creado exitosamente.')
        return redirect('course_detail', pk=pk)
    
    context = {
        'course': course,
        'page_title': f'Generar Token de Registro - {course.title}'
    }
    
    return render(request, 'tickets/course_generate_registration_token.html', context)


@login_required
def course_disable_registration_token(request, pk, token_id):
    """Desactivar token de registro público"""
    from .models import Course, CourseRegistrationToken
    from . import utils
    
    course = get_object_or_404(Course, pk=pk)
    token = get_object_or_404(CourseRegistrationToken, pk=token_id, course=course)
    
    if not utils.can_manage_courses(request.user):
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('course_detail', pk=pk)
    
    token.is_active = False
    token.save()
    
    messages.success(request, 'Token de registro desactivado exitosamente.')
    return redirect('course_detail', pk=pk)


def course_public_register(request, token):
    """Formulario de registro público para cursos"""
    from .models import CourseRegistrationToken, UserProfile
    from django.contrib.auth.models import User
    from django.contrib.auth import login
    
    # Buscar el token
    try:
        registration_token = CourseRegistrationToken.objects.get(token=token)
    except CourseRegistrationToken.DoesNotExist:
        messages.error(request, 'Token de registro no válido.')
        return redirect('course_public')
    
    # Verificar si el token es válido
    is_valid, message = registration_token.is_valid()
    if not is_valid:
        messages.error(request, f'Token no válido: {message}')
        return redirect('course_public')
    
    course = registration_token.course
    
    if request.method == 'POST':
        # Obtener datos del formulario
        first_name = request.POST.get('first_name', '').strip()
        last_name = request.POST.get('last_name', '').strip()
        email = request.POST.get('email', '').strip()
        password = request.POST.get('password', '')
        password_confirm = request.POST.get('password_confirm', '')
        
        # Validaciones
        errors = []
        
        if not first_name:
            errors.append('El nombre es obligatorio.')
        
        if not last_name:
            errors.append('El apellido es obligatorio.')
        
        if not email:
            errors.append('El correo electrónico es obligatorio.')
        elif User.objects.filter(email=email).exists():
            errors.append('Ya existe un usuario con este correo electrónico.')
        
        if not password:
            errors.append('La contraseña es obligatoria.')
        elif len(password) < 8:
            errors.append('La contraseña debe tener al menos 8 caracteres.')
        
        if password != password_confirm:
            errors.append('Las contraseñas no coinciden.')
        
        if errors:
            for error in errors:
                messages.error(request, error)
        else:
            try:
                # Crear el usuario
                username = email.split('@')[0]
                counter = 1
                original_username = username
                
                # Asegurar que el username sea único
                while User.objects.filter(username=username).exists():
                    username = f"{original_username}{counter}"
                    counter += 1
                
                user = User.objects.create_user(
                    username=username,
                    email=email,
                    password=password,
                    first_name=first_name,
                    last_name=last_name
                )
                
                # Crear o actualizar el perfil del usuario
                user_profile, created = UserProfile.objects.get_or_create(user=user)
                
                # Asignar la empresa del profesor/agente que creó el token
                try:
                    creator_profile = UserProfile.objects.get(user=registration_token.created_by)
                    if creator_profile.company:
                        user_profile.company = creator_profile.company
                        user_profile.save()
                except UserProfile.DoesNotExist:
                    # Si el creador del token no tiene perfil, usar la empresa del curso como fallback
                    if course.company:
                        user_profile.company = course.company
                        user_profile.save()
                
                # Incrementar contador de registros
                registration_token.increment_registration_count()
                
                # Iniciar sesión automáticamente
                login(request, user)
                
                messages.success(request, f'¡Registro exitoso! Bienvenido al curso "{course.title}".')
                return redirect('course_detail', pk=course.pk)
                
            except Exception as e:
                messages.error(request, f'Error al crear el usuario: {str(e)}')
    
    context = {
        'course': course,
        'token': registration_token,
        'page_title': f'Registro para {course.title}'
    }
    
    return render(request, 'tickets/course_public_register.html', context)


@login_required
def course_registration_tokens_list(request, pk):
    """Lista de tokens de registro para un curso"""
    from .models import Course, CourseRegistrationToken
    from . import utils
    
    course = get_object_or_404(Course, pk=pk)
    
    if not utils.can_manage_courses(request.user):
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('course_detail', pk=pk)
    
    tokens = CourseRegistrationToken.objects.filter(course=course).order_by('-created_at')
    
    context = {
        'course': course,
        'tokens': tokens,
        'page_title': f'Tokens de Registro - {course.title}'
    }
    
    return render(request, 'tickets/course_registration_tokens_list.html', context)


# =============================================================================
# VISTAS DE EMPLEADOS Y APLICACIONES DE TRABAJO
# =============================================================================

@login_required
def employee_list(request):
    """Lista de empleados"""
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes', 'Profesores']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('dashboard')
    
    # Filtrar por empresa del usuario
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company:
        employees = Employee.objects.filter(company=user_profile.company).order_by('-created_at')
    else:
        employees = Employee.objects.all().order_by('-created_at')
    
    # Filtros
    status_filter = request.GET.get('status')
    search = request.GET.get('search')
    
    if status_filter:
        employees = employees.filter(status=status_filter)
    
    if search:
        employees = employees.filter(
            Q(first_name__icontains=search) |
            Q(last_name__icontains=search) |
            Q(email__icontains=search) |
            Q(position__icontains=search)
        )
    
    # Paginación
    paginator = Paginator(employees, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_obj': page_obj,
        'status_choices': Employee.STATUS_CHOICES,
        'current_status': status_filter,
        'search': search,
        'page_title': 'Gestión de Empleados'
    }
    
    return render(request, 'tickets/employee_list.html', context)


@login_required
def employee_detail(request, pk):
    """Detalle de un empleado"""
    employee = get_object_or_404(Employee, pk=pk)
    
    # Verificar permisos
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes', 'Profesores']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('employee_list')
    
    # Verificar que el usuario puede ver este empleado (misma empresa)
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company and employee.company != user_profile.company:
        messages.error(request, 'No tienes permisos para ver este empleado.')
        return redirect('employee_list')
    
    if request.method == 'POST' and 'analyze_ai' in request.POST:
        # Obtener configuración del sistema
        config = SystemConfiguration.objects.first()
        if not config or not config.openai_api_key:
            messages.error(request, 'La configuración de IA no está disponible. Contacta al administrador.')
            return redirect('employee_detail', pk=pk)
            
        # Preparar datos para IA
        datos = f"Nombre: {employee.get_full_name()}\nEmail: {employee.email}\nTeléfono: {employee.phone}\nCargo: {employee.position}"
        if employee.salary_euros:
            datos += f"\nSalario propuesto: €{employee.salary_euros}"
        if employee.description:
            datos += f"\nDescripción/Experiencia: {employee.description}"
        if employee.resume_file:
            datos += f"\nCurrículo adjunto: {employee.resume_file.name}"
            
        # Usar el prompt personalizado de la configuración
        prompt = config.ai_employee_analysis_prompt.format(datos=datos)
        
        # Llamada a OpenAI
        try:
            from openai import OpenAI
            
            client = OpenAI(api_key=config.openai_api_key)
            
            response = client.chat.completions.create(
                model=config.openai_model,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=500,
                temperature=0.7
            )
            
            texto = response.choices[0].message.content.strip()
            resumen = ""
            puntuacion = None
            
            # Extraer resumen y puntuación
            import re
            resumen_match = re.search(r"Resumen:\s*(.*?)(?=Puntuación:|$)", texto, re.DOTALL)
            puntuacion_match = re.search(r"Puntuación:\s*(\d+)", texto)
            
            if resumen_match:
                resumen = resumen_match.group(1).strip()
            else:
                # Si no encuentra el formato esperado, usar todo el texto
                resumen = texto
                
            if puntuacion_match:
                puntuacion = int(puntuacion_match.group(1))
                # Validar que la puntuación esté entre 1 y 10
                if puntuacion < 1 or puntuacion > 10:
                    puntuacion = None
                    
            # Guardar resultados
            employee.ai_analysis = resumen if resumen else texto
            employee.ai_score = puntuacion
            employee.save()
            
            messages.success(request, "Análisis de IA completado y guardado correctamente.")
            
        except Exception as e:
            messages.error(request, f"Error al analizar con IA: {str(e)}")
            
        return redirect('employee_detail', pk=pk)
    context = {
        'employee': employee,
        'page_title': f'Empleado: {employee.get_full_name()}',
        'config': SystemConfiguration.objects.first()
    }
    return render(request, 'tickets/employee_detail.html', context)


@login_required
def employee_change_status(request, pk):
    """Cambiar el estado de un empleado"""
    employee = get_object_or_404(Employee, pk=pk)
    
    # Verificar permisos
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes', 'Profesores']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('employee_list')
    
    # Verificar que el usuario puede modificar este empleado (misma empresa)
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company and employee.company != user_profile.company:
        messages.error(request, 'No tienes permisos para modificar este empleado.')
        return redirect('employee_list')
    
    if request.method == 'POST':
        new_status = request.POST.get('status')
        if new_status in ['candidate', 'in_process', 'employee', 'not_employee']:
            employee.status = new_status
            employee.save()
            messages.success(request, f'Estado actualizado a {employee.get_status_display()}')
            return redirect('employee_detail', pk=pk)
        else:
            messages.error(request, 'Estado no válido.')
    
    return redirect('employee_detail', pk=pk)


@login_required
def employee_edit_hiring_opinion(request, pk):
    """Editar opinión de reunión de contratación"""
    employee = get_object_or_404(Employee, pk=pk)
    
    # Verificar permisos
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes', 'Profesores']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('employee_list')
    
    # Verificar que el usuario puede modificar este empleado (misma empresa)
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company and employee.company != user_profile.company:
        messages.error(request, 'No tienes permisos para modificar este empleado.')
        return redirect('employee_list')
    
    if request.method == 'POST':
        form = EmployeeHiringOpinionForm(request.POST, instance=employee)
        if form.is_valid():
            form.save()
            messages.success(request, 'Opinión de reunión actualizada correctamente.')
            
            # Redirigir según el tipo de empleado
            if employee.status in ['candidate', 'in_process']:
                return redirect('candidate_detail', pk=pk)
            else:
                return redirect('active_employee_detail', pk=pk)
        else:
            messages.error(request, 'Por favor, corrige los errores en el formulario.')
    else:
        form = EmployeeHiringOpinionForm(instance=employee)
    
    context = {
        'form': form,
        'employee': employee,
        'page_title': f'Editar Opinión de Reunión - {employee.get_full_name()}',
    }
    
    return render(request, 'tickets/employee_edit_hiring_opinion.html', context)


@login_required
def employee_payroll_list(request, pk):
    """Lista de nóminas de un empleado"""
    employee = get_object_or_404(Employee, pk=pk)
    
    # Verificar permisos
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes', 'Profesores']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('employee_list')
    
    # Verificar que el usuario puede ver este empleado (misma empresa)
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company and employee.company != user_profile.company:
        messages.error(request, 'No tienes permisos para ver este empleado.')
        return redirect('employee_list')
    
    # Obtener nóminas del empleado
    payrolls = employee.payrolls.all().order_by('-period_year', '-period_month')
    
    context = {
        'employee': employee,
        'payrolls': payrolls,
        'page_title': f'Nóminas - {employee.get_full_name()}',
    }
    
    return render(request, 'tickets/employee_payroll_list.html', context)


@login_required
def employee_payroll_create(request, pk):
    """Agregar nueva nómina a un empleado"""
    employee = get_object_or_404(Employee, pk=pk)
    
    # Verificar permisos
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes', 'Profesores']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('employee_list')
    
    # Verificar que el usuario puede modificar este empleado (misma empresa)
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company and employee.company != user_profile.company:
        messages.error(request, 'No tienes permisos para modificar este empleado.')
        return redirect('employee_list')
    
    if request.method == 'POST':
        form = EmployeePayrollForm(request.POST, request.FILES)
        if form.is_valid():
            payroll = form.save(commit=False)
            payroll.employee = employee
            payroll.created_by = request.user
            try:
                payroll.save()
                messages.success(request, f'Nómina de {payroll.get_period_display()} agregada correctamente.')
                return redirect('employee_payroll_list', pk=employee.pk)
            except Exception as e:
                if 'UNIQUE constraint failed' in str(e) or 'unique_together' in str(e):
                    messages.error(request, f'Ya existe una nómina para {payroll.get_period_display()}.')
                else:
                    messages.error(request, f'Error al guardar la nómina: {str(e)}')
        else:
            messages.error(request, 'Por favor, corrige los errores en el formulario.')
    else:
        form = EmployeePayrollForm()
    
    context = {
        'form': form,
        'employee': employee,
        'page_title': f'Nueva Nómina - {employee.get_full_name()}',
    }
    
    return render(request, 'tickets/employee_payroll_form.html', context)


@login_required
def employee_payroll_detail(request, employee_pk, payroll_pk):
    """Ver detalles de una nómina específica"""
    employee = get_object_or_404(Employee, pk=employee_pk)
    payroll = get_object_or_404(EmployeePayroll, pk=payroll_pk, employee=employee)
    
    # Verificar permisos
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes', 'Profesores']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('employee_list')
    
    # Verificar que el usuario puede ver este empleado (misma empresa)
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company and employee.company != user_profile.company:
        messages.error(request, 'No tienes permisos para ver este empleado.')
        return redirect('employee_list')
    
    context = {
        'employee': employee,
        'payroll': payroll,
        'page_title': f'Nómina {payroll.get_period_display()} - {employee.get_full_name()}',
    }
    
    return render(request, 'tickets/employee_payroll_detail.html', context)


@login_required
def employee_payroll_edit(request, employee_pk, payroll_pk):
    """Editar una nómina existente"""
    employee = get_object_or_404(Employee, pk=employee_pk)
    payroll = get_object_or_404(EmployeePayroll, pk=payroll_pk, employee=employee)
    
    # Verificar permisos
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes', 'Profesores']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('employee_list')
    
    # Verificar que el usuario puede modificar este empleado (misma empresa)
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company and employee.company != user_profile.company:
        messages.error(request, 'No tienes permisos para modificar este empleado.')
        return redirect('employee_list')
    
    if request.method == 'POST':
        # Debug: Verificar archivos recibidos
        print(f"DEBUG - FILES recibidos: {request.FILES}")
        print(f"DEBUG - POST data: {request.POST}")
        
        form = EmployeePayrollForm(request.POST, request.FILES, instance=payroll)
        if form.is_valid():
            try:
                saved_payroll = form.save()
                print(f"DEBUG - Nómina guardada - Comprobante: {saved_payroll.payment_receipt}")
                messages.success(request, f'Nómina de {payroll.get_period_display()} actualizada correctamente.')
                return redirect('employee_payroll_detail', employee_pk=employee.pk, payroll_pk=payroll.pk)
            except Exception as e:
                print(f"DEBUG - Error al guardar: {str(e)}")
                messages.error(request, f'Error al actualizar la nómina: {str(e)}')
        else:
            print(f"DEBUG - Errores del formulario: {form.errors}")
            messages.error(request, 'Por favor, corrige los errores en el formulario.')
    else:
        form = EmployeePayrollForm(instance=payroll)
    
    context = {
        'form': form,
        'employee': employee,
        'payroll': payroll,
        'page_title': f'Editar Nómina {payroll.get_period_display()} - {employee.get_full_name()}',
    }
    
    return render(request, 'tickets/employee_payroll_form.html', context)


@login_required
def employee_payroll_delete(request, employee_pk, payroll_pk):
    """Eliminar una nómina"""
    employee = get_object_or_404(Employee, pk=employee_pk)
    payroll = get_object_or_404(EmployeePayroll, pk=payroll_pk, employee=employee)
    
    # Verificar permisos
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes', 'Profesores']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('employee_list')
    
    # Verificar que el usuario puede modificar este empleado (misma empresa)
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company and employee.company != user_profile.company:
        messages.error(request, 'No tienes permisos para modificar este empleado.')
        return redirect('employee_list')
    
    if request.method == 'POST':
        period_display = payroll.get_period_display()
        payroll.delete()
        messages.success(request, f'Nómina de {period_display} eliminada correctamente.')
        return redirect('employee_payroll_list', pk=employee.pk)
    
    context = {
        'employee': employee,
        'payroll': payroll,
        'page_title': f'Eliminar Nómina {payroll.get_period_display()} - {employee.get_full_name()}',
    }
    
    return render(request, 'tickets/employee_payroll_delete.html', context)


@login_required
def candidate_list(request):
    """Lista de candidatos (estado: candidato e in_process)"""
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes', 'Profesores']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('dashboard')
    
    # Filtrar por empresa del usuario
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company:
        employees = Employee.objects.filter(
            company=user_profile.company,
            status__in=['candidate', 'in_process']
        ).order_by('-created_at')
    else:
        employees = Employee.objects.filter(status__in=['candidate', 'in_process']).order_by('-created_at')
    
    # Búsqueda
    search = request.GET.get('search')
    if search:
        employees = employees.filter(
            models.Q(first_name__icontains=search) |
            models.Q(last_name__icontains=search) |
            models.Q(email__icontains=search) |
            models.Q(position__icontains=search)
        )
    
    # Paginación
    paginator = Paginator(employees, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'employees': page_obj,
        'search': search,
        'page_title': 'Candidatos',
        'section': 'candidates'
    }
    
    return render(request, 'tickets/candidate_list.html', context)


@login_required
def candidate_detail(request, pk):
    """Detalle de un candidato"""
    employee = get_object_or_404(Employee, pk=pk)
    
    # Verificar permisos
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes', 'Profesores']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('candidate_list')
    
    # Verificar que el usuario puede ver este candidato (misma empresa)
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company and employee.company != user_profile.company:
        messages.error(request, 'No tienes permisos para ver este candidato.')
        return redirect('candidate_list')
    
    # Análisis de IA (mismo código que employee_detail)
    if request.method == 'POST' and 'analyze_ai' in request.POST:
        config = SystemConfiguration.objects.first()
        if not config or not config.openai_api_key:
            messages.error(request, 'La configuración de IA no está disponible. Contacta al administrador.')
            return redirect('candidate_detail', pk=pk)
            
        # Preparar datos para IA
        datos = f"Nombre: {employee.get_full_name()}\nEmail: {employee.email}\nTeléfono: {employee.phone}\nCargo: {employee.position}"
        if employee.salary_euros:
            datos += f"\nSalario propuesto: €{employee.salary_euros}"
        if employee.description:
            datos += f"\nDescripción/Experiencia: {employee.description}"
        if employee.resume_file:
            datos += f"\nCurrículo adjunto: {employee.resume_file.name}"
            
        # Usar el prompt personalizado de la configuración
        prompt = config.ai_employee_analysis_prompt.format(datos=datos)
        
        # Llamada a OpenAI
        try:
            from openai import OpenAI
            
            client = OpenAI(api_key=config.openai_api_key)
            
            response = client.chat.completions.create(
                model=config.openai_model,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=500,
                temperature=0.7
            )
            
            texto = response.choices[0].message.content.strip()
            resumen = ""
            puntuacion = None
            
            # Extraer resumen y puntuación
            import re
            resumen_match = re.search(r"Resumen:\s*(.*?)(?=Puntuación:|$)", texto, re.DOTALL)
            puntuacion_match = re.search(r"Puntuación:\s*(\d+)", texto)
            
            if resumen_match:
                resumen = resumen_match.group(1).strip()
            else:
                # Si no encuentra el formato esperado, usar todo el texto
                resumen = texto
                
            if puntuacion_match:
                puntuacion = int(puntuacion_match.group(1))
                # Validar que la puntuación esté entre 1 y 10
                if puntuacion < 1 or puntuacion > 10:
                    puntuacion = None
                    
            # Guardar resultados
            employee.ai_analysis = resumen if resumen else texto
            employee.ai_score = puntuacion
            employee.save()
            
            messages.success(request, "Análisis de IA completado y guardado correctamente.")
            
        except Exception as e:
            messages.error(request, f"Error al analizar con IA: {str(e)}")
            
        return redirect('candidate_detail', pk=pk)
    
    context = {
        'employee': employee,
        'page_title': f'Candidato: {employee.get_full_name()}',
        'config': SystemConfiguration.objects.first(),
        'section': 'candidates'
    }
    
    return render(request, 'tickets/candidate_detail.html', context)


@login_required
def active_employee_list(request):
    """Lista de empleados activos (estado: employee)"""
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes', 'Profesores']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('dashboard')
    
    # Filtrar por empresa del usuario
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company:
        employees = Employee.objects.filter(
            company=user_profile.company,
            status='employee'
        ).order_by('-created_at')
    else:
        employees = Employee.objects.filter(status='employee').order_by('-created_at')
    
    # Búsqueda
    search = request.GET.get('search')
    if search:
        employees = employees.filter(
            models.Q(first_name__icontains=search) |
            models.Q(last_name__icontains=search) |
            models.Q(email__icontains=search) |
            models.Q(position__icontains=search)
        )
    
    # Paginación
    paginator = Paginator(employees, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'employees': page_obj,
        'search': search,
        'page_title': 'Empleados Activos',
        'section': 'employees'
    }
    
    return render(request, 'tickets/active_employee_list.html', context)


@login_required
def active_employee_detail(request, pk):
    """Detalle de un empleado activo"""
    employee = get_object_or_404(Employee, pk=pk)
    
    # Verificar permisos
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes', 'Profesores']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('active_employee_list')
    
    # Verificar que el usuario puede ver este empleado (misma empresa)
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company and employee.company != user_profile.company:
        messages.error(request, 'No tienes permisos para ver este empleado.')
        return redirect('active_employee_list')
    
    context = {
        'employee': employee,
        'page_title': f'Empleado: {employee.get_full_name()}',
        'config': SystemConfiguration.objects.first(),
        'section': 'employees'
    }
    
    return render(request, 'tickets/active_employee_detail.html', context)


@login_required
def job_application_token_list(request):
    """Lista de tokens de aplicación de trabajo"""
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes', 'Profesores']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('dashboard')
    
    # Filtrar por empresa del usuario
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company:
        tokens = JobApplicationToken.objects.filter(company=user_profile.company).order_by('-created_at')
    else:
        tokens = JobApplicationToken.objects.all().order_by('-created_at')
    
    # Paginación
    paginator = Paginator(tokens, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_obj': page_obj,
        'page_title': 'Enlaces de Aplicación de Empleo'
    }
    
    return render(request, 'tickets/job_application_token_list.html', context)


@login_required
def job_application_token_create(request):
    """Crear nuevo token de aplicación de trabajo"""
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes', 'Profesores']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('dashboard')
    
    if request.method == 'POST':
        try:
            job_title = request.POST.get('job_title')
            job_description = request.POST.get('job_description')
            proposed_salary_euros = request.POST.get('proposed_salary_euros')
            max_applications = request.POST.get('max_applications')
            expires_at = request.POST.get('expires_at')
            
            if not job_title or not job_description:
                messages.error(request, 'El título y descripción del trabajo son obligatorios.')
                return render(request, 'tickets/job_application_token_form.html')
            
            # Obtener empresa del usuario
            user_profile = UserProfile.objects.filter(user=request.user).first()
            if not user_profile or not user_profile.company:
                messages.error(request, 'Debes estar asociado a una empresa para crear enlaces de aplicación.')
                return redirect('job_application_token_list')
            
            # Crear el token
            token = JobApplicationToken.objects.create(
                job_title=job_title,
                job_description=job_description,
                proposed_salary_euros=float(proposed_salary_euros) if proposed_salary_euros else None,
                max_applications=int(max_applications) if max_applications else None,
                expires_at=datetime.strptime(expires_at, '%Y-%m-%dT%H:%M') if expires_at else None,
                company=user_profile.company,
                created_by=request.user
            )
            
            messages.success(request, f'Enlace de aplicación creado exitosamente para "{job_title}".')
            return redirect('job_application_token_detail', pk=token.pk)
            
        except Exception as e:
            messages.error(request, f'Error al crear el enlace: {str(e)}')
    
    context = {
        'page_title': 'Crear Enlace de Aplicación de Empleo'
    }
    
    return render(request, 'tickets/job_application_token_form.html', context)


@login_required
def job_application_token_detail(request, pk):
    """Detalle de un token de aplicación de trabajo"""
    token = get_object_or_404(JobApplicationToken, pk=pk)
    
    # Verificar permisos
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes', 'Profesores']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('job_application_token_list')
    
    # Verificar que el usuario puede ver este token (misma empresa)
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company and token.company != user_profile.company:
        messages.error(request, 'No tienes permisos para ver este enlace.')
        return redirect('job_application_token_list')
    
    # Obtener aplicaciones relacionadas
    applications = Employee.objects.filter(
        company=token.company,
        created_at__gte=token.created_at
    ).order_by('-created_at')
    
    context = {
        'token': token,
        'applications': applications,
        'page_title': f'Enlace: {token.job_title}'
    }
    
    return render(request, 'tickets/job_application_token_detail.html', context)


def public_job_application(request, token):
    """Vista pública para aplicar a un empleo"""
    try:
        application_token = get_object_or_404(JobApplicationToken, application_token=token)
    except Exception:
        return render(request, 'tickets/public_job_application_error.html', {
            'error': 'El enlace de aplicación no es válido.'
        })
    
    if not application_token.is_valid():
        error_msg = 'Este enlace de aplicación ya no está disponible.'
        if application_token.expires_at and timezone.now() > application_token.expires_at:
            error_msg = 'Este enlace de aplicación ha expirado.'
        elif application_token.max_applications and application_token.application_count >= application_token.max_applications:
            error_msg = 'Este enlace ha alcanzado el máximo de aplicaciones permitidas.'
        
        return render(request, 'tickets/public_job_application_error.html', {
            'error': error_msg
        })
    
    if request.method == 'POST':
        try:
            # Obtener datos del formulario
            first_name = request.POST.get('first_name', '').strip()
            last_name = request.POST.get('last_name', '').strip()
            email = request.POST.get('email', '').strip()
            phone = request.POST.get('phone', '').strip()
            description = request.POST.get('description', '').strip()
            resume_file = request.FILES.get('resume_file')
            
            # Validaciones básicas
            if not all([first_name, last_name, email, description]):
                messages.error(request, 'Todos los campos marcados con * son obligatorios.')
                return render(request, 'tickets/public_job_application.html', {
                    'token': application_token,
                    'page_title': f'Aplicar a: {application_token.job_title}'
                })
            
            # Verificar que el email no exista ya
            if Employee.objects.filter(email=email, company=application_token.company).exists():
                messages.error(request, 'Ya existe una aplicación con este correo electrónico.')
                return render(request, 'tickets/public_job_application.html', {
                    'token': application_token,
                    'page_title': f'Aplicar a: {application_token.job_title}'
                })
            
            # Crear el empleado/aplicante
            employee = Employee.objects.create(
                first_name=first_name,
                last_name=last_name,
                email=email,
                phone=phone,
                position=application_token.job_title,
                salary_euros=application_token.proposed_salary_euros,
                description=description,
                resume_file=resume_file,
                company=application_token.company,
                status='applied'
            )
            
            # Incrementar contador de aplicaciones
            application_token.application_count += 1
            application_token.save()
            
            # Procesar CV con IA si está configurada
            try:
                analyze_resume_with_ai(employee)
            except Exception as e:
                print(f"Error al analizar CV con IA: {e}")
            
            return render(request, 'tickets/public_job_application_success.html', {
                'employee': employee,
                'token': application_token,
                'page_title': 'Aplicación Enviada'
            })
            
        except Exception as e:
            messages.error(request, f'Error al enviar la aplicación: {str(e)}')
    
    context = {
        'token': application_token,
        'page_title': f'Aplicar a: {application_token.job_title}'
    }
    
    return render(request, 'tickets/public_job_application.html', context)


def analyze_resume_with_ai(employee):
    """Analizar currículo con IA si está configurada"""
    try:
        # Obtener configuración de IA
        ai_config = SystemConfiguration.objects.first()
        if not ai_config or not hasattr(ai_config, 'openai_api_key') or not ai_config.openai_api_key:
            return
        
        # Si no hay archivo de CV, analizar solo la descripción
        content_to_analyze = employee.description
        
        if employee.resume_file:
            try:
                # Leer el contenido del archivo (solo si es texto plano o PDF simple)
                file_path = employee.resume_file.path
                if file_path.endswith('.txt'):
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content_to_analyze += f"\n\nContenido del CV:\n{f.read()}"
            except Exception:
                pass  # Si no se puede leer el archivo, solo usar la descripción
        
        if not content_to_analyze.strip():
            return
        
        # Configurar OpenAI
        import openai
        openai.api_key = ai_config.openai_api_key
        
        # Prompt para análisis de CV
        prompt = f"""
        Analiza el siguiente currículo/perfil profesional y proporciona:
        
        1. Un resumen ejecutivo del candidato (máximo 3 párrafos)
        2. Fortalezas principales
        3. Áreas de mejora o faltantes
        4. Puntuación del 1 al 10 basada en:
           - Experiencia relevante
           - Habilidades técnicas
           - Comunicación escrita
           - Potencial de crecimiento
        
        Puesto aplicado: {employee.position}
        
        Perfil del candidato:
        {content_to_analyze}
        
        Responde en formato estructurado y profesional.
        """
        
        # Llamar a la API de OpenAI
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "Eres un experto en recursos humanos y análisis de currículos."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=800,
            temperature=0.3
        )
        
        ai_analysis = response.choices[0].message.content
        
        # Extraer puntuación del análisis (buscar números del 1-10)
        import re
        score_match = re.search(r'(\d+)/10|(\d+)\s*de\s*10|puntuación.*?(\d+)', ai_analysis.lower())
        ai_score = None
        if score_match:
            for group in score_match.groups():
                if group and 1 <= int(group) <= 10:
                    ai_score = int(group)
                    break
        
        # Guardar análisis
        employee.ai_analysis = ai_analysis
        employee.ai_score = ai_score
        employee.save()
        
    except Exception as e:
        print(f"Error en análisis de IA: {e}")
        # No fallar silenciosamente, pero tampoco interrumpir el proceso


# =============================================================================
# VISTAS DE ACUERDOS/CONTRATOS
# =============================================================================

@login_required
def agreement_list(request):
    """Lista de acuerdos"""
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('dashboard')
    
    # Filtrar por empresa del usuario si es necesario
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company:
        agreements = Agreement.objects.filter(company=user_profile.company)
    else:
        agreements = Agreement.objects.all()
    
    # Filtros de búsqueda
    search = request.GET.get('search', '').strip()
    status_filter = request.GET.get('status', '')
    
    if search:
        agreements = agreements.filter(
            models.Q(title__icontains=search) |
            models.Q(body__icontains=search)
        )
    
    if status_filter:
        agreements = agreements.filter(status=status_filter)
    
    agreements = agreements.order_by('-created_at')
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(agreements, 20)
    page_number = request.GET.get('page')
    agreements = paginator.get_page(page_number)
    
    context = {
        'agreements': agreements,
        'search': search,
        'status_filter': status_filter,
        'page_title': 'Gestión de Acuerdos',
    }
    
    return render(request, 'tickets/agreement_list.html', context)


@login_required
def agreement_create(request):
    """Crear nuevo acuerdo"""
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('dashboard')
    
    if request.method == 'POST':
        form = AgreementForm(request.POST)
        if form.is_valid():
            agreement = form.save(commit=False)
            agreement.created_by = request.user
            
            # Asignar empresa del usuario
            user_profile = UserProfile.objects.filter(user=request.user).first()
            if user_profile and user_profile.company:
                agreement.company = user_profile.company
            
            # Generar contenido con IA si se solicitó
            if form.cleaned_data.get('generate_ai_content'):
                ai_content = agreement.generate_ai_content(
                    form.cleaned_data.get('ai_prompt_addition', '')
                )
                if ai_content:
                    agreement.body = ai_content
                    messages.success(request, 'Contenido generado con IA exitosamente.')
                else:
                    messages.warning(request, 'No se pudo generar contenido con IA. Verifica la configuración.')
            
            agreement.save()
            messages.success(request, f'Acuerdo "{agreement.title}" creado correctamente.')
            return redirect('agreement_detail', pk=agreement.pk)
        else:
            messages.error(request, 'Por favor, corrige los errores en el formulario.')
    else:
        form = AgreementForm()
    
    context = {
        'form': form,
        'page_title': 'Nuevo Acuerdo',
    }
    
    return render(request, 'tickets/agreement_form.html', context)


@login_required
def agreement_detail(request, pk):
    """Ver detalles de un acuerdo"""
    agreement = get_object_or_404(Agreement, pk=pk)
    
    # Verificar permisos
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('dashboard')
    
    # Verificar empresa
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company and agreement.company != user_profile.company:
        messages.error(request, 'No tienes permisos para ver este acuerdo.')
        return redirect('agreement_list')
    
    signatures = agreement.signatures.all().order_by('-signed_at')
    
    context = {
        'agreement': agreement,
        'signatures': signatures,
        'page_title': f'Acuerdo - {agreement.title}',
    }
    
    return render(request, 'tickets/agreement_detail.html', context)


@login_required
def agreement_edit(request, pk):
    """Editar acuerdo existente"""
    agreement = get_object_or_404(Agreement, pk=pk)
    
    # Verificar permisos
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('dashboard')
    
    # Verificar empresa
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company and agreement.company != user_profile.company:
        messages.error(request, 'No tienes permisos para editar este acuerdo.')
        return redirect('agreement_list')
    
    # Verificar si es editable
    if not agreement.is_editable:
        messages.error(request, 'Este acuerdo ya no se puede editar porque tiene firmas válidas.')
        return redirect('agreement_detail', pk=agreement.pk)
    
    if request.method == 'POST':
        form = AgreementForm(request.POST, instance=agreement)
        if form.is_valid():
            agreement = form.save()
            
            # Generar contenido con IA si se solicitó
            if form.cleaned_data.get('generate_ai_content'):
                ai_content = agreement.generate_ai_content(
                    form.cleaned_data.get('ai_prompt_addition', '')
                )
                if ai_content:
                    agreement.body = ai_content
                    agreement.save()
                    messages.success(request, 'Contenido actualizado con IA exitosamente.')
                else:
                    messages.warning(request, 'No se pudo generar contenido con IA.')
            
            messages.success(request, f'Acuerdo "{agreement.title}" actualizado correctamente.')
            return redirect('agreement_detail', pk=agreement.pk)
        else:
            messages.error(request, 'Por favor, corrige los errores en el formulario.')
    else:
        form = AgreementForm(instance=agreement)
    
    context = {
        'form': form,
        'agreement': agreement,
        'page_title': f'Editar - {agreement.title}',
    }
    
    return render(request, 'tickets/agreement_form.html', context)


@login_required
def agreement_delete(request, pk):
    """Eliminar acuerdo"""
    agreement = get_object_or_404(Agreement, pk=pk)
    
    # Verificar permisos
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('dashboard')
    
    # Verificar empresa
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company and agreement.company != user_profile.company:
        messages.error(request, 'No tienes permisos para eliminar este acuerdo.')
        return redirect('agreement_list')
    
    if request.method == 'POST':
        title = agreement.title
        agreement.delete()
        messages.success(request, f'Acuerdo "{title}" eliminado correctamente.')
        return redirect('agreement_list')
    
    context = {
        'agreement': agreement,
        'page_title': f'Eliminar - {agreement.title}',
    }
    
    return render(request, 'tickets/agreement_delete.html', context)


@login_required
def agreement_publish(request, pk):
    """Publicar acuerdo para firma"""
    agreement = get_object_or_404(Agreement, pk=pk)
    
    # Verificar permisos
    if not request.user.groups.filter(name__in=['Administradores', 'Agentes']).exists():
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('dashboard')
    
    # Verificar empresa
    user_profile = UserProfile.objects.filter(user=request.user).first()
    if user_profile and user_profile.company and agreement.company != user_profile.company:
        messages.error(request, 'No tienes permisos para publicar este acuerdo.')
        return redirect('agreement_list')
    
    if request.method == 'POST':
        form = AgreementPublicForm(request.POST)
        if form.is_valid():
            agreement.status = 'published'
            agreement.published_at = timezone.now()
            agreement.save()
            
            messages.success(request, f'Acuerdo "{agreement.title}" publicado correctamente.')
            messages.info(request, f'URL pública: {agreement.get_public_url(request)}')
            
            # TODO: Enviar notificaciones por email si está configurado
            email_list = form.cleaned_data.get('email_list', [])
            if email_list and form.cleaned_data.get('send_notifications'):
                # Implementar envío de emails
                pass
            
            return redirect('agreement_detail', pk=agreement.pk)
        else:
            messages.error(request, 'Por favor, corrige los errores en el formulario.')
    else:
        form = AgreementPublicForm()
    
    context = {
        'form': form,
        'agreement': agreement,
        'page_title': f'Publicar - {agreement.title}',
    }
    
    return render(request, 'tickets/agreement_publish.html', context)


# =============================================================================
# VISTAS PÚBLICAS DE ACUERDOS (SIN LOGIN)
# =============================================================================

def public_agreement_sign(request, token):
    """Vista pública para firmar un acuerdo"""
    agreement = get_object_or_404(Agreement, public_token=token)
    
    # Verificar si el acuerdo puede ser firmado
    if not agreement.can_be_signed:
        error_msg = "Este acuerdo no está disponible para firmar."
        if agreement.status != 'published':
            error_msg = "Este acuerdo aún no ha sido publicado."
        elif agreement.is_expired:
            error_msg = "Este acuerdo ha expirado."
        elif agreement.max_signers and agreement.signature_count >= agreement.max_signers:
            error_msg = "Este acuerdo ha alcanzado el número máximo de firmantes."
        
        context = {
            'agreement': agreement,
            'error_message': error_msg,
            'page_title': f'Acuerdo - {agreement.title}',
        }
        return render(request, 'tickets/public_agreement_error.html', context)
    
    if request.method == 'POST':
        form = AgreementSignatureForm(request.POST)
        form.agreement = agreement  # Para validaciones
        
        if form.is_valid():
            signature = form.save(commit=False)
            signature.agreement = agreement
            
            # Capturar información adicional
            signature.ip_address = request.META.get('REMOTE_ADDR')
            signature.user_agent = request.META.get('HTTP_USER_AGENT', '')
            
            # Si el acuerdo requiere aprobación, marcar como no aprobado
            if agreement.requires_approval:
                signature.is_approved = False
            
            signature.save()
            
            messages.success(request, '¡Acuerdo firmado correctamente!')
            return redirect('public_agreement_success', token=token, signature_id=signature.pk)
        else:
            messages.error(request, 'Por favor, corrige los errores en el formulario.')
    else:
        form = AgreementSignatureForm()
    
    context = {
        'agreement': agreement,
        'form': form,
        'signatures_count': agreement.signature_count,
        'page_title': f'Firmar - {agreement.title}',
    }
    
    return render(request, 'tickets/public_agreement_sign.html', context)


def public_agreement_success(request, token, signature_id):
    """Vista de confirmación después de firmar"""
    agreement = get_object_or_404(Agreement, public_token=token)
    signature = get_object_or_404(AgreementSignature, pk=signature_id, agreement=agreement)
    
    context = {
        'agreement': agreement,
        'signature': signature,
        'download_url': signature.get_download_url(request),
        'page_title': f'Firmado - {agreement.title}',
    }
    
    return render(request, 'tickets/public_agreement_success.html', context)


def download_signed_agreement(request, agreement_token, signature_id):
    """Descargar PDF del acuerdo firmado"""
    agreement = get_object_or_404(Agreement, public_token=agreement_token)
    signature = get_object_or_404(AgreementSignature, pk=signature_id, agreement=agreement)
    
    # Actualizar estadísticas de descarga
    signature.pdf_downloaded_at = timezone.now()
    signature.download_count += 1
    signature.save()
    
    # Generar PDF del acuerdo firmado
    from django.http import HttpResponse
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import letter
    from reportlab.lib.styles import getSampleStyleSheet
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
    from io import BytesIO
    
    # Crear PDF en memoria
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter)
    styles = getSampleStyleSheet()
    story = []
    
    # Título
    title = Paragraph(f"<b>{agreement.title}</b>", styles['Title'])
    story.append(title)
    story.append(Spacer(1, 20))
    
    # Contenido del acuerdo
    body_paragraphs = agreement.body.split('\n')
    for para in body_paragraphs:
        if para.strip():
            p = Paragraph(para, styles['Normal'])
            story.append(p)
            story.append(Spacer(1, 10))
    
    # Información de la firma
    story.append(Spacer(1, 30))
    story.append(Paragraph("<b>INFORMACIÓN DE LA FIRMA:</b>", styles['Heading2']))
    story.append(Spacer(1, 10))
    
    signature_info = f"""
    <b>Firmante:</b> {signature.signer_name}<br/>
    <b>Email:</b> {signature.signer_email}<br/>
    <b>Fecha de Firma:</b> {signature.signed_at.strftime('%d/%m/%Y %H:%M')}<br/>
    <b>IP:</b> {signature.ip_address or 'No disponible'}<br/>
    """
    
    story.append(Paragraph(signature_info, styles['Normal']))
    
    # Construir PDF
    doc.build(story)
    
    # Preparar respuesta
    buffer.seek(0)
    response = HttpResponse(buffer.getvalue(), content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="{agreement.title}_firmado_{signature.signer_name}.pdf"'
    
    return response


# =============================================================================
# VISTAS PARA LANDING PAGES
# =============================================================================

def is_agent_or_superuser(user):
    """
    Verifica si un usuario es agente o superusuario
    """
    if not user.is_authenticated:
        return False
    return user.is_superuser or is_agent(user)

@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def landing_page_list(request):
    """Vista para listar todas las landing pages"""
    landing_pages = LandingPage.objects.all().order_by('-created_at')
    
    context = {
        'page_title': 'Landing Pages',
        'landing_pages': landing_pages,
    }
    
    return render(request, 'tickets/landing_page_list.html', context)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def landing_page_create(request):
    """Vista para crear una nueva landing page"""
    if request.method == 'POST':
        form = LandingPageForm(request.POST, request.FILES)
        if form.is_valid():
            landing_page = form.save(commit=False)
            landing_page.created_by = request.user
            landing_page.save()
            messages.success(request, 'Landing Page creada exitosamente.')
            return redirect('landing_page_detail', pk=landing_page.pk)
        else:
            # Agregar errores del formulario a los mensajes
            for field, errors in form.errors.items():
                for error in errors:
                    messages.error(request, f'Error en {field}: {error}')
    else:
        form = LandingPageForm()
    
    context = {
        'page_title': 'Crear Landing Page',
        'form': form,
    }
    
    return render(request, 'tickets/landing_page_form.html', context)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
@login_required
@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def landing_page_detail(request, pk):
    """Vista para ver detalles de una landing page"""
    landing_page = get_object_or_404(LandingPage, pk=pk)
    # Solo mostrar submissions que no han sido procesadas (pendientes por contactar)
    submissions = landing_page.submissions.filter(processed=False).order_by('-created_at')[:20]
    
    context = {
        'page_title': f'Landing Page: {landing_page.nombre_producto}',
        'landing_page': landing_page,
        'submissions': submissions,
    }
    
    return render(request, 'tickets/landing_page_detail.html', context)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def landing_page_edit(request, pk):
    """Vista para editar una landing page"""
    landing_page = get_object_or_404(LandingPage, pk=pk)
    
    if request.method == 'POST':
        form = LandingPageForm(request.POST, request.FILES, instance=landing_page)
        if form.is_valid():
            form.save()
            messages.success(request, 'Landing Page actualizada exitosamente.')
            return redirect('landing_page_detail', pk=landing_page.pk)
    else:
        form = LandingPageForm(instance=landing_page)
    
    context = {
        'page_title': f'Editar Landing Page: {landing_page.nombre_producto}',
        'form': form,
        'landing_page': landing_page,
    }
    
    return render(request, 'tickets/landing_page_form.html', context)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def landing_page_delete(request, pk):
    """Vista para eliminar una landing page"""
    landing_page = get_object_or_404(LandingPage, pk=pk)
    
    if request.method == 'POST':
        landing_page.delete()
        messages.success(request, 'Landing Page eliminada exitosamente.')
        return redirect('landing_page_list')
    
    context = {
        'page_title': f'Eliminar Landing Page: {landing_page.nombre_producto}',
        'landing_page': landing_page,
    }
    
    return render(request, 'tickets/landing_page_delete.html', context)


def landing_page_public(request, slug):
    """Vista pública de la landing page"""
    landing_page = get_object_or_404(LandingPage, slug=slug, is_active=True)
    
    # Incrementar contador de visitas
    landing_page.increment_views()
    
    if request.method == 'POST':
        form = LandingPageSubmissionForm(request.POST)
        if form.is_valid():
            submission = form.save(commit=False)
            submission.landing_page = landing_page
            
            # Capturar información adicional
            x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
            if x_forwarded_for:
                submission.ip_address = x_forwarded_for.split(',')[0]
            else:
                submission.ip_address = request.META.get('REMOTE_ADDR')
            
            submission.user_agent = request.META.get('HTTP_USER_AGENT', '')
            submission.utm_source = request.GET.get('utm_source', '')
            submission.utm_medium = request.GET.get('utm_medium', '')
            submission.utm_campaign = request.GET.get('utm_campaign', '')
            
            submission.save()
            
            # Crear contacto web automáticamente
            try:
                # En vista pública no hay usuario logueado, así que created_by será None
                contact = create_contact_from_submission(submission, landing_page, created_by=None)
                
                # Enviar notificación de creación de contacto
                try:
                    from .utils import send_contact_creation_notification
                    send_contact_creation_notification(contact, landing_page)
                except Exception as e:
                    import logging
                    logger = logging.getLogger(__name__)
                    logger.error(f"Error enviando notificación de contacto: {str(e)}")
                    
            except Exception as e:
                import logging
                logger = logging.getLogger(__name__)
                logger.error(f"Error creando contacto desde landing page: {str(e)}")
            
            # Incrementar contador de envíos
            landing_page.increment_submissions()
            
            # Enviar notificación por email si está configurada
            try:
                from .utils import send_landing_page_notification
                send_landing_page_notification(submission)
            except Exception as e:
                import logging
                logger = logging.getLogger(__name__)
                logger.error(f"Error enviando notificación de landing page: {str(e)}")
            
            # Enviar notificación por Telegram si está configurada
            try:
                from .utils import send_telegram_notification
                send_telegram_notification(landing_page, submission)
            except Exception as e:
                import logging
                logger = logging.getLogger(__name__)
                logger.error(f"Error enviando notificación de Telegram: {str(e)}")
            
            # Redirigir a página de gracias
            return render(request, 'tickets/landing_page_thanks.html', {
                'landing_page': landing_page,
                'submission': submission,
            })
    else:
        form = LandingPageSubmissionForm()
    
    context = {
        'landing_page': landing_page,
        'form': form,
    }
    
    return render(request, 'tickets/landing_page_public.html', context)


def create_contact_from_submission(submission, landing_page, created_by=None):
    """Crear un contacto desde un envío de landing page"""
    from .models import Contact
    from django.contrib.auth.models import User
    
    # Si no hay usuario logueado, usar un usuario sistema
    if created_by is None:
        # Buscar o crear un usuario sistema para contacts automáticos
        system_user, created = User.objects.get_or_create(
            username='system_landing_pages',
            defaults={
                'first_name': 'Sistema',
                'last_name': 'Landing Pages',
                'email': 'system@landingpages.local',
                'is_active': False  # Usuario inactivo para que no pueda loguearse
            }
        )
        created_by = system_user
    
    # Verificar si ya existe un contacto con el mismo email
    existing_contact = Contact.objects.filter(
        email=submission.email
    ).first()
    
    # Preparar notas con información del landing page y mensaje del usuario
    notas_base = f"Contacto generado desde landing page: {landing_page.nombre_producto}\n\n"
    
    # Agregar mensaje del usuario si existe
    if hasattr(submission, 'mensaje') and submission.mensaje:
        notas_base += f"Mensaje del cliente:\n{submission.mensaje}\n\n"
    
    # Agregar información de seguimiento
    notas_base += f"Datos de seguimiento:\n" \
                  f"- UTM Source: {submission.utm_source or 'N/A'}\n" \
                  f"- UTM Medium: {submission.utm_medium or 'N/A'}\n" \
                  f"- UTM Campaign: {submission.utm_campaign or 'N/A'}\n" \
                  f"- IP Address: {submission.ip_address or 'N/A'}\n" \
                  f"- Fecha de envío: {submission.created_at.strftime('%d/%m/%Y %H:%M')}"
    
    if existing_contact:
        # Actualizar el contacto existente con nueva información
        existing_contact.name = f"{submission.nombre} {submission.apellido}".strip()
        if submission.telefono:
            existing_contact.phone = submission.telefono
        if submission.empresa:
            existing_contact.company = submission.empresa
        existing_contact.source = f"Landing Page: {landing_page.nombre_producto}"
        existing_contact.notes = notas_base
        existing_contact.status = 'positive'  # Nuevo lead es positivo
        existing_contact.save()
        
        return existing_contact
    else:
        # Crear nuevo contacto
        contact = Contact.objects.create(
            name=f"{submission.nombre} {submission.apellido}".strip(),
            email=submission.email,
            phone=submission.telefono or '',
            company=submission.empresa or '',
            source=f"Landing Page: {landing_page.nombre_producto}",
            notes=notas_base,
            status='positive',  # Nuevo lead es positivo por defecto
            created_by=created_by  # Asignar el usuario que creó el contacto
        )
        
        return contact


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def landing_page_submissions(request, pk):
    """Vista para ver todos los envíos de una landing page"""
    landing_page = get_object_or_404(LandingPage, pk=pk)
    submissions = landing_page.submissions.all().order_by('-created_at')
    
    # Agregar información de contactos existentes
    from .models import Contact
    for submission in submissions:
        # Buscar contacto existente por email
        existing_contact = Contact.objects.filter(
            email=submission.email
        ).first()
        submission.existing_contact = existing_contact
    
    context = {
        'page_title': f'Envíos: {landing_page.nombre_producto}',
        'landing_page': landing_page,
        'submissions': submissions,
    }
    
    return render(request, 'tickets/landing_page_submissions.html', context)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def landing_page_submission_detail(request, submission_id):
    """Vista para ver los detalles de un envío específico de landing page"""
    from .models import LandingPageSubmission, Contact
    
    submission = get_object_or_404(LandingPageSubmission, pk=submission_id)
    
    # Buscar contacto existente por email
    existing_contact = Contact.objects.filter(
        email=submission.email
    ).first()
    
    context = {
        'page_title': f'Detalle del Envío #{submission.id}',
        'submission': submission,
        'landing_page': submission.landing_page,
        'existing_contact': existing_contact,
    }
    
    return render(request, 'tickets/landing_page_submission_detail.html', context)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def create_contact_from_submission_view(request, submission_id):
    """Vista para crear un contacto manualmente desde un envío de landing page"""
    from .models import LandingPageSubmission
    
    submission = get_object_or_404(LandingPageSubmission, pk=submission_id)
    
    if request.method == 'POST':
        try:
            contact = create_contact_from_submission(submission, submission.landing_page, created_by=request.user)
            messages.success(request, f'Contacto creado exitosamente para {contact.name}')
            
            # Enviar notificación
            try:
                from .utils import send_contact_creation_notification
                send_contact_creation_notification(contact, submission.landing_page)
            except Exception as e:
                messages.warning(request, 'Contacto creado pero no se pudo enviar la notificación por email.')
                
        except Exception as e:
            messages.error(request, f'Error al crear el contacto: {str(e)}')
    
    return redirect('landing_page_submissions', pk=submission.landing_page.pk)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def toggle_submission_processed(request, submission_id):
    """Vista AJAX para marcar/desmarcar un envío de landing page como procesado/contactado"""
    # Verificar si es una petición AJAX y si el usuario está autenticado
    if not request.user.is_authenticated:
        return JsonResponse({
            'success': False,
            'error': 'No autorizado - debe iniciar sesión'
        }, status=401)
    
    if not is_agent_or_superuser(request.user):
        return JsonResponse({
            'success': False,
            'error': 'No tiene permisos para realizar esta acción'
        }, status=403)
    
    if request.method == 'POST':
        try:
            submission = get_object_or_404(LandingPageSubmission, pk=submission_id)
            
            # Obtener el nuevo estado desde el request y debug
            processed_value = request.POST.get('processed', 'false')
            new_processed_state = processed_value.lower() == 'true'
            
            print(f"DEBUG toggle_submission_processed:")
            print(f"  - submission_id: {submission_id}")
            print(f"  - processed_value recibido: '{processed_value}'")
            print(f"  - new_processed_state: {new_processed_state}")
            print(f"  - estado actual: {submission.processed}")
            
            # Actualizar el estado
            submission.processed = new_processed_state
            if new_processed_state:
                submission.processed_at = timezone.now()
                submission.processed_by = request.user
            else:
                submission.processed_at = None
                submission.processed_by = None
            
            submission.save()
            
            print(f"  - estado después de guardar: {submission.processed}")
            
            return JsonResponse({
                'success': True,
                'processed': submission.processed,
                'processed_at': submission.processed_at.isoformat() if submission.processed_at else None,
                'processed_by': submission.processed_by.get_full_name() if submission.processed_by else None,
                'message': 'Estado actualizado correctamente'
            })
            
        except Exception as e:
            return JsonResponse({
                'success': False,
                'error': str(e)
            }, status=400)
    
    return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def update_contact_tracking(request, submission_id):
    """Vista para actualizar el seguimiento de contacto de un envío"""
    from .models import LandingPageSubmission
    from django.utils import timezone
    from datetime import datetime
    
    if request.method == 'POST':
        try:
            submission = get_object_or_404(LandingPageSubmission, pk=submission_id)
            
            # Obtener datos del formulario
            contacted_by_phone = request.POST.get('contacted_by_phone') == 'on'
            contacted_by_web = request.POST.get('contacted_by_web') == 'on'
            contact_notes = request.POST.get('contact_notes', '')
            contact_date_str = request.POST.get('contact_date', '')
            
            # Actualizar campos
            submission.contacted_by_phone = contacted_by_phone
            submission.contacted_by_web = contacted_by_web
            submission.contact_notes = contact_notes
            
            # Procesar fecha de contacto
            if contact_date_str:
                try:
                    # Convertir datetime-local format a datetime object
                    contact_datetime = datetime.strptime(contact_date_str, '%Y-%m-%dT%H:%M')
                    submission.contact_date = timezone.make_aware(contact_datetime)
                except ValueError:
                    pass  # Si no se puede parsear, mantener el valor anterior
            
            submission.save()
            
            return JsonResponse({
                'success': True,
                'message': 'Seguimiento de contacto actualizado correctamente',
                'contacted_by_phone': submission.contacted_by_phone,
                'contacted_by_web': submission.contacted_by_web,
                'contact_date': submission.contact_date.isoformat() if submission.contact_date else None,
                'contact_notes': submission.contact_notes
            })
            
        except Exception as e:
            return JsonResponse({
                'success': False,
                'error': f'Error al actualizar seguimiento: {str(e)}'
            }, status=400)
    
    return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def landing_page_contacts(request):
    """Vista para ver todos los contactos creados desde landing pages"""
    from .models import Contact
    
    # Filtrar contactos que contienen "landing page" en la fuente o notas
    contacts = Contact.objects.filter(
        models.Q(source__icontains='landing page') |
        models.Q(notes__icontains='landing page')
    ).order_by('-created_at')
    
    # Estadísticas
    total_contacts = contacts.count()
    positive_contacts = contacts.filter(status='positive').count()
    negative_contacts = contacts.filter(status='negative').count()
    
    context = {
        'page_title': 'Contactos desde Landing Pages',
        'contacts': contacts,
        'total_contacts': total_contacts,
        'positive_contacts': positive_contacts,
        'negative_contacts': negative_contacts,
    }
    
    return render(request, 'tickets/landing_page_contacts.html', context)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def ajax_create_contact_from_submission(request, submission_id):
    """Vista AJAX para crear un contacto desde un envío"""
    if request.method == 'POST':
        try:
            from .models import LandingPageSubmission
            submission = get_object_or_404(LandingPageSubmission, pk=submission_id)
            
            contact = create_contact_from_submission(submission, submission.landing_page, created_by=request.user)
            
            if not contact:
                return JsonResponse({
                    'success': False,
                    'message': 'No se pudo crear el contacto'
                })
            
            # Verificar si es un contacto nuevo o actualizado
            from .models import ContactoWeb
            existing_contact_count = ContactoWeb.objects.filter(email=submission.email).count()
            
            if existing_contact_count > 1:
                message = f'Contacto actualizado para {contact.name} ({contact.email})'
            else:
                message = f'Contacto creado exitosamente para {contact.name}'
            
            # Log para debugging
            import logging
            logger = logging.getLogger(__name__)
            logger.info(f"Contacto procesado: {message}")
            
            # Enviar notificación (opcional)
            try:
                from .utils import send_contact_creation_notification
                send_contact_creation_notification(contact, submission.landing_page)
            except Exception as e:
                logger.warning(f"Error enviando notificación de contacto: {str(e)}")
            
            response_data = {
                'success': True,
                'message': message,
                'contact_id': contact.id
            }
            
            logger.info(f"Enviando respuesta: {response_data}")
            return JsonResponse(response_data)
            
        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f"Error creando contacto desde submission {submission_id}: {str(e)}")
            
            return JsonResponse({
                'success': False,
                'message': f'Error al crear el contacto: {str(e)}'
            })
    
    return JsonResponse({'success': False, 'message': 'Método no permitido'})


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def ajax_create_contacts_batch(request):
    """Vista AJAX para crear contactos en lote desde múltiples envíos"""
    if request.method == 'POST':
        try:
            import json
            data = json.loads(request.body)
            submission_ids = data.get('submission_ids', [])
            
            if not submission_ids:
                return JsonResponse({'success': False, 'message': 'No se seleccionaron envíos'})
            
            from .models import LandingPageSubmission
            contacts_created = 0
            errors = []
            
            for submission_id in submission_ids:
                try:
                    submission = LandingPageSubmission.objects.get(pk=submission_id)
                    contact = create_contact_from_submission(submission, submission.landing_page, created_by=request.user)
                    if contact:
                        contacts_created += 1
                except Exception as e:
                    errors.append(f'Error en envío {submission_id}: {str(e)}')
            
            return JsonResponse({
                'success': True,
                'message': f'Se crearon {contacts_created} contactos exitosamente',
                'contacts_created': contacts_created,
                'errors': errors
            })
            
        except Exception as e:
            return JsonResponse({
                'success': False,
                'message': f'Error en la operación: {str(e)}'
            })
    
    return JsonResponse({'success': False, 'message': 'Método no permitido'})


@login_required  
@user_passes_test(is_agent_or_superuser, login_url='/')
def ajax_submission_details(request, submission_id):
    """Vista AJAX para obtener detalles de un envío"""
    try:
        from .models import LandingPageSubmission
        submission = get_object_or_404(LandingPageSubmission, pk=submission_id)
        
        data = {
            'success': True,
            'submission': {
                'id': submission.id,
                'nombre': submission.nombre,
                'apellido': submission.apellido,
                'email': submission.email,
                'telefono': submission.telefono or '',
                'empresa': submission.empresa or '',
                'ip_address': submission.ip_address or '',
                'user_agent': submission.user_agent or '',
                'utm_source': submission.utm_source or '',
                'utm_medium': submission.utm_medium or '',
                'utm_campaign': submission.utm_campaign or '',
                'created_at': submission.created_at.strftime('%d/%m/%Y %H:%M:%S'),
                'landing_page': submission.landing_page.nombre_producto
            }
        }
        
        return JsonResponse(data)
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'message': f'Error al obtener detalles: {str(e)}'
        })


@require_http_methods(["DELETE"])
@login_required
def ajax_landing_submission_delete(request, submission_id):
    """Vista AJAX para eliminar un envío de landing page - Solo para agentes"""
    if not is_agent(request.user):
        return JsonResponse({
            'success': False,
            'message': 'No tienes permisos para realizar esta acción.'
        }, status=403)
    
    try:
        from .models import LandingPageSubmission
        submission = get_object_or_404(LandingPageSubmission, pk=submission_id)
        
        # Guardar información para el mensaje de confirmación
        submission_info = f"{submission.nombre} {submission.apellido} ({submission.email})"
        
        # Eliminar el envío
        submission.delete()
        
        return JsonResponse({
            'success': True,
            'message': f'Envío de {submission_info} eliminado correctamente.'
        })
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'message': f'Error al eliminar el envío: {str(e)}'
        }, status=500)


def public_company_ticket_create(request, public_token):
    """Vista pública para crear tickets desde una empresa usando su token público"""
    try:
        company = get_object_or_404(Company, public_token=public_token, is_active=True)
    except (Company.DoesNotExist, ValueError):
        return render(request, 'tickets/public_company_ticket_error.html', {
            'error_message': 'Esta empresa no existe o no tiene habilitada la creación pública de tickets.'
        })
    
    if request.method == 'POST':
        form = PublicCompanyTicketForm(request.POST, company=company)
        if form.is_valid():
            try:
                # Crear o obtener usuario del sistema para tickets públicos
                system_user, created = User.objects.get_or_create(
                    username='system_public_tickets',
                    defaults={
                        'email': 'system@ticketproo.com',
                        'first_name': 'Sistema',
                        'last_name': 'Tickets Públicos',
                        'is_active': True,
                    }
                )
                
                # Crear el ticket
                ticket = form.save(commit=False)
                ticket.created_by = system_user
                ticket.ticket_type = 'desarrollo'  # Tipo por defecto para tickets públicos
                ticket.status = 'open'
                ticket.save()
                
                return render(request, 'tickets/public_company_ticket_success.html', {
                    'ticket': ticket,
                    'company': company,
                    'customer_name': form.cleaned_data['customer_name'],
                    'customer_email': form.cleaned_data['customer_email'],
                })
                
            except Exception as e:
                form.add_error(None, f'Error al crear el ticket: {str(e)}')
    else:
        form = PublicCompanyTicketForm(company=company)
    
    return render(request, 'tickets/public_company_ticket_create.html', {
        'form': form,
        'company': company,
    })


# ===========================================
# VISTAS PARA TAREAS DE ÓRDENES DE TRABAJO
# ===========================================

@login_required
@user_passes_test(is_agent, login_url='/')
def work_order_task_list_view(request, work_order_pk):
    """Vista para listar tareas de una orden de trabajo"""
    work_order = get_object_or_404(WorkOrder, pk=work_order_pk)
    tasks = work_order.tasks.all().order_by('order', 'created_at')
    
    context = {
        'work_order': work_order,
        'tasks': tasks,
        'page_title': f'Tareas - {work_order.order_number}',
        'total_estimated_hours': sum(task.estimated_hours or 0 for task in tasks),
        'total_logged_hours': work_order.get_total_hours_logged(),
        'progress_percentage': work_order.get_progress_percentage(),
    }
    
    return render(request, 'tickets/work_order_task_list.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def work_order_task_create_view(request, work_order_pk):
    """Vista para crear una nueva tarea en una orden de trabajo"""
    work_order = get_object_or_404(WorkOrder, pk=work_order_pk)
    
    if request.method == 'POST':
        from .forms import WorkOrderTaskForm
        form = WorkOrderTaskForm(request.POST)
        if form.is_valid():
            task = form.save(commit=False)
            task.work_order = work_order
            task.created_by = request.user
            task.save()
            messages.success(request, f'Tarea "{task.title}" creada exitosamente.')
            return redirect('work_order_task_list', work_order_pk=work_order.pk)
    else:
        from .forms import WorkOrderTaskForm
        form = WorkOrderTaskForm()
    
    context = {
        'form': form,
        'work_order': work_order,
        'page_title': f'Nueva Tarea - {work_order.order_number}'
    }
    
    return render(request, 'tickets/work_order_task_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def work_order_task_edit_view(request, work_order_pk, task_pk):
    """Vista para editar una tarea"""
    work_order = get_object_or_404(WorkOrder, pk=work_order_pk)
    from .models import WorkOrderTask
    task = get_object_or_404(WorkOrderTask, pk=task_pk, work_order=work_order)
    
    if request.method == 'POST':
        from .forms import WorkOrderTaskForm
        form = WorkOrderTaskForm(request.POST, instance=task)
        if form.is_valid():
            form.save()
            messages.success(request, f'Tarea "{task.title}" actualizada exitosamente.')
            return redirect('work_order_task_list', work_order_pk=work_order.pk)
    else:
        from .forms import WorkOrderTaskForm
        form = WorkOrderTaskForm(instance=task)
    
    context = {
        'form': form,
        'work_order': work_order,
        'task': task,
        'page_title': f'Editar Tarea - {task.title}'
    }
    
    return render(request, 'tickets/work_order_task_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def work_order_task_delete_view(request, work_order_pk, task_pk):
    """Vista para eliminar una tarea"""
    work_order = get_object_or_404(WorkOrder, pk=work_order_pk)
    from .models import WorkOrderTask
    task = get_object_or_404(WorkOrderTask, pk=task_pk, work_order=work_order)
    
    if request.method == 'POST':
        title = task.title
        task.delete()
        messages.success(request, f'Tarea "{title}" eliminada exitosamente.')
        return redirect('work_order_task_list', work_order_pk=work_order.pk)
    
    context = {
        'work_order': work_order,
        'task': task,
        'page_title': f'Eliminar Tarea - {task.title}'
    }
    
    return render(request, 'tickets/work_order_task_delete.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def work_order_task_bulk_create_view(request, work_order_pk):
    """Vista para crear múltiples tareas de una vez"""
    work_order = get_object_or_404(WorkOrder, pk=work_order_pk)
    
    if request.method == 'POST':
        from .forms import WorkOrderTaskBulkForm
        form = WorkOrderTaskBulkForm(request.POST)
        if form.is_valid():
            tasks_text = form.cleaned_data['tasks_text']
            tasks_created = 0
            
            for i, line in enumerate(tasks_text.strip().split('\n')):
                line = line.strip()
                if line:
                    from .models import WorkOrderTask
                    WorkOrderTask.objects.create(
                        work_order=work_order,
                        title=line,
                        description=f'Tarea creada automáticamente',
                        status='pending',
                        order=i + 1,
                        created_by=request.user
                    )
                    tasks_created += 1
            
            messages.success(request, f'{tasks_created} tareas creadas exitosamente.')
            return redirect('work_order_task_list', work_order_pk=work_order.pk)
    else:
        from .forms import WorkOrderTaskBulkForm
        form = WorkOrderTaskBulkForm()
    
    context = {
        'form': form,
        'work_order': work_order,
        'page_title': f'Crear Tareas Múltiples - {work_order.order_number}'
    }
    
    return render(request, 'tickets/work_order_task_bulk_form.html', context)


def work_order_task_status_update_view(request, work_order_pk, task_pk):
    """Vista AJAX para actualizar el estado de una tarea"""
    if request.method == 'POST':
        work_order = get_object_or_404(WorkOrder, pk=work_order_pk)
        from .models import WorkOrderTask
        task = get_object_or_404(WorkOrderTask, pk=task_pk, work_order=work_order)
        
        new_status = request.POST.get('status')
        
        if new_status in ['pending', 'in_progress', 'completed']:
            old_status = task.get_status_display()
            task.status = new_status
            
            # Si se marca como completada, establecer fecha de finalización
            if new_status == 'completed':
                task.completed_at = timezone.now()
            elif new_status == 'in_progress':
                task.started_at = timezone.now()
                task.completed_at = None
            else:  # pending
                task.started_at = None
                task.completed_at = None
            
            task.save()
            
            new_status_display = task.get_status_display()
            
            return JsonResponse({
                'success': True,
                'message': f'Estado actualizado a "{new_status_display}"',
                'new_status': new_status,
                'new_status_display': new_status_display,
                'progress_percentage': work_order.get_progress_percentage()
            })
        
        return JsonResponse({
            'success': False,
            'error': 'Estado inválido'
        })
    
    return JsonResponse({'success': False, 'error': 'Método no permitido'})


def work_order_task_time_start_view(request, work_order_pk, task_pk):
    """Vista para iniciar el tiempo de una tarea"""
    print(f"=== INICIO work_order_task_time_start_view ===")
    print(f"work_order_pk={work_order_pk}, task_pk={task_pk}, method={request.method}")
    print(f"User: {request.user}")
    
    if request.method == 'POST':
        try:
            work_order = get_object_or_404(WorkOrder, pk=work_order_pk)
            print(f"Work order encontrada: {work_order.order_number}")
            
            from .models import WorkOrderTask, WorkOrderTaskTimeSession
            task = get_object_or_404(WorkOrderTask, pk=task_pk, work_order=work_order)
            print(f"Tarea encontrada: {task.title}, Estado: {task.status}")
            
            # Verificar si ya hay una sesión activa para este usuario
            active_session = task.get_active_time_session(request.user)
            print(f"Sesión activa existente: {active_session}")
            
            if active_session:
                print(f"Ya existe una sesión activa: {active_session}")
                return JsonResponse({
                    'success': False,
                    'error': 'Ya tienes una sesión de tiempo activa para esta tarea'
                })
            
            # Crear nueva sesión de tiempo
            print("Creando nueva sesión...")
            session = WorkOrderTaskTimeSession.objects.create(
                task=task,
                user=request.user
            )
            print(f"Sesión creada exitosamente: {session} (ID: {session.id})")
            
            # Actualizar estado de la tarea a "en progreso" si está pendiente
            if task.status == 'pending':
                task.status = 'in_progress'
                task.started_at = timezone.now()
                task.save()
                print(f"Tarea actualizada a 'in_progress'")
            
            response_data = {
                'success': True,
                'message': 'Tiempo iniciado correctamente',
                'session_id': session.id,
                'started_at': session.start_time.strftime('%H:%M:%S')
            }
            print(f"Enviando respuesta exitosa: {response_data}")
            return JsonResponse(response_data)
            
        except Exception as e:
            print(f"ERROR EXCEPCIÓN: {type(e).__name__}: {e}")
            import traceback
            traceback.print_exc()
            return JsonResponse({
                'success': False,
                'error': f'Error interno: {str(e)}'
            })
    
    print("Método no es POST, enviando error")
    return JsonResponse({'success': False, 'error': 'Método no permitido'})


def work_order_task_time_stop_view(request, work_order_pk, task_pk):
    """Vista para detener el tiempo de una tarea"""
    if request.method == 'POST':
        work_order = get_object_or_404(WorkOrder, pk=work_order_pk)
        from .models import WorkOrderTask
        task = get_object_or_404(WorkOrderTask, pk=task_pk, work_order=work_order)
        
        # Buscar sesión activa para este usuario
        active_session = task.get_active_time_session(request.user)
        if not active_session:
            return JsonResponse({
                'success': False,
                'error': 'No hay una sesión de tiempo activa para esta tarea'
            })
        
        # Obtener descripción opcional del POST
        description = request.POST.get('description', '')
        
        # Detener la sesión
        time_entry = active_session.stop_session(description)
        
        if time_entry:
            return JsonResponse({
                'success': True,
                'message': f'Tiempo registrado: {time_entry.hours}h',
                'total_time': task.get_total_time_logged(),
                'session_duration': active_session.get_duration_hours()
            })
        else:
            return JsonResponse({
                'success': False,
                'error': 'Error al registrar el tiempo'
            })
    
    return JsonResponse({'success': False, 'error': 'Método no permitido'})


def work_order_public_task_view(request, token):
    """Vista pública para tareas de órdenes de trabajo compartidas"""
    work_order = get_object_or_404(WorkOrder, public_share_token=token, is_public=True)
    tasks = work_order.tasks.all().order_by('order', 'created_at')
    
    # Manejar actualización de estado de tarea por POST
    if request.method == 'POST':
        task_id = request.POST.get('task_id')
        new_status = request.POST.get('status')
        
        if task_id and new_status in ['pending', 'in_progress', 'completed']:
            from .models import WorkOrderTask
            try:
                task = WorkOrderTask.objects.get(id=task_id, work_order=work_order)
                old_status = task.get_status_display()
                task.status = new_status
                
                # Actualizar fechas según el estado
                if new_status == 'completed':
                    task.completed_at = timezone.now()
                    
                    # Si la tarea se marca como completada y no tiene tiempo registrado,
                    # calcular tiempo basado en started_at y completed_at
                    if task.get_total_time_logged() == 0 and task.started_at:
                        from .models import WorkOrderTaskTimeEntry
                        from decimal import Decimal
                        
                        # Calcular duración en horas
                        duration = task.completed_at - task.started_at
                        hours = Decimal(str(duration.total_seconds() / 3600))
                        
                        # Crear entrada de tiempo automática
                        WorkOrderTaskTimeEntry.objects.create(
                            task=task,
                            hours=round(hours, 2),
                            description="Tiempo automático calculado al completar la tarea",
                            date=task.completed_at.date()
                        )
                        
                        # Actualizar horas reales de la tarea
                        task.update_actual_hours()
                        
                elif new_status == 'in_progress':
                    if not task.started_at:  # Solo si no se había iniciado antes
                        task.started_at = timezone.now()
                    task.completed_at = None
                else:  # pending
                    task.started_at = None
                    task.completed_at = None
                
                task.save()
                
                # Actualizar las horas del work order después de cualquier cambio de estado
                work_order.update_actual_hours()
                
                new_status_display = task.get_status_display()
                messages.success(request, f'Tarea "{task.title}" actualizada de "{old_status}" a "{new_status_display}".')
            except WorkOrderTask.DoesNotExist:
                messages.error(request, 'Tarea no encontrada.')
        
        return redirect('public_work_order_tasks', token=token)
    
    context = {
        'work_order': work_order,
        'tasks': tasks,
        'page_title': f'Tareas - {work_order.order_number}',
        'is_public_view': True,
        'total_estimated_hours': sum(task.estimated_hours or 0 for task in tasks),
        'total_logged_hours': work_order.get_total_hours_logged(),
        'progress_percentage': work_order.get_progress_percentage(),
    }
    
    return render(request, 'tickets/work_order_public_tasks.html', context)


def work_order_public_task_time_start_view(request, token, task_pk):
    """Vista pública para iniciar el tiempo de una tarea"""
    if request.method == 'POST':
        work_order = get_object_or_404(WorkOrder, public_share_token=token, is_public=True)
        from .models import WorkOrderTask, WorkOrderTaskTimeSession
        task = get_object_or_404(WorkOrderTask, pk=task_pk, work_order=work_order)
        
        # Para vista pública, crear sesión anónima (sin usuario)
        # Verificar si ya hay una sesión activa para esta tarea
        active_session = task.active_sessions.filter(is_active=True, user__isnull=True).first()
        if active_session:
            return JsonResponse({
                'success': False,
                'error': 'Ya hay una sesión de tiempo activa para esta tarea'
            })
        
        # Crear nueva sesión de tiempo sin usuario (pública)
        session = WorkOrderTaskTimeSession.objects.create(
            task=task,
            user=None  # Para sesiones públicas
        )
        
        # Actualizar estado de la tarea a "en progreso" si está pendiente
        if task.status == 'pending':
            task.status = 'in_progress'
            task.started_at = timezone.now()
            task.save()
        
        return JsonResponse({
            'success': True,
            'message': 'Tiempo iniciado correctamente',
            'session_id': session.id,
            'started_at': session.start_time.strftime('%H:%M:%S')
        })
    
    return JsonResponse({'success': False, 'error': 'Método no permitido'})


def work_order_public_task_time_stop_view(request, token, task_pk):
    """Vista pública para detener el tiempo de una tarea"""
    if request.method == 'POST':
        work_order = get_object_or_404(WorkOrder, public_share_token=token, is_public=True)
        from .models import WorkOrderTask
        task = get_object_or_404(WorkOrderTask, pk=task_pk, work_order=work_order)
        
        # Buscar sesión activa pública (sin usuario)
        active_session = task.active_sessions.filter(is_active=True, user__isnull=True).first()
        if not active_session:
            return JsonResponse({
                'success': False,
                'error': 'No hay una sesión de tiempo activa para esta tarea'
            })
        
        # Obtener descripción opcional del POST
        description = request.POST.get('description', '')
        
        # Detener la sesión
        time_entry = active_session.stop_session(description)
        
        if time_entry:
            return JsonResponse({
                'success': True,
                'message': f'Tiempo registrado: {time_entry.hours}h',
                'total_time': task.get_total_time_logged(),
                'session_duration': active_session.get_duration_hours()
            })
        else:
            return JsonResponse({
                'success': False,
                'error': 'Error al registrar el tiempo'
            })
    
    return JsonResponse({'success': False, 'error': 'Método no permitido'})


# ===========================================
# VISTAS PARA EVALUACIÓN DE IA DE LANDING PAGES
# ===========================================

@login_required
@user_passes_test(is_agent, login_url='/')
def landing_submissions_list_view(request):
    """Vista para listar envíos de landing pages con evaluación de IA"""
    from .models import LandingPageSubmission
    
    # Filtros
    evaluated_filter = request.GET.get('evaluated', 'all')
    priority_filter = request.GET.get('priority', 'all')
    score_filter = request.GET.get('score', 'all')
    search = request.GET.get('search', '')
    
    # Base queryset
    submissions = LandingPageSubmission.objects.select_related('landing_page').order_by('-created_at')
    
    # Aplicar filtros
    if evaluated_filter == 'yes':
        submissions = submissions.filter(ai_evaluated=True)
    elif evaluated_filter == 'no':
        submissions = submissions.filter(ai_evaluated=False)
    
    if priority_filter != 'all':
        submissions = submissions.filter(ai_priority_level=priority_filter)
    
    if score_filter == 'high':
        submissions = submissions.filter(ai_overall_score__gte=7.0)
    elif score_filter == 'medium':
        submissions = submissions.filter(ai_overall_score__gte=4.0, ai_overall_score__lt=7.0)
    elif score_filter == 'low':
        submissions = submissions.filter(ai_overall_score__lt=4.0)
    
    if search:
        submissions = submissions.filter(
            Q(nombre__icontains=search) |
            Q(apellido__icontains=search) |
            Q(email__icontains=search) |
            Q(empresa__icontains=search) |
            Q(mensaje__icontains=search)
        )
    
    # Paginación
    paginator = Paginator(submissions, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Estadísticas
    from .ai_landing_evaluator import get_evaluation_stats
    try:
        stats = get_evaluation_stats()
    except:
        stats = {}
    
    context = {
        'page_title': 'Evaluación IA - Landing Pages',
        'page_obj': page_obj,
        'evaluated_filter': evaluated_filter,
        'priority_filter': priority_filter,
        'score_filter': score_filter,
        'search': search,
        'stats': stats,
        'priority_choices': [
            ('low', 'Baja'),
            ('medium', 'Media'),
            ('high', 'Alta'),
            ('urgent', 'Urgente'),
        ]
    }
    
    return render(request, 'tickets/landing_submissions_list.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def landing_submission_detail_view(request, submission_id):
    """Vista detallada de un envío de landing page con evaluación IA"""
    from .models import LandingPageSubmission
    
    submission = get_object_or_404(LandingPageSubmission, id=submission_id)
    
    context = {
        'page_title': f'Evaluación: {submission.nombre} {submission.apellido}',
        'submission': submission,
    }
    
    return render(request, 'tickets/landing_submission_detail.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def evaluate_submission_ai_view(request, submission_id):
    """Vista para evaluar un envío específico con IA"""
    from .models import LandingPageSubmission
    
    submission = get_object_or_404(LandingPageSubmission, id=submission_id)
    
    if request.method == 'POST':
        try:
            success = submission.evaluate_with_ai()
            if success:
                messages.success(request, f'Evaluación IA completada. Puntuación: {submission.ai_overall_score}/10')
            else:
                messages.error(request, 'Error al evaluar con IA')
        except Exception as e:
            messages.error(request, f'Error: {str(e)}')
    
    return redirect('landing_submission_detail', submission_id=submission.id)


@login_required
@user_passes_test(is_agent, login_url='/')
def landing_submission_delete_view(request, submission_id):
    """Vista para eliminar una submission de landing page"""
    from .models import LandingPageSubmission
    
    submission = get_object_or_404(LandingPageSubmission, id=submission_id)
    
    if request.method == 'POST':
        try:
            submission.delete()
            messages.success(request, f'Submission de "{submission.nombre} {submission.apellido}" eliminada correctamente.')
            return redirect('landing_submissions_list')
        except Exception as e:
            messages.error(request, f'Error al eliminar la submission: {str(e)}')
            return redirect('landing_submission_detail', submission_id=submission.id)
    
    context = {
        'submission': submission,
        'page_title': f'Eliminar Submission - {submission.nombre} {submission.apellido}',
    }
    
    return render(request, 'tickets/landing_submission_delete.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def batch_evaluate_submissions_view(request):
    """Vista para evaluación en lote con IA"""
    if request.method == 'POST':
        limit = int(request.POST.get('limit', 10))
        
        try:
            from .ai_landing_evaluator import batch_evaluate_submissions
            results = batch_evaluate_submissions(limit=limit)
            
            messages.success(
                request, 
                f'Evaluación completada: {results["processed"]} procesados, {results["errors"]} errores'
            )
            
            # Mostrar detalles de errores si los hay
            if results["errors"] > 0:
                error_details = [r for r in results["results"] if r["status"] == "error"]
                for error in error_details[:3]:  # Mostrar máximo 3 errores
                    messages.warning(request, f'Error en ID {error["id"]}: {error["error"]}')
                    
        except Exception as e:
            messages.error(request, f'Error en evaluación en lote: {str(e)}')
    
    return redirect('landing_submissions_list')


@login_required
@user_passes_test(is_agent, login_url='/')
def ai_evaluation_dashboard_view(request):
    """Dashboard con estadísticas de evaluación IA"""
    from .ai_landing_evaluator import get_evaluation_stats
    from .models import LandingPageSubmission
    from django.db.models import Count
    from datetime import datetime, timedelta
    
    # Estadísticas generales
    try:
        stats = get_evaluation_stats()
    except:
        stats = {}
    
    # Top submissions por puntuación
    top_submissions = LandingPageSubmission.objects.filter(
        ai_evaluated=True
    ).order_by('-ai_overall_score')[:10]
    
    # Submissions recientes no evaluados
    pending_submissions = LandingPageSubmission.objects.filter(
        ai_evaluated=False
    ).order_by('-created_at')[:10]
    
    # Submissions urgentes
    urgent_submissions = LandingPageSubmission.objects.filter(
        ai_priority_level='urgent'
    ).order_by('-ai_overall_score')[:5]
    
    # Estadísticas por mes
    last_30_days = timezone.now() - timedelta(days=30)
    monthly_stats = LandingPageSubmission.objects.filter(
        created_at__gte=last_30_days
    ).extra(
        select={'month': 'DATE(created_at)'}
    ).values('month').annotate(
        total=Count('id'),
        evaluated=Count('id', filter=Q(ai_evaluated=True))
    ).order_by('-month')[:10]
    
    context = {
        'page_title': 'Dashboard Evaluación IA',
        'stats': stats,
        'top_submissions': top_submissions,
        'pending_submissions': pending_submissions,
        'urgent_submissions': urgent_submissions,
        'monthly_stats': monthly_stats,
    }
    
    return render(request, 'tickets/ai_evaluation_dashboard.html', context)


# ====== VISTAS DE ARCHIVOS COMPARTIDOS ======

@login_required
def shared_files_list_view(request):
    """Vista para listar archivos compartidos"""
    
    user = request.user
    user_profile = getattr(user, 'userprofile', None)
    
    # Si es agente, puede ver todos los archivos
    if is_agent(user):
        files = SharedFile.objects.all()
    else:
        # Si no es agente, solo ve archivos de su empresa y los que él subió
        if user_profile and user_profile.company:
            files = SharedFile.objects.filter(
                Q(company=user_profile.company) | Q(uploaded_by=user)
            )
        else:
            # Si no tiene empresa, solo ve los que él subió
            files = SharedFile.objects.filter(uploaded_by=user)
    
    # Filtros
    search = request.GET.get('search', '')
    company_id = request.GET.get('company', '')
    file_type = request.GET.get('file_type', '')
    
    if search:
        files = files.filter(
            Q(title__icontains=search) | 
            Q(description__icontains=search)
        )
    
    if company_id:
        files = files.filter(company_id=company_id)
    
    if file_type:
        files = files.filter(file_type__icontains=file_type)
    
    files = files.select_related('company', 'uploaded_by').order_by('-created_at')
    
    # Paginación
    paginator = Paginator(files, 20)
    page_number = request.GET.get('page')
    files_page = paginator.get_page(page_number)
    
    # Empresas para el filtro
    companies = Company.objects.filter(is_active=True).order_by('name')
    
    # Tipos de archivo únicos para el filtro
    file_types = SharedFile.objects.values_list('file_type', flat=True).distinct()
    
    context = {
        'page_title': 'Archivos Compartidos',
        'files': files_page,
        'companies': companies,
        'file_types': file_types,
        'search': search,
        'selected_company': company_id,
        'selected_file_type': file_type,
    }
    
    return render(request, 'tickets/shared_files_list.html', context)


@login_required
def shared_file_upload_view(request):
    """Vista para subir archivos compartidos"""
    
    if request.method == 'POST':
        form = SharedFileForm(request.POST, request.FILES, user=request.user)
        if form.is_valid():
            shared_file = form.save(commit=False)
            shared_file.uploaded_by = request.user
            
            # Si el usuario no es agente y no tiene empresa asignada, usar la primera empresa activa
            if not shared_file.company:
                user_profile = getattr(request.user, 'userprofile', None)
                if user_profile and user_profile.company:
                    shared_file.company = user_profile.company
                else:
                    # Usar la primera empresa activa disponible
                    first_company = Company.objects.filter(is_active=True).first()
                    if first_company:
                        shared_file.company = first_company
            
            shared_file.save()
            messages.success(request, 'Archivo subido exitosamente.')
            return redirect('shared_files_list')
    else:
        form = SharedFileForm(user=request.user)
    
    context = {
        'page_title': 'Subir Archivo',
        'form': form,
    }
    
    return render(request, 'tickets/shared_file_upload.html', context)


@login_required
def shared_file_detail_view(request, file_id):
    """Vista para ver detalles de un archivo compartido"""
    
    shared_file = get_object_or_404(SharedFile, id=file_id)
    
    # Verificar permisos
    user = request.user
    user_profile = getattr(user, 'userprofile', None)
    
    if not is_agent(user):
        # Si no es agente, verificar que tenga acceso
        if not (shared_file.uploaded_by == user or 
                (user_profile and user_profile.company == shared_file.company)):
            messages.error(request, 'No tienes permisos para ver este archivo.')
            return redirect('shared_files_list')
    
    context = {
        'page_title': f'Archivo: {shared_file.title}',
        'shared_file': shared_file,
    }
    
    return render(request, 'tickets/shared_file_detail.html', context)


@login_required
def shared_file_download_view(request, file_id):
    """Vista para descargar archivos compartidos"""
    from django.http import FileResponse
    
    shared_file = get_object_or_404(SharedFile, id=file_id)
    
    # Verificar permisos
    user = request.user
    user_profile = getattr(user, 'userprofile', None)
    
    if not is_agent(user):
        # Si no es agente, verificar que tenga acceso
        if not (shared_file.uploaded_by == user or 
                (user_profile and user_profile.company == shared_file.company)):
            messages.error(request, 'No tienes permisos para descargar este archivo.')
            return redirect('shared_files_list')
    
    # Registrar la descarga
    SharedFileDownload.objects.create(
        shared_file=shared_file,
        downloaded_by=user,
        ip_address=request.META.get('REMOTE_ADDR', ''),
        user_agent=request.META.get('HTTP_USER_AGENT', '')
    )
    
    # Incrementar contador de descargas
    shared_file.download_count += 1
    shared_file.save(update_fields=['download_count'])
    
    try:
        response = FileResponse(
            shared_file.file.open(),
            as_attachment=True,
            filename=os.path.basename(shared_file.file.name)
        )
        return response
    except FileNotFoundError:
        messages.error(request, 'El archivo no se encontró en el servidor.')
        return redirect('shared_file_detail', file_id=file_id)


def public_file_upload_view(request):
    """Vista pública para subir archivos"""
    
    if request.method == 'POST':
        form = PublicSharedFileForm(request.POST, request.FILES)
        if form.is_valid():
            shared_file = form.save()
            
            # Verificar si se encontró una empresa para el usuario
            uploader_email = form.cleaned_data['uploader_email']
            try:
                existing_user = User.objects.get(email=uploader_email)
                if hasattr(existing_user, 'userprofile') and existing_user.userprofile.company:
                    messages.success(
                        request, 
                        f'Archivo subido exitosamente y asignado automáticamente a la empresa: {existing_user.userprofile.company.name}. Gracias por compartir.'
                    )
                else:
                    messages.success(
                        request, 
                        'Archivo subido exitosamente. Tu cuenta no tiene empresa asignada, por lo que el archivo estará disponible para revisión de los agentes.'
                    )
            except User.DoesNotExist:
                messages.success(
                    request, 
                    'Archivo subido exitosamente. No se encontró una cuenta con este email, por lo que el archivo estará disponible para revisión de los agentes.'
                )
            
            return redirect('public_file_upload')
    else:
        form = PublicSharedFileForm()
    
    context = {
        'page_title': 'Subir Archivo Público',
        'form': form,
    }
    
    return render(request, 'tickets/public_file_upload.html', context)


@login_required 
@user_passes_test(is_agent)
def shared_file_delete_view(request, file_id):
    """Vista para eliminar archivos compartidos (solo agentes)"""
    
    shared_file = get_object_or_404(SharedFile, id=file_id)
    
    if request.method == 'POST':
        # Eliminar archivo físico
        if shared_file.file:
            try:
                shared_file.file.delete()
            except:
                pass
        
        shared_file.delete()
        messages.success(request, 'Archivo eliminado exitosamente.')
        return redirect('shared_files_list')
    
    context = {
        'page_title': 'Eliminar Archivo',
        'shared_file': shared_file,
    }
    
    return render(request, 'tickets/shared_file_delete.html', context)


@login_required
@user_passes_test(is_agent)
def shared_files_stats_view(request):
    """Vista de estadísticas de archivos compartidos (solo agentes)"""
    from django.db.models import Count, Sum
    
    # Estadísticas generales
    total_files = SharedFile.objects.count()
    total_downloads = SharedFileDownload.objects.count()
    total_size = SharedFile.objects.aggregate(
        total=Sum('file_size')
    )['total'] or 0
    
    # Calcular promedio de descargas por archivo
    avg_downloads_per_file = round(total_downloads / total_files, 1) if total_files > 0 else 0
    
    # Archivos más descargados
    top_files = SharedFile.objects.filter(
        download_count__gt=0
    ).order_by('-download_count')[:10]
    
    # Archivos por empresa
    files_by_company = SharedFile.objects.values(
        'company__name'
    ).annotate(
        count=Count('id')
    ).order_by('-count')[:10]
    
    # Archivos por tipo
    files_by_type = SharedFile.objects.values(
        'file_type'
    ).annotate(
        count=Count('id')
    ).order_by('-count')[:10]
    
    # Actividad reciente
    recent_uploads = SharedFile.objects.select_related(
        'company', 'uploaded_by'
    ).order_by('-created_at')[:10]
    
    recent_downloads = SharedFileDownload.objects.select_related(
        'shared_file', 'downloaded_by'
    ).order_by('-downloaded_at')[:10]
    
    context = {
        'page_title': 'Estadísticas de Archivos Compartidos',
        'total_files': total_files,
        'total_downloads': total_downloads,
        'total_size': total_size,
        'avg_downloads_per_file': avg_downloads_per_file,
        'top_files': top_files,
        'files_by_company': files_by_company,
        'files_by_type': files_by_type,
        'recent_uploads': recent_uploads,
        'recent_downloads': recent_downloads,
    }
    
    return render(request, 'tickets/shared_files_stats.html', context)


# ========================== GRABACIONES VIEWS ==========================

@login_required
def recordings_list_view(request):
    """Vista para listar grabaciones"""
    from .models import Recording
    from .utils import is_agent
    
    # Filtrar grabaciones según el rol del usuario
    if is_agent(request.user):
        # Los agentes pueden ver todas las grabaciones
        recordings = Recording.objects.select_related('company', 'uploaded_by').all()
    else:
        # Los usuarios solo ven grabaciones de su empresa o públicas
        user_company = getattr(request.user.userprofile, 'company', None) if hasattr(request.user, 'userprofile') else None
        if user_company:
            recordings = Recording.objects.select_related('company', 'uploaded_by').filter(
                models.Q(company=user_company) | models.Q(is_public=True, company__isnull=True)
            )
        else:
            recordings = Recording.objects.select_related('company', 'uploaded_by').filter(
                uploaded_by=request.user
            )
    
    # Paginación
    paginator = Paginator(recordings, 12)
    page_number = request.GET.get('page')
    recordings_page = paginator.get_page(page_number)
    
    context = {
        'page_title': 'Grabaciones',
        'recordings': recordings_page,
        'is_agent': is_agent(request.user),
    }
    
    return render(request, 'tickets/recordings_list.html', context)


@login_required
def recording_upload_view(request):
    """Vista para grabar audio desde el navegador"""
    from .forms import RecordingForm
    from .models import Recording
    import base64
    import tempfile
    import os
    from django.core.files.base import ContentFile
    
    if request.method == 'POST':
        form = RecordingForm(request.POST)
        if form.is_valid():
            recording = form.save(commit=False)
            
            # Asignar el usuario que sube
            recording.uploaded_by = request.user
            
            # Asignar empresa del usuario si tiene
            if hasattr(request.user, 'userprofile') and request.user.userprofile.company:
                recording.company = request.user.userprofile.company
            
            # Procesar datos de audio
            audio_data = form.cleaned_data['audio_data']
            if audio_data:
                try:
                    # Remover el prefijo 'data:audio/webm;codecs=opus;base64,' si existe
                    if ',' in audio_data:
                        audio_data = audio_data.split(',')[1]
                    
                    # Decodificar base64
                    audio_binary = base64.b64decode(audio_data)
                    
                    # Crear archivo temporal
                    audio_file = ContentFile(audio_binary, name=f"{recording.title}.webm")
                    recording.audio_file = audio_file
                    
                    recording.save()
                    
                    # Iniciar transcripción automática
                    try:
                        from .ai_utils import transcribe_recording
                        import threading
                        
                        # Ejecutar transcripción en hilo separado para no bloquear la respuesta
                        def transcribe_async():
                            transcribe_recording(recording.id)
                        
                        thread = threading.Thread(target=transcribe_async)
                        thread.daemon = True
                        thread.start()
                        
                        messages.success(request, 'Grabación guardada exitosamente. La transcripción se procesará automáticamente.')
                    except Exception as e:
                        messages.success(request, 'Grabación guardada exitosamente. La transcripción se procesará manualmente.')
                        print(f"Error iniciando transcripción automática: {e}")
                    
                    return redirect('recordings_list')
                    
                except Exception as e:
                    messages.error(request, f'Error al procesar la grabación: {str(e)}')
            else:
                messages.error(request, 'No se recibieron datos de audio.')
    else:
        form = RecordingForm()
    
    context = {
        'page_title': 'Grabar Audio',
        'form': form,
    }
    
    return render(request, 'tickets/recording_upload.html', context)


@login_required
def recording_detail_view(request, recording_id):
    """Vista para ver detalles de una grabación"""
    from .models import Recording, RecordingPlayback
    from .utils import is_agent
    
    recording = get_object_or_404(Recording, id=recording_id)
    
    # Verificar permisos
    user_can_access = False
    if is_agent(request.user):
        user_can_access = True
    elif recording.company and hasattr(request.user, 'userprofile') and request.user.userprofile.company == recording.company:
        user_can_access = True
    elif recording.uploaded_by == request.user:
        user_can_access = True
    elif recording.is_public:
        user_can_access = True
    
    if not user_can_access:
        messages.error(request, 'No tienes permisos para ver esta grabación.')
        return redirect('recordings_list')
    
    # Registrar reproducción
    RecordingPlayback.objects.create(
        recording=recording,
        played_by=request.user,
        ip_address=request.META.get('REMOTE_ADDR'),
        user_agent=request.META.get('HTTP_USER_AGENT', '')
    )
    
    context = {
        'page_title': f'Grabación: {recording.title}',
        'recording': recording,
        'is_agent': is_agent(request.user),
    }
    
    return render(request, 'tickets/recording_detail.html', context)


@login_required
def recording_play_view(request, recording_id):
    """Vista para reproducir grabación (streaming)"""
    from .models import Recording
    from .utils import is_agent
    import mimetypes
    from django.http import HttpResponse, Http404
    from wsgiref.util import FileWrapper
    
    recording = get_object_or_404(Recording, id=recording_id)
    
    # Verificar permisos
    user_can_access = False
    if is_agent(request.user):
        user_can_access = True
    elif recording.company and hasattr(request.user, 'userprofile') and request.user.userprofile.company == recording.company:
        user_can_access = True
    elif recording.uploaded_by == request.user:
        user_can_access = True
    elif recording.is_public:
        user_can_access = True
    
    if not user_can_access:
        raise Http404("Grabación no encontrada")
    
    # Servir archivo de audio
    try:
        audio_file = recording.audio_file.open('rb')
        content_type, _ = mimetypes.guess_type(recording.audio_file.name)
        
        response = HttpResponse(FileWrapper(audio_file), content_type=content_type or 'audio/mpeg')
        response['Content-Disposition'] = f'inline; filename="{recording.title}.{recording.get_audio_extension().lower()}"'
        response['Content-Length'] = recording.file_size or recording.audio_file.size
        
        return response
    except Exception as e:
        raise Http404(f"Error al reproducir grabación: {str(e)}")


def public_recording_upload_view(request):
    """Vista pública para grabar audio desde el navegador"""
    from .forms import PublicRecordingForm
    import base64
    from django.core.files.base import ContentFile
    
    if request.method == 'POST':
        form = PublicRecordingForm(request.POST)
        if form.is_valid():
            recording = form.save(commit=False)
            
            # Buscar usuario por email para asignar empresa automáticamente
            uploader_email = form.cleaned_data['uploader_email']
            try:
                existing_user = User.objects.get(email=uploader_email)
                # Si el usuario tiene perfil con empresa, usar esa empresa
                if hasattr(existing_user, 'userprofile') and existing_user.userprofile.company:
                    recording.company = existing_user.userprofile.company
                else:
                    # Si no tiene empresa asignada, dejarlo sin empresa
                    recording.company = None
            except User.DoesNotExist:
                # Si no existe el usuario, dejarlo sin empresa
                recording.company = None
            
            # Guardar información del uploader en la descripción si no hay descripción
            uploader_info = f"\nSubido por: {form.cleaned_data['uploader_name']} ({uploader_email})"
            if recording.description:
                recording.description += uploader_info
            else:
                recording.description = f"Grabación subida públicamente.{uploader_info}"
            
            # Marcar como público
            recording.is_public = True
            
            # Procesar datos de audio
            audio_data = form.cleaned_data['audio_data']
            if audio_data:
                try:
                    # Remover el prefijo 'data:audio/webm;codecs=opus;base64,' si existe
                    if ',' in audio_data:
                        audio_data = audio_data.split(',')[1]
                    
                    # Decodificar base64
                    audio_binary = base64.b64decode(audio_data)
                    
                    # Crear archivo temporal
                    audio_file = ContentFile(audio_binary, name=f"{recording.title}.webm")
                    recording.audio_file = audio_file
                    
                    recording.save()
                    
                    # Iniciar transcripción automática
                    try:
                        from .ai_utils import transcribe_recording
                        import threading
                        
                        # Ejecutar transcripción en hilo separado para no bloquear la respuesta
                        def transcribe_async():
                            transcribe_recording(recording.id)
                        
                        thread = threading.Thread(target=transcribe_async)
                        thread.daemon = True
                        thread.start()
                    except Exception as e:
                        print(f"Error iniciando transcripción automática: {e}")
                    
                    # Verificar si se encontró una empresa para el usuario
                    try:
                        existing_user = User.objects.get(email=uploader_email)
                        if hasattr(existing_user, 'userprofile') and existing_user.userprofile.company:
                            messages.success(
                                request, 
                                f'Grabación guardada exitosamente y asignada automáticamente a la empresa: {existing_user.userprofile.company.name}. La transcripción se procesará automáticamente.'
                            )
                        else:
                            messages.success(
                                request, 
                                'Grabación guardada exitosamente. Tu cuenta no tiene empresa asignada, por lo que la grabación estará disponible para revisión de los agentes.'
                            )
                    except User.DoesNotExist:
                        messages.success(
                            request, 
                            'Grabación guardada exitosamente. No se encontró una cuenta con este email, por lo que la grabación estará disponible para revisión de los agentes.'
                        )
                    
                    return redirect('public_recording_upload')
                    
                except Exception as e:
                    messages.error(request, f'Error al procesar la grabación: {str(e)}')
            else:
                messages.error(request, 'No se recibieron datos de audio.')
    else:
        form = PublicRecordingForm()
    
    context = {
        'page_title': 'Grabar Audio Público',
        'form': form,
    }
    
    return render(request, 'tickets/public_recording_upload.html', context)


@login_required 
@user_passes_test(is_agent)
def recording_delete_view(request, recording_id):
    """Vista para eliminar grabaciones (solo agentes)"""
    from .models import Recording
    
    recording = get_object_or_404(Recording, id=recording_id)
    
    if request.method == 'POST':
        # Eliminar archivo físico
        if recording.audio_file:
            try:
                recording.audio_file.delete()
            except:
                pass
        
        recording.delete()
        messages.success(request, 'Grabación eliminada exitosamente.')
        return redirect('recordings_list')
    
    context = {
        'page_title': 'Eliminar Grabación',
        'recording': recording,
    }
    
    return render(request, 'tickets/recording_delete.html', context)


@login_required 
@user_passes_test(is_agent)
def recordings_stats_view(request):
    """Vista de estadísticas de grabaciones (solo agentes)"""
    from django.db.models import Count, Sum, Avg
    from .models import Recording, RecordingPlayback
    
    # Estadísticas generales
    total_recordings = Recording.objects.count()
    total_playbacks = RecordingPlayback.objects.count()
    total_size = Recording.objects.aggregate(
        total=Sum('file_size')
    )['total'] or 0
    
    # Calcular promedio de reproducciones por grabación
    avg_playbacks_per_recording = round(total_playbacks / total_recordings, 1) if total_recordings > 0 else 0
    
    # Grabaciones más reproducidas
    top_recordings = Recording.objects.annotate(
        playback_count=Count('playbacks')
    ).filter(playback_count__gt=0).order_by('-playback_count')[:10]
    
    # Grabaciones por empresa
    recordings_by_company = Recording.objects.values(
        'company__name'
    ).annotate(
        count=Count('id')
    ).order_by('-count')[:10]
    
    # Grabaciones por estado de transcripción
    recordings_by_status = Recording.objects.values(
        'transcription_status'
    ).annotate(
        count=Count('id')
    ).order_by('-count')
    
    # Actividad reciente
    recent_uploads = Recording.objects.select_related(
        'company', 'uploaded_by'
    ).order_by('-created_at')[:10]
    
    recent_playbacks = RecordingPlayback.objects.select_related(
        'recording', 'played_by'
    ).order_by('-played_at')[:10]
    
    context = {
        'page_title': 'Estadísticas de Grabaciones',
        'total_recordings': total_recordings,
        'total_playbacks': total_playbacks,
        'total_size': total_size,
        'avg_playbacks_per_recording': avg_playbacks_per_recording,
        'top_recordings': top_recordings,
        'recordings_by_company': recordings_by_company,
        'recordings_by_status': recordings_by_status,
        'recent_uploads': recent_uploads,
        'recent_playbacks': recent_playbacks,
    }
    
    return render(request, 'tickets/recordings_stats.html', context)


@login_required
def recording_detail_view(request, recording_id):
    """Vista detallada de una grabación con transcripción editable"""
    from .models import Recording, RecordingPlayback
    from .forms import TranscriptionEditForm, TranscriptionActionForm
    from .ai_utils import transcribe_recording, AudioTranscriber
    
    recording = get_object_or_404(Recording, id=recording_id)
    
    # Verificar permisos usando la función is_agent de utils
    if not is_agent(request.user):
        # Si no es agente, verificar que tiene empresa y es la misma que la grabación
        user_profile = getattr(request.user, 'userprofile', None)
        if not user_profile:
            raise PermissionDenied("No tienes perfil de usuario configurado")
        if recording.company != user_profile.company:
            raise PermissionDenied("No tienes permiso para ver esta grabación")
    
    # Registrar reproducción si es una visualización completa
    if request.method == 'GET' and 'transcript_only' not in request.GET:
        RecordingPlayback.objects.create(
            recording=recording,
            played_by=request.user,
            user_agent=request.META.get('HTTP_USER_AGENT', ''),
            ip_address=request.META.get('REMOTE_ADDR', '')
        )
    
    transcription_form = TranscriptionEditForm(instance=recording)
    action_form = TranscriptionActionForm(recording=recording)
    
    # Procesar formularios
    if request.method == 'POST':
        if 'save_transcription' in request.POST:
            transcription_form = TranscriptionEditForm(request.POST, instance=recording)
            if transcription_form.is_valid():
                transcription_form.save()
                messages.success(request, 'Transcripción guardada exitosamente.')
                return redirect('recording_detail', recording_id=recording.id)
        
        elif 'process_ai' in request.POST:
            action_form = TranscriptionActionForm(request.POST, recording=recording)
            if action_form.is_valid():
                action = action_form.cleaned_data['action']
                context_hint = action_form.cleaned_data['context_hint']
                
                try:
                    if action == 'generate' or action == 'regenerate':
                        # Transcribir desde audio
                        result = transcribe_recording(recording.id)
                        if result['success']:
                            messages.success(request, 'Transcripción generada exitosamente con IA.')
                        else:
                            messages.error(request, f'Error al generar transcripción: {result["error"]}')
                    
                    elif action == 'improve':
                        # Mejorar transcripción existente
                        if recording.transcription_text:
                            transcriber = AudioTranscriber()
                            context = f"Título: {recording.title}. Descripción: {recording.description}"
                            if context_hint:
                                context += f". Contexto adicional: {context_hint}"
                            
                            improved_text = transcriber.improve_transcription_with_ai(
                                recording.transcription_text, 
                                context
                            )
                            
                            if improved_text != recording.transcription_text:
                                recording.transcription_text = improved_text
                                recording.save()
                                messages.success(request, 'Transcripción mejorada exitosamente con IA.')
                            else:
                                messages.info(request, 'La transcripción ya estaba optimizada.')
                        else:
                            messages.error(request, 'No hay transcripción para mejorar.')
                    
                    return redirect('recording_detail', recording_id=recording.id)
                    
                except Exception as e:
                    messages.error(request, f'Error procesando con IA: {str(e)}')
    
    # Obtener estadísticas de reproducción
    playback_count = recording.playbacks.count()
    recent_playbacks = recording.playbacks.select_related('played_by').order_by('-played_at')[:5]
    
    # Calcular valores estadísticos para el template
    bitrate_kbps = None
    if recording.file_size and recording.duration_seconds and recording.duration_seconds > 0:
        # Bitrate en kbps (file_size en bytes / duration_seconds / 128)
        bitrate_kbps = round(recording.file_size / recording.duration_seconds / 128, 0)
    
    context = {
        'page_title': f'Grabación: {recording.title}',
        'recording': recording,
        'transcription_form': transcription_form,
        'action_form': action_form,
        'playback_count': playback_count,
        'recent_playbacks': recent_playbacks,
        'bitrate_kbps': bitrate_kbps,
    }
    
    return render(request, 'tickets/recording_detail.html', context)


@login_required
@user_passes_test(is_agent)
def recording_transcribe_async_view(request, recording_id):
    """Vista para iniciar transcripción asíncrona (solo agentes)"""
    from .models import Recording
    from .ai_utils import transcribe_recording
    import json
    from django.http import JsonResponse
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'})
    
    try:
        recording = Recording.objects.get(id=recording_id)
        
        # Verificar que no esté ya procesando
        if recording.transcription_status == 'processing':
            return JsonResponse({
                'success': False, 
                'error': 'La transcripción ya está en proceso'
            })
        
        # Iniciar transcripción
        result = transcribe_recording(recording_id)
        
        return JsonResponse({
            'success': result['success'],
            'transcription': result.get('transcription', ''),
            'confidence': result.get('confidence', 0),
            'error': result.get('error', '')
        })
        
    except Recording.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Grabación no encontrada'})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)})


@login_required
@user_passes_test(is_agent)
def recording_bulk_transcribe_view(request):
    """Vista para transcribir múltiples grabaciones en lote (solo agentes)"""
    from .models import Recording
    from .ai_utils import transcribe_recording
    import json
    from django.http import JsonResponse
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'})
    
    try:
        data = json.loads(request.body)
        recording_ids = data.get('recording_ids', [])
        
        if not recording_ids:
            return JsonResponse({'success': False, 'error': 'No se proporcionaron IDs de grabaciones'})
        
        results = []
        for recording_id in recording_ids:
            try:
                recording = Recording.objects.get(id=recording_id)
                
                # Solo procesar si no está ya transcrito o si hay error previo
                if recording.transcription_status in ['pending', 'failed']:
                    result = transcribe_recording(recording_id)
                    results.append({
                        'id': recording_id,
                        'title': recording.title,
                        'success': result['success'],
                        'error': result.get('error', '')
                    })
                else:
                    results.append({
                        'id': recording_id,
                        'title': recording.title,
                        'success': True,
                        'error': 'Ya transcrito'
                    })
                    
            except Recording.DoesNotExist:
                results.append({
                    'id': recording_id,
                    'title': 'Desconocido',
                    'success': False,
                    'error': 'Grabación no encontrada'
                })
        
        success_count = sum(1 for r in results if r['success'])
        
        return JsonResponse({
            'success': True,
            'processed': len(results),
            'successful': success_count,
            'failed': len(results) - success_count,
            'results': results
        })
        
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)})


@login_required
def voice_command_create_ticket_view(request):
    """Vista para procesar comandos de voz y crear tickets automáticamente"""
    from .ai_utils import VoiceCommandProcessor
    import tempfile
    import os
    import logging
    
    logger = logging.getLogger(__name__)
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'})
    
    try:
        # Verificar que se envió un archivo de audio
        if 'audio' not in request.FILES:
            return JsonResponse({'success': False, 'error': 'No se envió archivo de audio'})
        
        audio_file = request.FILES['audio']
        
        # Validar formato de audio
        allowed_formats = ['.wav', '.mp3', '.m4a', '.webm', '.ogg']
        file_extension = os.path.splitext(audio_file.name)[1].lower()
        
        if file_extension not in allowed_formats:
            return JsonResponse({
                'success': False, 
                'error': f'Formato de audio no soportado. Use: {", ".join(allowed_formats)}'
            })
        
        # Crear archivo temporal para procesar el audio
        with tempfile.NamedTemporaryFile(delete=False, suffix=file_extension) as temp_file:
            # Escribir el contenido del archivo subido al archivo temporal
            for chunk in audio_file.chunks():
                temp_file.write(chunk)
            temp_file_path = temp_file.name
        
        try:
            # Procesar el comando de voz
            processor = VoiceCommandProcessor()
            result = processor.process_voice_command(temp_file_path, request.user)
            
            if result['success']:
                # Comando procesado exitosamente
                ticket_number = result["ticket"].get("ticket_number", result["ticket"].get("ticket_id", "Sin número"))
                return JsonResponse({
                    'success': True,
                    'message': f'Ticket creado exitosamente: #{ticket_number}',
                    'ticket': result['ticket'],
                    'transcription': result['transcription'],
                    'ticket_info': result['ticket_info']
                })
            else:
                # Error procesando el comando
                return JsonResponse({
                    'success': False,
                    'error': result.get('error', 'Error desconocido procesando comando')
                })
        
        finally:
            # Limpiar archivo temporal
            try:
                os.unlink(temp_file_path)
            except OSError:
                pass  # Ignorar errores al eliminar archivo temporal
    
    except Exception as e:
        logger.error(f"Error en comando de voz: {str(e)}")
        return JsonResponse({'success': False, 'error': f'Error interno del servidor: {str(e)}'})


@login_required 
def voice_command_interface_view(request):
    """Vista para mostrar la interfaz de comandos de voz"""
    from .models import Ticket
    
    # Obtener estadísticas de tickets recientes del usuario
    recent_tickets = Ticket.objects.filter(
        created_by=request.user
    ).order_by('-created_at')[:5]
    
    # Obtener estadísticas generales
    total_tickets = Ticket.objects.filter(created_by=request.user).count()
    open_tickets = Ticket.objects.filter(created_by=request.user, status='open').count()
    
    context = {
        'page_title': 'Comandos de Voz IA - TicketProo',
        'recent_tickets': recent_tickets,
        'total_tickets': total_tickets,
        'open_tickets': open_tickets,
    }
    
    return render(request, 'tickets/voice_command_interface.html', context)


# ====================================
# VISTAS DE ANALYTICS Y REPORTES
# ====================================

@login_required
@require_http_methods(["GET"])
def page_visits_analytics_view(request):
    """Vista principal de analytics de visitas a páginas públicas"""
    from django.db.models import Count, Q
    from django.utils import timezone
    from datetime import datetime, timedelta
    from .models import PageVisit
    from django.views.decorators.cache import never_cache
    
    # Filtros de fecha
    end_date = timezone.now().date()
    start_date = end_date - timedelta(days=30)  # Por defecto últimos 30 días
    
    # Obtener fechas desde parámetros
    fecha_desde = request.GET.get('fecha_desde')
    fecha_hasta = request.GET.get('fecha_hasta')
    
    if fecha_desde:
        try:
            start_date = datetime.strptime(fecha_desde, '%Y-%m-%d').date()
        except ValueError:
            pass
    
    if fecha_hasta:
        try:
            end_date = datetime.strptime(fecha_hasta, '%Y-%m-%d').date()
        except ValueError:
            pass
    
    # Filtros adicionales
    page_type_filter = request.GET.get('page_type')
    country_filter = request.GET.get('country')
    exclude_bots = request.GET.get('exclude_bots', 'true') == 'true'
    
    # Query base
    visits = PageVisit.objects.filter(
        visited_at__date__gte=start_date,
        visited_at__date__lte=end_date
    )
    
    if page_type_filter:
        visits = visits.filter(page_type=page_type_filter)
    
    if country_filter:
        visits = visits.filter(country_code=country_filter)
    
    if exclude_bots:
        visits = visits.filter(is_bot=False)
    
    # Estadísticas generales
    total_visits = visits.count()
    unique_ips = visits.values('ip_address').distinct().count()
    unique_countries = visits.exclude(country_code='').values('country_code').distinct().count()
    
    # Visitas por página
    visits_by_page = visits.values('page_type').annotate(
        count=Count('id')
    ).order_by('-count')
    
    # Visitas por día (últimos 30 días)
    visits_by_day = []
    current_date = start_date
    while current_date <= end_date:
        day_visits = visits.filter(visited_at__date=current_date).count()
        visits_by_day.append({
            'date': current_date.strftime('%Y-%m-%d'),
            'visits': day_visits
        })
        current_date += timedelta(days=1)
    
    # Top países
    top_countries = visits.exclude(country='').values('country', 'country_code').annotate(
        count=Count('id')
    ).order_by('-count')[:10]
    
    # Top navegadores
    top_browsers = visits.exclude(browser='').values('browser').annotate(
        count=Count('id')
    ).order_by('-count')[:10]
    
    # Dispositivos móviles vs desktop
    mobile_visits = visits.filter(is_mobile=True).count()
    desktop_visits = visits.filter(is_mobile=False).count()
    
    # Asegurar que hay al menos un dispositivo para el gráfico
    if mobile_visits == 0 and desktop_visits == 0:
        desktop_visits = 0
        mobile_visits = 0
    
    # Páginas más visitadas (detalle)
    top_pages = visits.values('page_url', 'page_title', 'page_type').annotate(
        count=Count('id')
    ).order_by('-count')[:20]
    
    # Landing pages específicas
    landing_pages_stats = visits.filter(page_type='landing').values('page_url', 'page_title').annotate(
        count=Count('id')
    ).order_by('-count')[:10]
    
    # Estadísticas específicas de landing pages
    landing_total_visits = visits.filter(page_type='landing').count()
    landing_unique_visitors = visits.filter(page_type='landing').values('ip_address').distinct().count()
    
    # Conversión de landing pages (si hay parámetros UTM)
    landing_utm_sources = visits.filter(
        page_type='landing',
        utm_source__isnull=False
    ).exclude(utm_source='').values('utm_source').annotate(
        count=Count('id')
    ).order_by('-count')[:5]
    
    # Fuentes de tráfico (referrers)
    referrers = visits.exclude(referrer='').values('referrer').annotate(
        count=Count('id')
    ).order_by('-count')[:10]
    
    # Visitas recientes
    recent_visits = visits.order_by('-visited_at')[:50]
    
    # Para filtros
    page_types = PageVisit.PAGE_CHOICES
    countries = visits.exclude(country_code='').values('country_code', 'country').distinct().order_by('country')
    
    context = {
        'page_title': 'Analytics de Páginas Públicas',
        'start_date': start_date,
        'end_date': end_date,
        'total_visits': total_visits,
        'unique_ips': unique_ips,
        'unique_countries': unique_countries,
        'visits_by_page': visits_by_page,
        'visits_by_day': visits_by_day,
        'top_countries': top_countries,
        'top_browsers': top_browsers,
        'mobile_visits': mobile_visits,
        'desktop_visits': desktop_visits,
        'top_pages': top_pages,
        'landing_pages_stats': landing_pages_stats,
        'landing_total_visits': landing_total_visits,
        'landing_unique_visitors': landing_unique_visitors,
        'landing_utm_sources': landing_utm_sources,
        'referrers': referrers,
        'recent_visits': recent_visits,
        'page_types': page_types,
        'countries': countries,
        # Filtros aplicados
        'page_type_filter': page_type_filter,
        'country_filter': country_filter,
        'exclude_bots': exclude_bots,
    }
    
    response = render(request, 'tickets/page_visits_analytics.html', context)
    # Agregar headers para evitar cache
    response['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    response['Pragma'] = 'no-cache'
    response['Expires'] = '0'
    return response


@login_required
@require_http_methods(["GET"])
def page_visits_detail_view(request):
    """Vista detallada de visitas a páginas con filtros avanzados"""
    from django.core.paginator import Paginator
    from django.db.models import Q
    from .models import PageVisit
    
    # Query base
    visits = PageVisit.objects.all().order_by('-visited_at')
    
    # Filtros
    search = request.GET.get('search')
    page_type = request.GET.get('page_type')
    country = request.GET.get('country')
    is_mobile = request.GET.get('is_mobile')
    exclude_bots = request.GET.get('exclude_bots', 'true') == 'true'
    fecha_desde = request.GET.get('fecha_desde')
    fecha_hasta = request.GET.get('fecha_hasta')
    
    if search:
        visits = visits.filter(
            Q(page_url__icontains=search) |
            Q(page_title__icontains=search) |
            Q(ip_address__icontains=search) |
            Q(country__icontains=search) |
            Q(browser__icontains=search)
        )
    
    if page_type:
        visits = visits.filter(page_type=page_type)
    
    if country:
        visits = visits.filter(country_code=country)
    
    if is_mobile:
        visits = visits.filter(is_mobile=is_mobile == 'true')
    
    if exclude_bots:
        visits = visits.filter(is_bot=False)
    
    if fecha_desde:
        try:
            from datetime import datetime
            start_date = datetime.strptime(fecha_desde, '%Y-%m-%d').date()
            visits = visits.filter(visited_at__date__gte=start_date)
        except ValueError:
            pass
    
    if fecha_hasta:
        try:
            from datetime import datetime
            end_date = datetime.strptime(fecha_hasta, '%Y-%m-%d').date()
            visits = visits.filter(visited_at__date__lte=end_date)
        except ValueError:
            pass
    
    # Paginación
    paginator = Paginator(visits, 50)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Para filtros
    page_types = PageVisit.PAGE_CHOICES
    countries = PageVisit.objects.exclude(country_code='').values('country_code', 'country').distinct().order_by('country')
    
    context = {
        'page_title': 'Detalle de Visitas',
        'page_obj': page_obj,
        'page_types': page_types,
        'countries': countries,
        # Filtros aplicados
        'search': search,
        'page_type': page_type,
        'country': country,
        'is_mobile': is_mobile,
        'exclude_bots': exclude_bots,
        'fecha_desde': fecha_desde,
        'fecha_hasta': fecha_hasta,
    }
    
    return render(request, 'tickets/page_visits_detail.html', context)


@login_required
@require_http_methods(["GET"])
def page_visits_export_view(request):
    """Vista para exportar datos de visitas en CSV"""
    import csv
    from django.http import HttpResponse
    from django.utils import timezone
    from .models import PageVisit
    
    # Aplicar los mismos filtros que en la vista principal
    visits = PageVisit.objects.all().order_by('-visited_at')
    
    # Filtros (copiar lógica de page_visits_detail_view)
    search = request.GET.get('search')
    page_type = request.GET.get('page_type')
    country = request.GET.get('country')
    exclude_bots = request.GET.get('exclude_bots', 'true') == 'true'
    fecha_desde = request.GET.get('fecha_desde')
    fecha_hasta = request.GET.get('fecha_hasta')
    
    if search:
        from django.db.models import Q
        visits = visits.filter(
            Q(page_url__icontains=search) |
            Q(page_title__icontains=search) |
            Q(ip_address__icontains=search) |
            Q(country__icontains=search) |
            Q(browser__icontains=search)
        )
    
    if page_type:
        visits = visits.filter(page_type=page_type)
    
    if country:
        visits = visits.filter(country_code=country)
    
    if exclude_bots:
        visits = visits.filter(is_bot=False)
    
    if fecha_desde:
        try:
            from datetime import datetime
            start_date = datetime.strptime(fecha_desde, '%Y-%m-%d').date()
            visits = visits.filter(visited_at__date__gte=start_date)
        except ValueError:
            pass
    
    if fecha_hasta:
        try:
            from datetime import datetime
            end_date = datetime.strptime(fecha_hasta, '%Y-%m-%d').date()
            visits = visits.filter(visited_at__date__lte=end_date)
        except ValueError:
            pass
    
    # Limitar a 10000 registros para evitar problemas de memoria
    visits = visits[:10000]
    
    # Crear respuesta CSV
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = f'attachment; filename="visitas_paginas_{timezone.now().strftime("%Y%m%d_%H%M%S")}.csv"'
    
    writer = csv.writer(response)
    
    # Encabezados
    writer.writerow([
        'Fecha/Hora',
        'Tipo de Página',
        'URL',
        'Título',
        'IP',
        'País',
        'Ciudad',
        'Navegador',
        'Sistema Operativo',
        'Es Móvil',
        'Es Bot',
        'Referrer',
        'UTM Source',
        'UTM Medium',
        'UTM Campaign'
    ])
    
    # Datos
    for visit in visits:
        writer.writerow([
            visit.visited_at.strftime('%Y-%m-%d %H:%M:%S'),
            visit.get_page_type_display(),
            visit.page_url,
            visit.page_title,
            visit.ip_address,
            visit.country,
            visit.city,
            visit.browser_info,
            visit.operating_system,
            'Sí' if visit.is_mobile else 'No',
            'Sí' if visit.is_bot else 'No',
            visit.referrer,
            visit.utm_source,
            visit.utm_medium,
            visit.utm_campaign
        ])
    
    return response


# ====================================
# CONFIGURADOR DE IA PARA BLOG
# ====================================

@login_required
@require_http_methods(["GET"])
def ai_blog_configurators_list_view(request):
    """Vista lista de configuradores de IA para blog"""
    from .models import AIBlogConfigurator
    
    configurators = AIBlogConfigurator.objects.all().order_by('-created_at')
    
    # Agregar información de próxima ejecución y estadísticas
    for config in configurators:
        config.next_run_formatted = config.next_run_time.strftime('%d/%m/%Y %H:%M') if config.next_run_time else 'No programado'
        config.last_run_formatted = config.last_run.strftime('%d/%m/%Y %H:%M') if config.last_run else 'Nunca'
        
        # Calcular estadísticas desde los logs
        logs = config.generation_logs.all()
        config.successful_runs = logs.filter(generation_status='success').count()
        config.failed_runs = logs.filter(generation_status='error').count()
        
        # Contar posts realmente generados desde los logs
        posts_generated = logs.filter(
            generation_status='success',
            generated_post__isnull=False
        ).count()
        config.posts_generated = posts_generated
    
    context = {
        'page_title': 'Configuradores de IA para Blog',
        'configurators': configurators,
    }
    
    return render(request, 'tickets/ai_blog_configurators_list.html', context)


@login_required
@require_http_methods(["GET", "POST"])
def ai_blog_configurator_create_view(request):
    """Vista para crear configurador de IA"""
    from .models import AIBlogConfigurator, BlogCategory
    
    if request.method == 'POST':
        try:
            configurator = AIBlogConfigurator.objects.create(
                name=request.POST.get('name'),
                description=request.POST.get('description', ''),
                keywords=request.POST.get('keywords'),
                topic_template=request.POST.get('topic_template'),
                content_length=request.POST.get('content_length'),
                content_style=request.POST.get('content_style'),
                is_active=request.POST.get('is_active') == 'on',
                schedule_time=request.POST.get('schedule_time'),
                frequency_days=int(request.POST.get('frequency_days', 1)),
                max_posts_per_run=int(request.POST.get('max_posts_per_run', 1)),
                default_category_id=request.POST.get('default_category') or None,
            )
            
            messages.success(request, f'Configurador "{configurator.name}" creado exitosamente.')
            return redirect('ai_blog_configurators_list')
            
        except Exception as e:
            messages.error(request, f'Error creando configurador: {str(e)}')
    
    # Para el formulario
    categories = BlogCategory.objects.filter(is_active=True).order_by('name')
    
    context = {
        'page_title': 'Crear Configurador de IA',
        'categories': categories,
    }
    
    return render(request, 'tickets/ai_blog_configurator_form.html', context)


@login_required
@require_http_methods(["GET", "POST"])
def ai_blog_configurator_edit_view(request, pk):
    """Vista para editar configurador de IA"""
    from .models import AIBlogConfigurator, BlogCategory
    
    configurator = get_object_or_404(AIBlogConfigurator, pk=pk)
    
    if request.method == 'POST':
        try:
            configurator.name = request.POST.get('name')
            configurator.description = request.POST.get('description', '')
            configurator.keywords = request.POST.get('keywords')
            configurator.topic_template = request.POST.get('topic_template')
            configurator.content_length = request.POST.get('content_length')
            configurator.content_style = request.POST.get('content_style')
            configurator.is_active = request.POST.get('is_active') == 'on'
            configurator.schedule_time = request.POST.get('schedule_time')
            configurator.frequency_days = int(request.POST.get('frequency_days', 1))
            configurator.max_posts_per_run = int(request.POST.get('max_posts_per_run', 1))
            configurator.default_category_id = request.POST.get('default_category') or None
            configurator.save()
            
            messages.success(request, f'Configurador "{configurator.name}" actualizado exitosamente.')
            return redirect('ai_blog_configurators_list')
            
        except Exception as e:
            messages.error(request, f'Error actualizando configurador: {str(e)}')
    
    # Para el formulario
    categories = BlogCategory.objects.filter(is_active=True).order_by('name')
    
    context = {
        'page_title': 'Editar Configurador de IA',
        'configurator': configurator,
        'categories': categories,
    }
    
    return render(request, 'tickets/ai_blog_configurator_form.html', context)


@login_required
@require_http_methods(["POST"])
def ai_blog_configurator_delete_view(request, pk):
    """Vista para eliminar configurador de IA"""
    from .models import AIBlogConfigurator
    
    configurator = get_object_or_404(AIBlogConfigurator, pk=pk)
    configurator_name = configurator.name
    configurator.delete()
    
    messages.success(request, f'Configurador "{configurator_name}" eliminado exitosamente.')
    return redirect('ai_blog_configurators_list')


@login_required
@require_http_methods(["POST"])
def ai_blog_configurator_toggle_view(request, pk):
    """Vista para activar/desactivar configurador de IA"""
    from .models import AIBlogConfigurator
    
    configurator = get_object_or_404(AIBlogConfigurator, pk=pk)
    configurator.is_active = not configurator.is_active
    configurator.save()
    
    status = 'activado' if configurator.is_active else 'desactivado'
    messages.success(request, f'Configurador "{configurator.name}" {status} exitosamente.')
    
    return redirect('ai_blog_configurators_list')


@login_required
@require_http_methods(["POST"])
def ai_blog_configurator_run_now_view(request, pk):
    """Vista para ejecutar manualmente un configurador de IA"""
    from .models import AIBlogConfigurator
    
    configurator = get_object_or_404(AIBlogConfigurator, pk=pk)
    
    try:
        # Importar la función de generación
        from .ai_blog_generator import run_ai_blog_generation
        
        # Ejecutar manualmente con force=True para ignorar frecuencia programada
        result = run_ai_blog_generation(configurator, force=True)
        
        if result['success']:
            messages.success(request, f'✅ Generación exitosa: {result["posts_created"]} post(s) creado(s)')
        else:
            messages.error(request, f'❌ Error en generación: {result["error"]}')
            
    except Exception as e:
        messages.error(request, f'Error ejecutando configurador: {str(e)}')
    
    return redirect('ai_blog_configurators_list')


@login_required
@require_http_methods(["GET"])
def ai_blog_generation_logs_view(request, pk):
    """Vista para ver logs de generación de un configurador"""
    from .models import AIBlogConfigurator, AIBlogGenerationLog
    
    configurator = get_object_or_404(AIBlogConfigurator, pk=pk)
    logs = AIBlogGenerationLog.objects.filter(configurator=configurator).order_by('-created_at')
    
    # Calcular estadísticas
    total_logs = logs.count()
    successful_logs = logs.filter(generation_status='success').count()
    failed_logs = logs.filter(generation_status='error').count()
    posts_generated = logs.filter(generated_post__isnull=False).count()
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(logs, 50)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_title': f'Logs de Generación - {configurator.name}',
        'configurator': configurator,
        'page_obj': page_obj,
        'stats': {
            'total_logs': total_logs,
            'successful_logs': successful_logs,
            'failed_logs': failed_logs,
            'posts_generated': posts_generated,
        }
    }
    
    return render(request, 'tickets/ai_blog_generation_logs.html', context)


# ============= VISTAS DE DOCUMENTACIÓN MÚLTIPLE =============

@login_required
@user_passes_test(is_agent, login_url='/')
def multiple_documentation_list_view(request):
    """Vista para listar todas las documentaciones múltiples"""
    documentations = MultipleDocumentation.objects.all().order_by('-created_at')
    
    # Búsqueda
    search = request.GET.get('search')
    if search:
        documentations = documentations.filter(
            models.Q(title__icontains=search) |
            models.Q(description__icontains=search)
        )
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(documentations, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_title': 'Documentación Múltiple',
        'page_obj': page_obj,
        'search': search,
    }
    
    return render(request, 'tickets/multiple_documentation_list.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def multiple_documentation_create_view(request):
    """Vista para crear una nueva documentación múltiple"""
    from .forms import MultipleDocumentationForm
    
    if request.method == 'POST':
        form = MultipleDocumentationForm(request.POST)
        if form.is_valid():
            documentation = form.save(commit=False)
            documentation.created_by = request.user
            documentation.save()
            
            messages.success(request, f'Documentación "{documentation.title}" creada correctamente.')
            return redirect('multiple_documentation_detail', pk=documentation.pk)
    else:
        form = MultipleDocumentationForm()
    
    context = {
        'page_title': 'Crear Documentación Múltiple',
        'form': form,
        'is_create': True,
    }
    
    return render(request, 'tickets/multiple_documentation_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def multiple_documentation_detail_view(request, pk):
    """Vista para ver detalles de una documentación múltiple"""
    from .models import MultipleDocumentation
    
    documentation = get_object_or_404(MultipleDocumentation, pk=pk)
    items = documentation.items.all().order_by('number')
    
    context = {
        'page_title': f'Documentación: {documentation.title}',
        'documentation': documentation,
        'items': items,
    }
    
    return render(request, 'tickets/multiple_documentation_detail.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def multiple_documentation_edit_view(request, pk):
    """Vista para editar una documentación múltiple"""
    from .models import MultipleDocumentation
    from .forms import MultipleDocumentationForm
    
    documentation = get_object_or_404(MultipleDocumentation, pk=pk)
    
    if request.method == 'POST':
        form = MultipleDocumentationForm(request.POST, instance=documentation)
        if form.is_valid():
            form.save()
            messages.success(request, f'Documentación "{documentation.title}" actualizada correctamente.')
            return redirect('multiple_documentation_detail', pk=documentation.pk)
    else:
        form = MultipleDocumentationForm(instance=documentation)
    
    context = {
        'page_title': f'Editar: {documentation.title}',
        'documentation': documentation,
        'form': form,
        'is_create': False,
    }
    
    return render(request, 'tickets/multiple_documentation_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def multiple_documentation_delete_view(request, pk):
    """Vista para eliminar una documentación múltiple"""
    from .models import MultipleDocumentation
    
    documentation = get_object_or_404(MultipleDocumentation, pk=pk)
    
    if request.method == 'POST':
        try:
            title = documentation.title
            documentation.delete()
            messages.success(request, f'Documentación "{title}" eliminada correctamente.')
            return redirect('multiple_documentation_list')
            
        except Exception as e:
            messages.error(request, f'Error al eliminar la documentación: {str(e)}')
            return redirect('multiple_documentation_detail', pk=pk)
    
    context = {
        'page_title': f'Eliminar: {documentation.title}',
        'documentation': documentation,
    }
    
    return render(request, 'tickets/multiple_documentation_delete.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def multiple_documentation_add_item_view(request, pk):
    """Vista para agregar un item a la documentación múltiple"""
    from .models import MultipleDocumentation, MultipleDocumentationItem
    
    documentation = get_object_or_404(MultipleDocumentation, pk=pk)
    
    if request.method == 'POST':
        try:
            # Obtener el siguiente número disponible
            last_item = documentation.items.order_by('-number').first()
            next_number = (last_item.number + 1) if last_item else 1
            
            # Permitir que el usuario especifique el número
            number = int(request.POST.get('number', next_number))
            
            item = MultipleDocumentationItem.objects.create(
                documentation=documentation,
                number=number,
                name=request.POST['name'],
                description=request.POST.get('description', ''),
                file=request.FILES['file']
            )
            
            messages.success(request, f'Documento "{item.name}" agregado correctamente.')
            return redirect('multiple_documentation_detail', pk=documentation.pk)
            
        except Exception as e:
            messages.error(request, f'Error al agregar el documento: {str(e)}')
    
    # Obtener el siguiente número sugerido
    last_item = documentation.items.order_by('-number').first()
    suggested_number = (last_item.number + 1) if last_item else 1
    
    context = {
        'page_title': f'Agregar Documento - {documentation.title}',
        'documentation': documentation,
        'suggested_number': suggested_number,
    }
    
    return render(request, 'tickets/multiple_documentation_add_item.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def multiple_documentation_edit_item_view(request, pk, item_id):
    """Vista para editar un item de documentación"""
    from .models import MultipleDocumentation, MultipleDocumentationItem
    
    documentation = get_object_or_404(MultipleDocumentation, pk=pk)
    item = get_object_or_404(MultipleDocumentationItem, pk=item_id, documentation=documentation)
    
    if request.method == 'POST':
        try:
            item.number = int(request.POST['number'])
            item.name = request.POST['name']
            item.description = request.POST.get('description', '')
            
            # Solo actualizar el archivo si se proporciona uno nuevo
            if 'file' in request.FILES:
                # Eliminar el archivo anterior
                if item.file:
                    item.file.delete(save=False)
                item.file = request.FILES['file']
            
            item.save()
            
            messages.success(request, f'Documento "{item.name}" actualizado correctamente.')
            return redirect('multiple_documentation_detail', pk=documentation.pk)
            
        except Exception as e:
            messages.error(request, f'Error al actualizar el documento: {str(e)}')
    
    context = {
        'page_title': f'Editar Documento - {item.name}',
        'documentation': documentation,
        'item': item,
    }
    
    return render(request, 'tickets/multiple_documentation_edit_item.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def multiple_documentation_delete_item_view(request, pk, item_id):
    """Vista para eliminar un item de documentación"""
    from .models import MultipleDocumentation, MultipleDocumentationItem
    
    documentation = get_object_or_404(MultipleDocumentation, pk=pk)
    item = get_object_or_404(MultipleDocumentationItem, pk=item_id, documentation=documentation)
    
    if request.method == 'POST':
        try:
            name = item.name
            # Eliminar el archivo físico
            if item.file:
                item.file.delete(save=False)
            item.delete()
            
            messages.success(request, f'Documento "{name}" eliminado correctamente.')
            return redirect('multiple_documentation_detail', pk=documentation.pk)
            
        except Exception as e:
            messages.error(request, f'Error al eliminar el documento: {str(e)}')
    
    context = {
        'page_title': f'Eliminar Documento - {item.name}',
        'documentation': documentation,
        'item': item,
    }
    
    return render(request, 'tickets/multiple_documentation_delete_item.html', context)


def multiple_documentation_public_view(request, token):
    """Vista pública para ver una documentación múltiple (sin autenticación)"""
    from .models import (
        MultipleDocumentation, MultipleDocumentationStats, 
        MultipleDocumentationVisit
    )
    from .forms import DocumentationPasswordForm
    
    try:
        documentation = get_object_or_404(
            MultipleDocumentation, 
            public_token=token, 
            is_active=True
        )
        
        # Verificar si está protegida con contraseña
        if documentation.password_protected:
            # Verificar si ya se validó la contraseña en esta sesión
            session_key = f'doc_access_{token}'
            if not request.session.get(session_key, False):
                # Procesar formulario de contraseña
                if request.method == 'POST':
                    form = DocumentationPasswordForm(request.POST, documentation=documentation)
                    if form.is_valid():
                        # Contraseña correcta, marcar en sesión
                        request.session[session_key] = True
                        request.session.set_expiry(3600)  # Expirar en 1 hora
                        return redirect('multiple_documentation_public', token=token)
                else:
                    form = DocumentationPasswordForm(documentation=documentation)
                
                # Mostrar formulario de contraseña
                context = {
                    'page_title': f'Acceso a {documentation.title}',
                    'documentation': documentation,
                    'form': form,
                }
                return render(request, 'tickets/multiple_documentation_password.html', context)
        
        # Obtener IP del visitante
        ip_address = request.META.get('REMOTE_ADDR')
        if request.META.get('HTTP_X_FORWARDED_FOR'):
            ip_address = request.META.get('HTTP_X_FORWARDED_FOR').split(',')[0]
        
        # Registrar la visita
        visit = MultipleDocumentationVisit.objects.create(
            documentation=documentation,
            ip_address=ip_address,
            user_agent=request.META.get('HTTP_USER_AGENT', ''),
            referer=request.META.get('HTTP_REFERER')
        )
        
        # Actualizar o crear estadísticas
        stats, created = MultipleDocumentationStats.objects.get_or_create(
            documentation=documentation,
            defaults={
                'first_view_date': timezone.now(),
                'last_view_date': timezone.now(),
                'page_views': 1,
                'unique_visitors': 1,
            }
        )
        
        if not created:
            # Actualizar estadísticas existentes
            stats.page_views += 1
            stats.last_view_date = timezone.now()
            
            # Verificar si es un visitante único (no ha visitado en las últimas 24 horas)
            yesterday = timezone.now() - timezone.timedelta(days=1)
            if not MultipleDocumentationVisit.objects.filter(
                documentation=documentation,
                ip_address=ip_address,
                timestamp__gte=yesterday
            ).exclude(pk=visit.pk).exists():
                stats.unique_visitors += 1
            
            stats.save()
        
        items = documentation.items.all().order_by('number')
        
        context = {
            'documentation': documentation,
            'items': items,
            'page_title': documentation.title,
        }
        
        return render(request, 'tickets/multiple_documentation_public.html', context)
        
    except Exception as e:
        from django.http import Http404
        raise Http404("La documentación solicitada no existe o no está disponible.")


def multiple_documentation_download_item_view(request, token, item_id):
    """Vista para descargar un archivo específico de la documentación pública"""
    from .models import (
        MultipleDocumentation, MultipleDocumentationItem, 
        MultipleDocumentationStats, MultipleDocumentationItemStats,
        MultipleDocumentationDownload
    )
    from django.http import HttpResponse, Http404
    
    try:
        documentation = get_object_or_404(
            MultipleDocumentation, 
            public_token=token, 
            is_active=True
        )
        
        # Verificar acceso con contraseña si es necesario
        if documentation.password_protected:
            session_key = f'doc_access_{token}'
            if not request.session.get(session_key, False):
                raise Http404("Acceso no autorizado")
        
        item = get_object_or_404(
            MultipleDocumentationItem, 
            pk=item_id, 
            documentation=documentation
        )
        
        if not item.file:
            raise Http404("Archivo no encontrado")
        
        # Obtener IP del usuario
        ip_address = request.META.get('REMOTE_ADDR')
        if request.META.get('HTTP_X_FORWARDED_FOR'):
            ip_address = request.META.get('HTTP_X_FORWARDED_FOR').split(',')[0]
        
        # Registrar la descarga
        download = MultipleDocumentationDownload.objects.create(
            item=item,
            ip_address=ip_address,
            user_agent=request.META.get('HTTP_USER_AGENT', ''),
            referer=request.META.get('HTTP_REFERER')
        )
        
        # Actualizar estadísticas del archivo
        item_stats, created = MultipleDocumentationItemStats.objects.get_or_create(
            item=item,
            defaults={
                'download_count': 1,
                'unique_downloaders': 1,
                'first_download_date': timezone.now(),
                'last_download_date': timezone.now(),
            }
        )
        
        if not created:
            item_stats.download_count += 1
            item_stats.last_download_date = timezone.now()
            
            # Verificar si es un descargador único (no ha descargado este archivo antes)
            if not MultipleDocumentationDownload.objects.filter(
                item=item,
                ip_address=ip_address
            ).exclude(pk=download.pk).exists():
                item_stats.unique_downloaders += 1
            
            item_stats.save()
        
        # Actualizar estadísticas de la documentación
        doc_stats, doc_created = MultipleDocumentationStats.objects.get_or_create(
            documentation=documentation,
            defaults={
                'total_downloads': 1,
                'last_download_date': timezone.now(),
            }
        )
        
        if not doc_created:
            doc_stats.total_downloads += 1
            doc_stats.last_download_date = timezone.now()
            doc_stats.save()
        
        # Obtener la respuesta del archivo
        response = HttpResponse(item.file.read(), content_type='application/octet-stream')
        response['Content-Disposition'] = f'attachment; filename="{item.file.name.split("/")[-1]}"'
        
        return response
        
    except Exception:
        raise Http404("Archivo no encontrado")


@login_required
@user_passes_test(is_agent, login_url='/')
def multiple_documentation_stats_view(request, pk):
    """Vista para mostrar estadísticas detalladas de una documentación"""
    from .models import (
        MultipleDocumentation, MultipleDocumentationStats,
        MultipleDocumentationVisit, MultipleDocumentationDownload
    )
    from django.db.models import Count, Q
    from django.utils import timezone
    from datetime import timedelta
    
    documentation = get_object_or_404(MultipleDocumentation, pk=pk)
    
    # Obtener o crear estadísticas generales
    stats, created = MultipleDocumentationStats.objects.get_or_create(
        documentation=documentation,
        defaults={
            'page_views': 0,
            'unique_visitors': 0,
            'total_downloads': 0,
        }
    )
    
    # Estadísticas por archivo
    items_stats = []
    for item in documentation.items.all().order_by('number'):
        item_stat = getattr(item, 'stats', None)
        if not item_stat:
            from .models import MultipleDocumentationItemStats
            item_stat, _ = MultipleDocumentationItemStats.objects.get_or_create(
                item=item,
                defaults={'download_count': 0, 'unique_downloaders': 0}
            )
        
        items_stats.append({
            'item': item,
            'stats': item_stat,
            'popularity': item_stat.get_popularity_percentage() if item_stat else 0,
        })
    
    # Estadísticas de los últimos 30 días
    thirty_days_ago = timezone.now() - timedelta(days=30)
    recent_visits = MultipleDocumentationVisit.objects.filter(
        documentation=documentation,
        timestamp__gte=thirty_days_ago
    ).count()
    
    recent_downloads = MultipleDocumentationDownload.objects.filter(
        item__documentation=documentation,
        timestamp__gte=thirty_days_ago
    ).count()
    
    # Estadísticas por día (últimos 7 días)
    daily_stats = []
    for i in range(7):
        date = timezone.now().date() - timedelta(days=i)
        date_start = timezone.make_aware(timezone.datetime.combine(date, timezone.datetime.min.time()))
        date_end = date_start + timedelta(days=1)
        
        visits = MultipleDocumentationVisit.objects.filter(
            documentation=documentation,
            timestamp__gte=date_start,
            timestamp__lt=date_end
        ).count()
        
        downloads = MultipleDocumentationDownload.objects.filter(
            item__documentation=documentation,
            timestamp__gte=date_start,
            timestamp__lt=date_end
        ).count()
        
        daily_stats.append({
            'date': date,
            'visits': visits,
            'downloads': downloads,
        })
    
    daily_stats.reverse()  # Mostrar desde el día más antiguo
    
    # Top 5 archivos más descargados
    top_files = sorted(items_stats, key=lambda x: x['stats'].download_count, reverse=True)[:5]
    
    # Últimas visitas y descargas
    recent_visits_list = MultipleDocumentationVisit.objects.filter(
        documentation=documentation
    ).order_by('-timestamp')[:10]
    
    recent_downloads_list = MultipleDocumentationDownload.objects.filter(
        item__documentation=documentation
    ).select_related('item').order_by('-timestamp')[:10]
    
    context = {
        'page_title': f'Estadísticas - {documentation.title}',
        'documentation': documentation,
        'stats': stats,
        'items_stats': items_stats,
        'recent_visits': recent_visits,
        'recent_downloads': recent_downloads,
        'daily_stats': daily_stats,
        'top_files': top_files,
        'recent_visits_list': recent_visits_list,
        'recent_downloads_list': recent_downloads_list,
        'conversion_rate': stats.get_conversion_rate(),
        'avg_downloads_per_day': stats.get_average_downloads_per_day(),
    }
    
    return render(request, 'tickets/multiple_documentation_stats.html', context)


# ====================
# Task Schedule Views
# ====================

def get_user_company(user):
    """Obtiene la empresa del usuario"""
    if hasattr(user, 'profile') and user.profile.company:
        return user.profile.company
    return None

def user_has_company_access(user, company):
    """Verifica si el usuario tiene acceso a una empresa"""
    # Los agentes y superusuarios tienen acceso a todas las empresas
    if user.is_superuser or is_agent(user):
        return True
    
    user_company = get_user_company(user)
    if not user_company:
        return False
    return user_company == company

def get_user_companies_queryset(user):
    """Obtiene el queryset de empresas accesibles por el usuario"""
    # Los agentes y superusuarios pueden ver todas las empresas
    if user.is_superuser or is_agent(user):
        return Company.objects.all()
    
    company = get_user_company(user)
    if company:
        return Company.objects.filter(id=company.id)
    return Company.objects.none()

@login_required
def task_schedule_list(request):
    """Vista para listar todos los cronogramas"""
    # Los agentes y superusuarios pueden ver todos los cronogramas
    if request.user.is_superuser or is_agent(request.user):
        schedules = TaskSchedule.objects.all().select_related('company', 'created_by').annotate(
            total_tasks=models.Count('tasks'),
            completed_tasks=models.Count('tasks', filter=models.Q(tasks__is_completed=True))
        ).order_by('-created_at')
    else:
        # Obtener la empresa del usuario
        user_company = None
        if hasattr(request.user, 'profile') and request.user.profile.company:
            user_company = request.user.profile.company
        
        if user_company:
            schedules = TaskSchedule.objects.filter(
                company=user_company
            ).select_related('company', 'created_by').annotate(
                total_tasks=models.Count('tasks'),
                completed_tasks=models.Count('tasks', filter=models.Q(tasks__is_completed=True))
            ).order_by('-created_at')
        else:
            # Si no tiene empresa, mostrar solo los que creó
            schedules = TaskSchedule.objects.filter(
                created_by=request.user
            ).select_related('company', 'created_by').annotate(
                total_tasks=models.Count('tasks'),
                completed_tasks=models.Count('tasks', filter=models.Q(tasks__is_completed=True))
            ).order_by('-created_at')
    
    context = {
        'page_title': 'Planificación de Tareas',
        'schedules': schedules,
    }
    
    return render(request, 'tickets/task_schedule_list.html', context)


@login_required
def task_schedule_create(request):
    """Vista para crear un nuevo cronograma"""
    if request.method == 'POST':
        form = TaskScheduleForm(request.POST)
        if form.is_valid():
            schedule = form.save(commit=False)
            schedule.created_by = request.user
            schedule.save()
            messages.success(request, 'Cronograma creado exitosamente. Las fechas de inicio y fin se calcularán automáticamente basándose en las tareas que agregues.')
            return redirect('task_schedule_detail', pk=schedule.pk)
    else:
        form = TaskScheduleForm()
        # Filtrar empresas del usuario
        form.fields['company'].queryset = get_user_companies_queryset(request.user)
    
    context = {
        'page_title': 'Crear Cronograma',
        'form': form,
        'auto_dates_info': True,
    }
    
    return render(request, 'tickets/task_schedule_form.html', context)


@login_required
def task_schedule_detail(request, pk):
    """Vista para ver los detalles de un cronograma"""
    schedule = get_object_or_404(
        TaskSchedule.objects.select_related('company', 'created_by'),
        pk=pk
    )
    
    # Verificar permisos
    if not user_has_company_access(request.user, schedule.company):
        messages.error(request, 'No tienes permiso para ver este cronograma.')
        return redirect('task_schedule_list')
    
    tasks = schedule.tasks.select_related('assigned_to').prefetch_related('dependencies')
    
    # Calcular KPIs
    kpis = {
        'total_tasks': schedule.get_total_tasks(),
        'completed_tasks': schedule.get_completed_tasks(),
        'pending_tasks': schedule.get_pending_tasks(),
        'overdue_tasks': schedule.get_overdue_tasks(),
        'progress_percentage': schedule.get_progress_percentage(),
        'on_time_rate': schedule.get_on_time_completion_rate(),
        'is_overdue': schedule.is_overdue(),
    }
    
    context = {
        'page_title': schedule.title,
        'schedule': schedule,
        'tasks': tasks,
        'kpis': kpis,
    }
    
    return render(request, 'tickets/task_schedule_detail.html', context)


@login_required
def task_schedule_export(request, pk):
    """Vista para exportar tareas de un cronograma a Excel"""
    schedule = get_object_or_404(
        TaskSchedule.objects.select_related('company', 'created_by'),
        pk=pk
    )
    
    # Verificar permisos
    if not user_has_company_access(request.user, schedule.company):
        messages.error(request, 'No tienes permiso para exportar este cronograma.')
        return redirect('task_schedule_list')
    
    # Importar pandas y crear DataFrame
    try:
        import pandas as pd
        from django.http import HttpResponse
        import io
        from datetime import datetime
        
        # Obtener todas las tareas del cronograma
        tasks = schedule.tasks.select_related('assigned_to').prefetch_related('dependencies').order_by('start_date')
        
        # Preparar datos para export
        data = []
        for task in tasks:
            # Obtener dependencias como texto
            dependencies_text = ', '.join([f"{dep.title}" for dep in task.dependencies.all()])
            
            # Calcular días de duración
            duration_days = 0
            if task.start_date and task.end_date:
                duration_days = (task.end_date - task.start_date).days + 1
            
            # Calcular estado de progreso
            progress_status = "A tiempo"
            if task.is_overdue():
                progress_status = "Atrasado"
            elif task.status == 'completed':
                progress_status = "Completado"
            
            data.append({
                'ID': task.id,
                'Título': task.title,
                'Descripción': task.description or '',
                'Estado': dict(task.STATUS_CHOICES).get(task.status, task.status),
                'Prioridad': dict(task.PRIORITY_CHOICES).get(task.priority, task.priority),
                'Asignado a': task.assigned_to.get_full_name() if task.assigned_to else 'Sin asignar',
                'Fecha de Inicio': task.start_date.strftime('%d/%m/%Y') if task.start_date else '',
                'Fecha de Fin': task.end_date.strftime('%d/%m/%Y') if task.end_date else '',
                'Duración (días)': duration_days,
                'Progreso (%)': task.progress,
                'Estado de Progreso': progress_status,
                'Dependencias': dependencies_text,
                'Notas': task.notes or '',
                'Fecha de Creación': task.created_at.strftime('%d/%m/%Y %H:%M'),
                'Fecha de Actualización': task.updated_at.strftime('%d/%m/%Y %H:%M'),
            })
        
        # Crear DataFrame
        df = pd.DataFrame(data)
        
        # Crear respuesta HTTP con archivo Excel
        response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
        filename = f"Cronograma_{schedule.title}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
        response['Content-Disposition'] = f'attachment; filename="{filename}"'
        
        # Escribir Excel al response
        with pd.ExcelWriter(response, engine='openpyxl') as writer:
            # Hoja principal con todas las tareas
            df.to_excel(writer, sheet_name='Tareas', index=False)
            
            # Hoja de resumen del cronograma
            summary_data = {
                'Métrica': [
                    'Nombre del Cronograma',
                    'Descripción',
                    'Empresa',
                    'Creado por',
                    'Fecha de Creación',
                    'Fecha de Inicio',
                    'Fecha de Fin',
                    'Total de Tareas',
                    'Tareas Completadas',
                    'Tareas Pendientes',
                    'Tareas Atrasadas',
                    'Porcentaje de Progreso',
                    'Tasa de Cumplimiento',
                ],
                'Valor': [
                    schedule.title,
                    schedule.description or '',
                    schedule.company.name if schedule.company else '',
                    schedule.created_by.get_full_name(),
                    schedule.created_at.strftime('%d/%m/%Y %H:%M'),
                    schedule.start_date.strftime('%d/%m/%Y') if schedule.start_date else '',
                    schedule.end_date.strftime('%d/%m/%Y') if schedule.end_date else '',
                    schedule.get_total_tasks(),
                    schedule.get_completed_tasks(),
                    schedule.get_pending_tasks(),
                    schedule.get_overdue_tasks(),
                    f"{schedule.get_progress_percentage():.1f}%",
                    f"{schedule.get_on_time_completion_rate():.1f}%",
                ]
            }
            
            summary_df = pd.DataFrame(summary_data)
            summary_df.to_excel(writer, sheet_name='Resumen', index=False)
            
            # Ajustar ancho de columnas automáticamente
            for sheet_name in writer.sheets:
                worksheet = writer.sheets[sheet_name]
                for column in worksheet.columns:
                    max_length = 0
                    column_letter = column[0].column_letter
                    for cell in column:
                        try:
                            if len(str(cell.value)) > max_length:
                                max_length = len(str(cell.value))
                        except:
                            pass
                    adjusted_width = min(max_length + 2, 50)  # Máximo 50 caracteres
                    worksheet.column_dimensions[column_letter].width = adjusted_width
        
        return response
        
    except ImportError:
        messages.error(request, 'La funcionalidad de exportación requiere la instalación de pandas. Contacta al administrador.')
        return redirect('task_schedule_detail', pk=pk)
    except Exception as e:
        messages.error(request, f'Error al exportar: {str(e)}')
        return redirect('task_schedule_detail', pk=pk)


@login_required
def task_schedule_edit(request, pk):
    """Vista para editar un cronograma"""
    schedule = get_object_or_404(TaskSchedule, pk=pk)
    
    # Verificar permisos
    if not user_has_company_access(request.user, schedule.company):
        messages.error(request, 'No tienes permiso para editar este cronograma.')
        return redirect('task_schedule_list')
    
    if request.method == 'POST':
        form = TaskScheduleForm(request.POST, instance=schedule)
        if form.is_valid():
            form.save()
            messages.success(request, 'Cronograma actualizado exitosamente.')
            return redirect('task_schedule_detail', pk=schedule.pk)
    else:
        form = TaskScheduleForm(instance=schedule)
        form.fields['company'].queryset = get_user_companies_queryset(request.user)
    
    context = {
        'page_title': f'Editar - {schedule.title}',
        'form': form,
        'schedule': schedule,
        'auto_dates_info': True,
    }
    
    return render(request, 'tickets/task_schedule_form.html', context)


@login_required
def task_schedule_delete(request, pk):
    """Vista para eliminar un cronograma"""
    schedule = get_object_or_404(TaskSchedule, pk=pk)
    
    # Verificar permisos
    if not user_has_company_access(request.user, schedule.company):
        messages.error(request, 'No tienes permiso para eliminar este cronograma.')
        return redirect('task_schedule_list')
    
    if request.method == 'POST':
        schedule.delete()
        messages.success(request, 'Cronograma eliminado exitosamente.')
        return redirect('task_schedule_list')
    
    context = {
        'page_title': f'Eliminar - {schedule.title}',
        'schedule': schedule,
    }
    
    return render(request, 'tickets/task_schedule_delete.html', context)


@login_required
def task_schedule_duplicate(request, pk):
    """Vista para duplicar un cronograma con todas sus tareas"""
    original_schedule = get_object_or_404(TaskSchedule, pk=pk)
    
    # Verificar permisos
    if not user_has_company_access(request.user, original_schedule.company):
        messages.error(request, 'No tienes permiso para duplicar este cronograma.')
        return redirect('task_schedule_list')
    
    if request.method == 'POST':
        try:
            # Crear el cronograma duplicado
            duplicated_schedule = TaskSchedule.objects.create(
                title=f"Copia de {original_schedule.title}",
                description=original_schedule.description,
                company=original_schedule.company,
                start_date=original_schedule.start_date,
                end_date=original_schedule.end_date,
                is_public=False,  # Por seguridad, no hacer público automáticamente
                created_by=request.user,
                # No copiamos el token público - se generará automáticamente
            )
            
            # Duplicar las tareas del cronograma
            original_tasks = ScheduleTask.objects.filter(schedule=original_schedule)
            task_map = {}  # Para mapear dependencias
            
            # Primer paso: crear todas las tareas sin dependencias
            for original_task in original_tasks:
                duplicated_task = ScheduleTask.objects.create(
                    schedule=duplicated_schedule,
                    title=original_task.title,
                    description=original_task.description,
                    start_date=original_task.start_date,
                    end_date=original_task.end_date,
                    priority=original_task.priority,
                    assigned_to=original_task.assigned_to,
                    is_completed=False,  # Las tareas duplicadas empiezan como no completadas
                    progress_percentage=0,  # Progreso en 0
                )
                task_map[original_task.id] = duplicated_task
            
            # Segundo paso: establecer dependencias
            for original_task in original_tasks:
                duplicated_task = task_map[original_task.id]
                for dependency in original_task.dependencies.all():
                    if dependency.id in task_map:
                        duplicated_task.dependencies.add(task_map[dependency.id])
            
            messages.success(
                request, 
                f'Cronograma "{duplicated_schedule.title}" duplicado exitosamente con {len(task_map)} tareas.'
            )
            
            # Redirigir al nuevo cronograma duplicado
            return redirect('task_schedule_detail', pk=duplicated_schedule.pk)
            
        except Exception as e:
            messages.error(request, f'Error al duplicar el cronograma: {str(e)}')
            return redirect('task_schedule_detail', pk=pk)
    
    # Si es GET, mostrar confirmación
    context = {
        'page_title': f'Duplicar Cronograma: {original_schedule.title}',
        'schedule': original_schedule,
        'total_tasks_count': ScheduleTask.objects.filter(schedule=original_schedule).count(),
    }
    
    return render(request, 'tickets/task_schedule_duplicate_confirm.html', context)


@login_required
def task_schedule_reschedule(request, pk):
    """Vista para reprogramar todas las fechas del cronograma"""
    schedule = get_object_or_404(TaskSchedule, pk=pk)
    
    # Verificar permisos
    if not user_has_company_access(request.user, schedule.company):
        messages.error(request, 'No tienes permiso para reprogramar este cronograma.')
        return redirect('task_schedule_list')
    
    if request.method == 'POST':
        try:
            from datetime import datetime, timedelta
            
            new_start_date_str = request.POST.get('new_start_date')
            if not new_start_date_str:
                messages.error(request, 'Debes especificar una nueva fecha de inicio.')
                return redirect('task_schedule_detail', pk=pk)
            
            # Convertir la nueva fecha de inicio
            new_start_date = datetime.strptime(new_start_date_str, '%Y-%m-%d').date()
            
            # Calcular la diferencia de días entre la fecha actual y la nueva
            current_start_date = schedule.start_date
            date_difference = (new_start_date - current_start_date).days
            
            if date_difference == 0:
                messages.info(request, 'La nueva fecha de inicio es la misma que la actual.')
                return redirect('task_schedule_detail', pk=pk)
            
            # Reprogramar todas las tareas
            tasks_updated = 0
            for task in schedule.tasks.all():
                # Calcular las nuevas fechas sumando/restando la diferencia
                task.start_date = task.start_date + timedelta(days=date_difference)
                task.end_date = task.end_date + timedelta(days=date_difference)
                task.save()
                tasks_updated += 1
            
            # Actualizar las fechas del cronograma
            schedule.start_date = new_start_date
            # Calcular la nueva fecha de fin basándose en las tareas actualizadas
            if schedule.tasks.exists():
                schedule.end_date = schedule.tasks.order_by('-end_date').first().end_date
            schedule.save()
            
            messages.success(
                request, 
                f'Cronograma reprogramado exitosamente. Se han actualizado {tasks_updated} tareas. '
                f'{"Adelantado" if date_difference > 0 else "Retrasado"} {abs(date_difference)} días.'
            )
            
        except ValueError:
            messages.error(request, 'Formato de fecha inválido.')
        except Exception as e:
            messages.error(request, f'Error al reprogramar el cronograma: {str(e)}')
    
    return redirect('task_schedule_detail', pk=pk)


# Vista Gantt deshabilitada - funcionalidad removida temporalmente
# @login_required
# def task_schedule_gantt(request, pk):
#     """Vista Gantt del cronograma"""
#     schedule = get_object_or_404(
#         TaskSchedule.objects.select_related('company', 'created_by'),
#         pk=pk
#     )
#     
#     # Verificar permisos
#     if not user_has_company_access(request.user, schedule.company):
#         messages.error(request, 'No tienes permiso para ver este cronograma.')
#         return redirect('task_schedule_list')
#     
#     tasks = schedule.tasks.select_related('assigned_to').prefetch_related('dependencies')
#     
#     # Preparar datos para el Gantt
#     gantt_data = []
#     for task in tasks:
#         gantt_data.append({
#             'id': task.id,
#             'title': task.title,
#             'start': task.start_date.isoformat(),
#             'end': task.end_date.isoformat(),
#             'progress': task.progress_percentage,
#             'is_completed': task.is_completed,
#             'priority': task.priority,
#             'assigned_to': task.assigned_to.get_full_name() if task.assigned_to else 'Sin asignar',
#             'dependencies': [dep.id for dep in task.dependencies.all()],
#             'is_overdue': task.is_overdue(),
#         })
#     
#     # Calcular KPIs
#     kpis = {
#         'total_tasks': schedule.get_total_tasks(),
#         'completed_tasks': schedule.get_completed_tasks(),
#         'pending_tasks': schedule.get_pending_tasks(),
#         'overdue_tasks': schedule.get_overdue_tasks(),
#         'progress_percentage': schedule.get_progress_percentage(),
#         'on_time_rate': schedule.get_on_time_completion_rate(),
#     }
#     
#     context = {
#         'page_title': f'Vista Gantt - {schedule.title}',
#         'schedule': schedule,
#         'gantt_data': json.dumps(gantt_data),
#         'kpis': kpis,
#     }
#     
#     return render(request, 'tickets/task_schedule_gantt.html', context)


# Task CRUD
@login_required
def schedule_task_create(request, schedule_pk):
    """Vista para crear una nueva tarea"""
    schedule = get_object_or_404(TaskSchedule, pk=schedule_pk)
    
    # Verificar permisos
    if not user_has_company_access(request.user, schedule.company):
        messages.error(request, 'No tienes permiso para agregar tareas a este cronograma.')
        return redirect('task_schedule_list')
    
    if request.method == 'POST':
        form = ScheduleTaskForm(request.POST, schedule=schedule)
        if form.is_valid():
            task = form.save(commit=False)
            task.schedule = schedule
            task.save()
            form.save_m2m()  # Guardar relaciones many-to-many
            messages.success(request, 'Tarea creada exitosamente.')
            return redirect('task_schedule_detail', pk=schedule.pk)
    else:
        # Establecer fechas por defecto del cronograma
        initial = {
            'start_date': schedule.start_date,
            'end_date': schedule.end_date,
        }
        form = ScheduleTaskForm(initial=initial, schedule=schedule)
    
    context = {
        'page_title': f'Nueva Tarea - {schedule.title}',
        'form': form,
        'schedule': schedule,
    }
    
    return render(request, 'tickets/schedule_task_form.html', context)


@login_required
def schedule_task_edit(request, pk):
    """Vista para editar una tarea"""
    task = get_object_or_404(ScheduleTask.objects.select_related('schedule'), pk=pk)
    schedule = task.schedule
    
    # Verificar permisos
    if not user_has_company_access(request.user, schedule.company):
        messages.error(request, 'No tienes permiso para editar esta tarea.')
        return redirect('task_schedule_list')
    
    if request.method == 'POST':
        form = ScheduleTaskForm(request.POST, instance=task, schedule=schedule)
        if form.is_valid():
            form.save()
            messages.success(request, 'Tarea actualizada exitosamente.')
            return redirect('task_schedule_detail', pk=schedule.pk)
    else:
        form = ScheduleTaskForm(instance=task, schedule=schedule)
    
    context = {
        'page_title': f'Editar Tarea - {task.title}',
        'form': form,
        'schedule': schedule,
        'task': task,
    }
    
    return render(request, 'tickets/schedule_task_form.html', context)


@login_required
def schedule_task_delete(request, pk):
    """Vista para eliminar una tarea"""
    task = get_object_or_404(ScheduleTask.objects.select_related('schedule'), pk=pk)
    schedule = task.schedule
    
    # Verificar permisos
    if not user_has_company_access(request.user, schedule.company):
        messages.error(request, 'No tienes permiso para eliminar esta tarea.')
        return redirect('task_schedule_list')
    
    if request.method == 'POST':
        task.delete()
        messages.success(request, 'Tarea eliminada exitosamente.')
        return redirect('task_schedule_detail', pk=schedule.pk)
    
    context = {
        'page_title': f'Eliminar Tarea - {task.title}',
        'task': task,
        'schedule': schedule,
    }
    
    return render(request, 'tickets/schedule_task_delete.html', context)


@login_required
def schedule_task_toggle(request, pk):
    """Vista para marcar/desmarcar una tarea como completada (AJAX)"""
    if request.method == 'POST':
        task = get_object_or_404(ScheduleTask, pk=pk)
        
        # Verificar permisos
        if not user_has_company_access(request.user, task.schedule.company):
            return JsonResponse({'success': False, 'error': 'No tienes permiso.'}, status=403)
        
        task.is_completed = not task.is_completed
        # Establecer progreso automáticamente según el estado
        if task.is_completed:
            task.progress_percentage = 100
        else:
            task.progress_percentage = 0
        task.save()
        
        return JsonResponse({
            'success': True,
            'is_completed': task.is_completed,
            'completed_at': task.completed_at.strftime('%d/%m/%Y %H:%M') if task.completed_at else None,
            'progress': task.progress_percentage,
        })
    
    return JsonResponse({'success': False}, status=400)


# Vista pública del cronograma
def task_schedule_public(request, token):
    """Vista pública del cronograma con token"""
    schedule = get_object_or_404(
        TaskSchedule.objects.select_related('company', 'created_by'),
        public_token=token,
        is_public=True
    )
    
    tasks = schedule.tasks.select_related('assigned_to').prefetch_related('dependencies')
    
    # Calcular total de días
    total_days = sum(task.get_duration_days() for task in tasks)
    
    # Calcular KPIs
    kpis = {
        'total_tasks': schedule.get_total_tasks(),
        'completed_tasks': schedule.get_completed_tasks(),
        'pending_tasks': schedule.get_pending_tasks(),
        'overdue_tasks': schedule.get_overdue_tasks(),
        'progress_percentage': schedule.get_progress_percentage(),
        'on_time_rate': schedule.get_on_time_completion_rate(),
    }
    
    context = {
        'page_title': schedule.title,
        'schedule': schedule,
        'tasks': tasks,
        'kpis': kpis,
        'total_days': total_days,
        'is_public_view': True,
    }
    
    return render(request, 'tickets/task_schedule_public.html', context)


def task_schedule_public_gantt(request, token):
    """Vista Gantt pública del cronograma"""
    schedule = get_object_or_404(
        TaskSchedule.objects.select_related('company', 'created_by'),
        public_token=token,
        is_public=True
    )
    
    tasks = schedule.tasks.select_related('assigned_to').prefetch_related('dependencies')
    
    # Preparar datos para el Gantt
    gantt_data = []
    for task in tasks:
        gantt_data.append({
            'id': task.id,
            'title': task.title,
            'start': task.start_date.isoformat(),
            'end': task.end_date.isoformat(),
            'progress': task.progress_percentage,
            'is_completed': task.is_completed,
            'priority': task.priority,
            'assigned_to': task.assigned_to.get_full_name() if task.assigned_to else 'Sin asignar',
            'dependencies': [dep.id for dep in task.dependencies.all()],
            'is_overdue': task.is_overdue(),
        })
    
    # Calcular KPIs
    kpis = {
        'total_tasks': schedule.get_total_tasks(),
        'completed_tasks': schedule.get_completed_tasks(),
        'pending_tasks': schedule.get_pending_tasks(),
        'overdue_tasks': schedule.get_overdue_tasks(),
        'progress_percentage': schedule.get_progress_percentage(),
        'on_time_rate': schedule.get_on_time_completion_rate(),
    }
    
    context = {
        'page_title': f'Vista Gantt - {schedule.title}',
        'schedule': schedule,
        'gantt_data': json.dumps(gantt_data),
        'kpis': kpis,
        'is_public_view': True,
    }
    
    return render(request, 'tickets/task_schedule_public_gantt.html', context)


def schedule_task_toggle_public(request, pk):
    """Vista pública para marcar/desmarcar una tarea como completada (AJAX)"""
    if request.method == 'POST':
        task = get_object_or_404(ScheduleTask, pk=pk)
        
        # Verificar que la tarea pertenece a un cronograma público
        if not task.schedule.is_public:
            return JsonResponse({'success': False, 'error': 'Esta tarea no es pública.'}, status=403)
        
        # Verificar el token si se proporciona
        import json
        try:
            data = json.loads(request.body)
            token = data.get('token')
            if token and str(task.schedule.public_token) != str(token):
                return JsonResponse({'success': False, 'error': 'Token inválido.'}, status=403)
        except json.JSONDecodeError:
            pass
        
        task.is_completed = not task.is_completed
        # Establecer progreso automáticamente según el estado
        if task.is_completed:
            task.progress_percentage = 100
        else:
            task.progress_percentage = 0
        task.save()
        
        return JsonResponse({
            'success': True,
            'is_completed': task.is_completed,
            'completed_at': task.completed_at.strftime('%d/%m/%Y %H:%M') if task.completed_at else None,
            'progress': task.progress_percentage,
        })
    
    return JsonResponse({'success': False}, status=400)


@login_required
def world_clock_view(request):
    """Vista del reloj mundial con países de habla hispana organizados por franjas horarias"""
    
    # Países organizados por franjas horarias UTC - España primero
    countries_by_timezone = {
        'UTC+1 (España)': [
            {'name': 'España', 'timezone': 'Europe/Madrid', 'flag': '🇪🇸'},
        ],
        'UTC-2 (Atlántico)': [
            {'name': 'Azores (Portugal)', 'timezone': 'Atlantic/Azores', 'flag': '🇵🇹'},
            {'name': 'Cabo Verde', 'timezone': 'Atlantic/Cape_Verde', 'flag': '🇨🇻'},
        ],
        'UTC-6 (Centro América)': [
            {'name': 'México', 'timezone': 'America/Mexico_City', 'flag': '🇲🇽'},
            {'name': 'Guatemala', 'timezone': 'America/Guatemala', 'flag': '🇬🇹'},
        ],
        'UTC-5 (Región Andina)': [
            {'name': 'Ecuador', 'timezone': 'America/Guayaquil', 'flag': '🇪🇨'},
            {'name': 'Perú', 'timezone': 'America/Lima', 'flag': '🇵🇪'},
            {'name': 'Cuba', 'timezone': 'America/Havana', 'flag': '🇨🇺'},
        ],
        'UTC-4 (Caribe y Venezuela)': [
            {'name': 'República Dominicana', 'timezone': 'America/Santo_Domingo', 'flag': '🇩🇴'},
            {'name': 'Venezuela', 'timezone': 'America/Caracas', 'flag': '🇻🇪'},
            {'name': 'Bolivia', 'timezone': 'America/La_Paz', 'flag': '🇧🇴'},
        ],
        'UTC-3 (Cono Sur)': [
            {'name': 'Argentina', 'timezone': 'America/Argentina/Buenos_Aires', 'flag': '🇦🇷'},
            {'name': 'Uruguay', 'timezone': 'America/Montevideo', 'flag': '🇺🇾'},
            {'name': 'Paraguay', 'timezone': 'America/Asuncion', 'flag': '🇵🇾'},
        ],
        'UTC-3/-4 (Chile)': [
            {'name': 'Chile', 'timezone': 'America/Santiago', 'flag': '🇨🇱'},
        ],
    }
    
    context = {
        'page_title': 'Reloj Mundial - Países de Habla Hispana',
        'countries_by_timezone': countries_by_timezone,
    }
    
    return render(request, 'tickets/world_clock.html', context)


# ====================================
# VISTAS DE ACCIONES FINANCIERAS
# ====================================

@login_required
@user_passes_test(is_agent, login_url='/')
def financial_actions_list_view(request):
    """Vista para listar todas las acciones financieras"""
    from .models import FinancialAction
    
    actions = FinancialAction.objects.all().order_by('order', 'symbol')
    
    # Búsqueda
    search = request.GET.get('search')
    if search:
        actions = actions.filter(
            models.Q(symbol__icontains=search) |
            models.Q(name__icontains=search)
        )
    
    # Filtro por estado activo
    status = request.GET.get('status')
    if status == 'active':
        actions = actions.filter(is_active=True)
    elif status == 'inactive':
        actions = actions.filter(is_active=False)
    
    context = {
        'page_title': 'Gestión de Acciones Financieras',
        'actions': actions,
        'search': search,
        'status': status,
    }
    
    return render(request, 'tickets/financial_actions_list.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def financial_action_create_view(request):
    """Vista para crear una nueva acción financiera"""
    from .models import FinancialAction
    from .forms import FinancialActionForm
    
    if request.method == 'POST':
        form = FinancialActionForm(request.POST)
        if form.is_valid():
            action = form.save()
            messages.success(request, f'Acción financiera "{action.symbol}" creada exitosamente.')
            return redirect('financial_actions_list')
        else:
            messages.error(request, 'Por favor, corrige los errores en el formulario.')
    else:
        # Obtener el siguiente orden sugerido
        last_action = FinancialAction.objects.order_by('-order').first()
        suggested_order = (last_action.order + 1) if last_action else 1
        
        form = FinancialActionForm(initial={'order': suggested_order})
    
    context = {
        'page_title': 'Crear Acción Financiera',
        'form': form,
        'suggested_order': form.initial.get('order', 1),
        'is_edit': False,
    }
    
    return render(request, 'tickets/financial_action_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def financial_action_edit_view(request, pk):
    """Vista para editar una acción financiera"""
    from .models import FinancialAction
    from .forms import FinancialActionForm
    
    action = get_object_or_404(FinancialAction, pk=pk)
    
    if request.method == 'POST':
        form = FinancialActionForm(request.POST, instance=action)
        if form.is_valid():
            # No actualizar los campos de precio si vienen en el POST
            # Ya que deben ser de solo lectura
            cleaned_data = form.cleaned_data.copy()
            if action.pk:  # Si es edición, mantener precios existentes
                cleaned_data.pop('current_price', None)
                cleaned_data.pop('previous_price', None)
            
            # Actualizar solo los campos editables
            for field, value in cleaned_data.items():
                if field not in ['current_price', 'previous_price']:
                    setattr(action, field, value)
            
            action.save()
            messages.success(request, f'Acción financiera "{action.symbol}" actualizada exitosamente.')
            return redirect('financial_actions_list')
        else:
            messages.error(request, 'Por favor, corrige los errores en el formulario.')
    else:
        form = FinancialActionForm(instance=action)
    
    # Obtener el siguiente orden sugerido por si lo necesita
    last_action = FinancialAction.objects.order_by('-order').first()
    suggested_order = (last_action.order + 1) if last_action else 1
    
    context = {
        'page_title': f'Editar - {action.symbol}',
        'action': action,
        'form': form,
        'suggested_order': suggested_order,
        'is_edit': True,
    }
    
    return render(request, 'tickets/financial_action_form.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def financial_action_delete_view(request, pk):
    """Vista para eliminar una acción financiera"""
    from .models import FinancialAction
    
    action = get_object_or_404(FinancialAction, pk=pk)
    
    if request.method == 'POST':
        try:
            symbol = action.symbol
            action.delete()
            messages.success(request, f'Acción financiera "{symbol}" eliminada exitosamente.')
            return redirect('financial_actions_list')
            
        except Exception as e:
            messages.error(request, f'Error eliminando acción financiera: {str(e)}')
            return redirect('financial_actions_list')
    
    context = {
        'page_title': f'Eliminar - {action.symbol}',
        'action': action,
    }
    
    return render(request, 'tickets/financial_action_delete.html', context)


@login_required
@user_passes_test(is_agent, login_url='/')
def financial_action_toggle_view(request, pk):
    """Vista para activar/desactivar una acción financiera"""
    from .models import FinancialAction
    
    action = get_object_or_404(FinancialAction, pk=pk)
    action.is_active = not action.is_active
    action.save()
    
    status = 'activada' if action.is_active else 'desactivada'
    messages.success(request, f'Acción financiera "{action.symbol}" {status} exitosamente.')
    
    return redirect('financial_actions_list')


def financial_actions_ticker_data_view(request):
    """Vista AJAX para obtener datos del ticker de acciones"""
    from .models import FinancialAction
    from django.http import JsonResponse
    
    actions = FinancialAction.objects.filter(is_active=True).order_by('order', 'symbol')
    
    data = []
    for action in actions:
        data.append({
            'id': action.id,
            'symbol': action.symbol,
            'name': action.name,
            'current_price': float(action.current_price) if action.current_price is not None else 0.0,
            'previous_price': float(action.previous_price) if action.previous_price else None,
            'currency': action.currency,
            'price_change': float(action.price_change) if hasattr(action, 'price_change') and action.price_change is not None else 0.0,
            'price_change_percent': float(action.price_change_percent) if hasattr(action, 'price_change_percent') and action.price_change_percent is not None else 0.0,
            'is_positive_change': action.is_positive_change if hasattr(action, 'is_positive_change') else False,
            'is_negative_change': action.is_negative_change if hasattr(action, 'is_negative_change') else False,
            'change_color_class': action.change_color_class if hasattr(action, 'change_color_class') else '',
        })
    
    return JsonResponse({'actions': data})


@login_required
@user_passes_test(lambda u: u.is_staff or hasattr(u, 'role') and u.role in ['agente'])
def financial_actions_update_prices_view(request):
    """Vista para actualizar precios de acciones financieras desde APIs externas"""
    if request.method == 'POST':
        from .financial_api import update_all_financial_prices
        
        try:
            updated_count = update_all_financial_prices()
            
            return JsonResponse({
                'success': True,
                'message': f'Precios actualizados exitosamente: {updated_count} acciones',
                'updated_count': updated_count
            })
            
        except Exception as e:
            return JsonResponse({
                'success': False,
                'message': f'Error actualizando precios: {str(e)}'
            })
    
    return JsonResponse({'success': False, 'message': 'Método no permitido'})


@login_required
@user_passes_test(lambda u: u.is_staff or hasattr(u, 'role') and u.role in ['agente'])
def financial_action_update_single_price_view(request, pk):
    """Vista para actualizar precio de una acción específica"""
    if request.method == 'POST':
        from .financial_api import FinancialDataAPI
        from .models import FinancialAction
        
        try:
            action = get_object_or_404(FinancialAction, pk=pk)
            api = FinancialDataAPI()
            
            if api.update_price(action):
                return JsonResponse({
                    'success': True,
                    'message': f'Precio de {action.symbol} actualizado exitosamente',
                    'new_price': float(action.current_price),
                    'previous_price': float(action.previous_price) if action.previous_price else None,
                    'price_change': float(action.price_change),
                    'price_change_percent': float(action.price_change_percent),
                    'last_updated': action.last_updated.strftime('%d/%m/%Y %H:%M'),
                })
            else:
                return JsonResponse({
                    'success': False,
                    'message': f'No se pudo obtener precio actualizado para {action.symbol}'
                })
                
        except FinancialAction.DoesNotExist:
            return JsonResponse({
                'success': False,
                'message': 'Acción financiera no encontrada'
            })
        except Exception as e:
            return JsonResponse({
                'success': False,
                'message': f'Error actualizando precio: {str(e)}'
            })
    
    return JsonResponse({'success': False, 'message': 'Método no permitido'})


@login_required
def meeting_ai_recommendations_view(request):
    """Vista para generar propuestas específicas para el cliente basadas en el contenido de la reunión"""
    if request.method == 'POST':
        try:
            import json
            data = json.loads(request.body)
            content = data.get('content', '').strip()
            
            if not content:
                return JsonResponse({
                    'success': False,
                    'message': 'No se proporcionó contenido para analizar'
                })
            
            # Generar propuestas específicas para el cliente
            proposals = generate_client_proposals(content.lower())
            
            return JsonResponse({
                'success': True,
                'recommendations': proposals[:5],  # Máximo 5 propuestas
                'analysis_summary': f'Analicé {len(content.split())} palabras y generé {len(proposals[:5])} propuestas específicas para el cliente.'
            })
            
        except json.JSONDecodeError:
            return JsonResponse({
                'success': False,
                'message': 'Formato de datos inválido'
            })
        except Exception as e:
            return JsonResponse({
                'success': False,
                'message': f'Error procesando propuestas: {str(e)}'
            })
    
    return JsonResponse({'success': False, 'message': 'Método no permitido'})


def generate_client_proposals(content):
    """
    Genera propuestas específicas para el cliente basadas en el análisis del contenido
    """
    proposals = []
    
    # Análisis de industria/sector
    if any(word in content for word in ['tienda', 'venta', 'producto', 'inventario', 'retail', 'comercio']):
        proposals.append({
            'type': 'solution',
            'icon': 'fa-store',
            'title': 'Sistema de Gestión de Inventario Inteligente',
            'suggestion': '🎯 Propuesta: Implementar sistema automatizado que optimice control de stock, reduzca mermas 25% y mejore rotación de productos con alertas inteligentes de restock.',
            'action': 'Proponer Sistema de Inventario',
            'priority': 'high'
        })
    
    if any(word in content for word in ['ventas', 'clientes', 'crm', 'marketing', 'leads']):
        proposals.append({
            'type': 'crm',
            'icon': 'fa-users',
            'title': 'Plataforma CRM con Automatización de Marketing',
            'suggestion': '🎯 Propuesta: Centralizar gestión de clientes con automatización de campañas, aumento del 40% en conversión de leads y reportes en tiempo real.',
            'action': 'Implementar CRM Personalizado',
            'priority': 'high'
        })
    
    if any(word in content for word in ['empleados', 'nómina', 'recursos humanos', 'personal', 'asistencia']):
        proposals.append({
            'type': 'hr',
            'icon': 'fa-user-friends',
            'title': 'Sistema Integral de Recursos Humanos',
            'suggestion': '🎯 Propuesta: Digitalizar RR.HH. con control de asistencia biométrico, nóminas automatizadas y evaluaciones de desempeño. Ahorro de 15 horas semanales.',
            'action': 'Desarrollar Módulo de RR.HH.',
            'priority': 'medium'
        })
    
    if any(word in content for word in ['finanzas', 'contabilidad', 'facturación', 'impuestos', 'fiscal']):
        proposals.append({
            'type': 'finance',
            'icon': 'fa-calculator',
            'title': 'Módulo Financiero con Facturación Electrónica',
            'suggestion': '🎯 Propuesta: Automatizar gestión financiera con facturación electrónica, control de flujo de caja y reportes fiscales automáticos para cumplimiento normativo.',
            'action': 'Implementar Sistema Financiero',
            'priority': 'high'
        })
    
    if any(word in content for word in ['sitio web', 'online', 'internet', 'digital', 'e-commerce', 'página']):
        proposals.append({
            'type': 'web',
            'icon': 'fa-globe',
            'title': 'Presencia Digital Completa con E-commerce',
            'suggestion': '🎯 Propuesta: Desarrollar plataforma web con tienda online 24/7, múltiples métodos de pago, integración con redes sociales y marketing digital automático.',
            'action': 'Crear Plataforma Digital',
            'priority': 'medium'
        })
    
    if any(word in content for word in ['automatización', 'procesos', 'eficiencia', 'optimización', 'workflow']):
        proposals.append({
            'type': 'automation',
            'icon': 'fa-cogs',
            'title': 'Suite de Automatización de Procesos',
            'suggestion': '🎯 Propuesta: Automatizar procesos repetitivos con workflows inteligentes, reducir 60% tareas manuales y eliminar errores humanos.',
            'action': 'Desarrollar Automatización',
            'priority': 'medium'
        })
    
    if any(word in content for word in ['móvil', 'app', 'aplicación', 'smartphone', 'celular']):
        proposals.append({
            'type': 'mobile',
            'icon': 'fa-mobile-alt',
            'title': 'Aplicación Móvil Nativa para Clientes',
            'suggestion': '🎯 Propuesta: Desarrollar app móvil para iOS/Android con autoservicio, notificaciones push personalizadas y mayor engagement 24/7 con clientes.',
            'action': 'Desarrollar App Móvil',
            'priority': 'medium'
        })
    
    if any(word in content for word in ['seguridad', 'backup', 'protección', 'datos', 'ciberseguridad']):
        proposals.append({
            'type': 'security',
            'icon': 'fa-shield-alt',
            'title': 'Solución Integral de Seguridad y Backup',
            'suggestion': '🎯 Propuesta: Implementar seguridad multicapa con protección 99.9% contra amenazas, backups automáticos diarios y cumplimiento normativo.',
            'action': 'Implementar Seguridad Avanzada',
            'priority': 'high'
        })
    
    if any(word in content for word in ['reportes', 'análisis', 'datos', 'métricas', 'dashboard', 'kpi']):
        proposals.append({
            'type': 'analytics',
            'icon': 'fa-chart-line',
            'title': 'Plataforma de Business Intelligence',
            'suggestion': '🎯 Propuesta: Implementar dashboards ejecutivos con KPIs en tiempo real, alertas automáticas y análisis predictivo para decisiones basadas en datos.',
            'action': 'Desarrollar BI Dashboard',
            'priority': 'medium'
        })
    
    if any(word in content for word in ['capacitación', 'entrenamiento', 'formación', 'aprendizaje', 'educación']):
        proposals.append({
            'type': 'training',
            'icon': 'fa-graduation-cap',
            'title': 'Plataforma de Capacitación Digital',
            'suggestion': '🎯 Propuesta: Crear LMS personalizado con cursos interactivos, certificaciones automáticas y seguimiento de progreso para maximizar adopción tecnológica.',
            'action': 'Diseñar Plataforma Educativa',
            'priority': 'medium'
        })
    
    # Si no se detecta contenido específico, generar propuestas generales inteligentes
    if not proposals:
        proposals = [
            {
                'type': 'consultation',
                'icon': 'fa-lightbulb',
                'title': 'Consultoría de Transformación Digital Gratuita',
                'suggestion': '🎯 Propuesta: Análisis completo de procesos actuales con roadmap personalizado de digitalización, diagnóstico gratuito y ROI proyectado.',
                'action': 'Realizar Consultoría Estratégica',
                'priority': 'high'
            },
            {
                'type': 'pilot',
                'icon': 'fa-flask',
                'title': 'Proyecto Piloto de Automatización',
                'suggestion': '🎯 Propuesta: Implementar solución piloto en área específica para demostrar valor tangible antes de expansión, con inversión inicial mínima.',
                'action': 'Iniciar Proyecto Piloto',
                'priority': 'medium'
            },
            {
                'type': 'integration',
                'icon': 'fa-link',
                'title': 'Integración de Sistemas Existentes',
                'suggestion': '🎯 Propuesta: Conectar sistemas actuales mediante APIs robustas para eliminar silos de información y crear flujo de datos unificado.',
                'action': 'Integrar Sistemas Actuales',
                'priority': 'high'
            },
            {
                'type': 'support',
                'icon': 'fa-headset',
                'title': 'Mesa de Ayuda Especializada',
                'suggestion': '🎯 Propuesta: Implementar sistema de tickets con IA para soporte técnico 24/7, categorización automática y resolución proactiva.',
                'action': 'Crear Mesa de Ayuda',
                'priority': 'medium'
            },
            {
                'type': 'maintenance',
                'icon': 'fa-tools',
                'title': 'Plan de Mantenimiento Preventivo',
                'suggestion': '🎯 Propuesta: Establecer mantenimiento predictivo con monitoreo continuo, actualizaciones automáticas y garantía de uptime 99.9%.',
                'action': 'Estructurar Plan de Mantenimiento',
                'priority': 'medium'
            }
        ]
    
    return proposals


@login_required
def meeting_pdf_download_view(request, pk):
    """Vista para descargar reunión en formato PDF"""
    try:
        meeting = get_object_or_404(Meeting, pk=pk)
        
        # Verificar permisos
        if not request.user.is_staff and meeting.created_by != request.user:
            return HttpResponse('No tiene permisos para acceder a esta reunión', status=403)
        
        # Importar librerías de PDF
        from reportlab.lib.pagesizes import letter, A4
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.units import inch
        from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
        from reportlab.lib import colors
        from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
        from io import BytesIO
        import datetime
        
        # Crear buffer en memoria
        buffer = BytesIO()
        
        # Crear documento PDF
        doc = SimpleDocTemplate(
            buffer,
            pagesize=A4,
            rightMargin=72,
            leftMargin=72,
            topMargin=72,
            bottomMargin=18
        )
        
        # Obtener estilos
        styles = getSampleStyleSheet()
        
        # Crear estilos personalizados
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=24,
            textColor=colors.HexColor('#2c3e50'),
            alignment=TA_CENTER,
            spaceAfter=30
        )
        
        heading_style = ParagraphStyle(
            'CustomHeading',
            parent=styles['Heading2'],
            fontSize=16,
            textColor=colors.HexColor('#34495e'),
            spaceBefore=20,
            spaceAfter=12
        )
        
        normal_style = ParagraphStyle(
            'CustomNormal',
            parent=styles['Normal'],
            fontSize=11,
            textColor=colors.HexColor('#2c3e50'),
            spaceAfter=12
        )
        
        # Lista para almacenar elementos del PDF
        story = []
        
        # Título principal
        story.append(Paragraph("📋 REPORTE DE REUNIÓN", title_style))
        story.append(Spacer(1, 20))
        
        # Información básica de la reunión
        info_data = [
            ['Título:', meeting.title or 'Sin título'],
            ['Fecha:', meeting.created_at.strftime('%d/%m/%Y %H:%M')],
            ['Creado por:', f"{meeting.created_by.first_name} {meeting.created_by.last_name}" if meeting.created_by.first_name else meeting.created_by.username],
            ['Empresa:', meeting.company.name if meeting.company else 'No especificada'],
            ['Contacto:', meeting.contact.name if meeting.contact else 'No especificado'],
            ['Estado:', meeting.get_status_display() if hasattr(meeting, 'get_status_display') else 'Activa'],
        ]
        
        # Crear tabla de información
        info_table = Table(info_data, colWidths=[2*inch, 4*inch])
        info_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ecf0f1')),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#2c3e50')),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#bdc3c7')),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
        ]))
        
        story.append(info_table)
        story.append(Spacer(1, 30))
        
        # Descripción de la reunión
        if meeting.description:
            story.append(Paragraph("📝 DESCRIPCIÓN DE LA REUNIÓN", heading_style))
            # Dividir la descripción en párrafos
            description_paragraphs = meeting.description.split('\n')
            for para in description_paragraphs:
                if para.strip():
                    story.append(Paragraph(para.strip(), normal_style))
            story.append(Spacer(1, 20))
        
        # Objetivos (si existen)
        if hasattr(meeting, 'objectives') and meeting.objectives:
            story.append(Paragraph("🎯 OBJETIVOS", heading_style))
            story.append(Paragraph(meeting.objectives, normal_style))
            story.append(Spacer(1, 20))
        
        # Participantes (si existen)
        if hasattr(meeting, 'attendees') and meeting.attendees.exists():
            story.append(Paragraph("👥 PARTICIPANTES", heading_style))
            attendees_list = []
            for attendee in meeting.attendees.all():
                attendees_list.append(f"• {attendee.name} ({attendee.email})")
            attendees_text = "<br/>".join(attendees_list)
            story.append(Paragraph(attendees_text, normal_style))
            story.append(Spacer(1, 20))
        
        # Temas tratados (extraer de la descripción si contiene estructura)
        if meeting.description and ('🎯 PROPUESTA' in meeting.description or '📋 Acción:' in meeting.description):
            story.append(Paragraph("💡 PROPUESTAS Y ACCIONES", heading_style))
            
            # Extraer propuestas de la descripción
            description_lines = meeting.description.split('\n')
            proposals = []
            current_proposal = None
            
            for line in description_lines:
                if '🎯 PROPUESTA PRESENTADA:' in line:
                    if current_proposal:
                        proposals.append(current_proposal)
                    current_proposal = {'title': line.replace('🎯 PROPUESTA PRESENTADA:', '').strip()}
                elif current_proposal and '📋 Acción:' in line:
                    current_proposal['action'] = line.replace('📋 Acción:', '').strip()
                elif current_proposal and '⏰ Fecha:' in line:
                    current_proposal['date'] = line.replace('⏰ Fecha:', '').strip()
                    proposals.append(current_proposal)
                    current_proposal = None
            
            if current_proposal:
                proposals.append(current_proposal)
            
            if proposals:
                for i, proposal in enumerate(proposals, 1):
                    story.append(Paragraph(f"<b>Propuesta {i}:</b> {proposal.get('title', 'Sin título')}", normal_style))
                    if proposal.get('action'):
                        story.append(Paragraph(f"<b>Acción:</b> {proposal.get('action')}", normal_style))
                    if proposal.get('date'):
                        story.append(Paragraph(f"<b>Fecha:</b> {proposal.get('date')}", normal_style))
                    story.append(Spacer(1, 10))
        
        # Notas adicionales
        if hasattr(meeting, 'notes') and meeting.notes:
            story.append(Paragraph("📝 NOTAS ADICIONALES", heading_style))
            story.append(Paragraph(meeting.notes, normal_style))
            story.append(Spacer(1, 20))
        
        # Próximos pasos
        story.append(Paragraph("🔜 PRÓXIMOS PASOS", heading_style))
        next_steps = [
            "• Revisar puntos acordados en la reunión",
            "• Programar seguimiento según cronograma definido",
            "• Implementar acciones específicas discutidas",
            "• Preparar documentación adicional si es necesaria"
        ]
        story.append(Paragraph("<br/>".join(next_steps), normal_style))
        story.append(Spacer(1, 30))
        
        # Pie de página con información del reporte
        footer_style = ParagraphStyle(
            'Footer',
            parent=styles['Normal'],
            fontSize=9,
            textColor=colors.HexColor('#7f8c8d'),
            alignment=TA_CENTER
        )
        
        footer_text = f"Reporte generado el {datetime.datetime.now().strftime('%d/%m/%Y a las %H:%M')} | TicketProo - Sistema de Gestión"
        story.append(Paragraph(footer_text, footer_style))
        
        # Construir PDF
        doc.build(story)
        
        # Obtener valor del buffer
        pdf = buffer.getvalue()
        buffer.close()
        
        # Crear respuesta HTTP
        response = HttpResponse(content_type='application/pdf')
        filename = f"reunion_{meeting.id}_{datetime.datetime.now().strftime('%Y%m%d_%H%M')}.pdf"
        response['Content-Disposition'] = f'attachment; filename="{filename}"'
        response.write(pdf)
        
        return response
        
    except Exception as e:
        messages.error(request, f'Error al generar PDF: {str(e)}')
        return redirect('meeting_edit', pk=pk)


@require_http_methods(["POST"])
@login_required
def generate_spin_methodology_view(request):
    """
    Genera preguntas usando la metodología SPIN de ventas basándose en el contexto con IA
    """
    try:
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        company_id = data.get('company_id', '')
        product_id = data.get('product_id', '')
        
        if not description:
            return JsonResponse({
                'success': False,
                'message': 'Se requiere una descripción para generar la metodología SPIN'
            })
        
        # Obtener información de la empresa si está disponible
        company_info = ""
        if company_id:
            try:
                from .models import Company
                company = Company.objects.get(id=company_id)
                company_info = f"""
INFORMACIÓN DE LA EMPRESA:
- Nombre: {company.name}
- Sector: {getattr(company, 'industry', 'No especificado')}
- Descripción: {getattr(company, 'description', 'No disponible')}
- Tamaño: {getattr(company, 'size', 'No especificado')}
"""
            except:
                company_info = ""
        
        # Obtener información del producto si está disponible
        product_info = ""
        if product_id:
            try:
                from .models import Product
                product = Product.objects.get(id=product_id, is_active=True)
                product_info = f"""
PRODUCTO A DISCUTIR:
- Nombre: {product.name}
- Precio: {product.get_formatted_price()}
- Descripción: {product.description}
"""
            except:
                product_info = ""
        
        # Generar preguntas SPIN usando IA configurada
        spin_questions = generate_spin_questions_with_ai(description, company_info, product_info)
        
        if spin_questions is None:
            return JsonResponse({
                'success': False,
                'message': 'Error: La IA no está configurada o no está disponible'
            })
        
        return JsonResponse({
            'success': True,
            'spin_questions': spin_questions,
            'message': 'Metodología SPIN generada exitosamente con IA'
        })
        
    except json.JSONDecodeError:
        return JsonResponse({
            'success': False,
            'message': 'Datos JSON inválidos'
        }, status=400)
    except Exception as e:
        return JsonResponse({
            'success': False,
            'message': f'Error generando metodología SPIN: {str(e)}'
        }, status=500)


def generate_spin_questions_with_ai(description, company_info="", product_info=""):
    """
    Genera preguntas SPIN personalizadas usando la IA configurada
    """
    from .models import SystemConfiguration
    
    config = SystemConfiguration.objects.first()
    if not config or not config.ai_chat_enabled or not config.openai_api_key:
        return None
        
    try:
        import openai
        client = openai.OpenAI(api_key=config.openai_api_key)
        
        prompt = f"""
Eres un experto en metodología SPIN de ventas. Basándote en el contexto proporcionado, genera una guía completa de preguntas SPIN (Situation, Problem, Implication, Need-Payoff) personalizada y profesional.

CONTEXTO DE LA REUNIÓN:
{description}

{company_info}

{product_info}

INSTRUCCIONES:
- Analiza el contexto, la información de la empresa y los productos mencionados
- Genera 4-6 preguntas específicas para cada categoría SPIN
- Las preguntas deben ser relevantes al contexto específico mencionado
- Si hay productos específicos, incluye preguntas relacionadas con sus características, precio y beneficios
- Incluye una estrategia de implementación
- Formato profesional con emojis y estructura clara
- Adapta las preguntas al sector y situación específica

ESTRUCTURA REQUERIDA:
🎯 METODOLOGÍA SPIN - PREGUNTAS ESTRATÉGICAS

📊 S - PREGUNTAS DE SITUACIÓN (Understanding Current State)
[4-6 preguntas específicas al contexto y productos]

⚠️ P - PREGUNTAS DE PROBLEMA (Identifying Pain Points)  
[4-6 preguntas que identifiquen dolor específico relacionado con la situación y productos]

🔥 I - PREGUNTAS DE IMPLICACIÓN (Consequences & Impact)
[4-6 preguntas sobre consecuencias de no actuar, considerando los productos ofrecidos]

✅ N - PREGUNTAS DE NECESIDAD-BENEFICIO (Value Proposition)
[4-6 preguntas sobre valor y beneficios específicos de los productos]

🎯 ESTRATEGIA RECOMENDADA:
[Estrategia específica basada en el contexto y productos a discutir]

📋 PRÓXIMOS PASOS:
[Acciones concretas para esta situación]

Haz que las preguntas sean profesionales, directas y adaptadas específicamente al contexto proporcionado.
"""
        
        response = client.chat.completions.create(
            model=config.openai_model or "gpt-4o",
            messages=[
                {"role": "system", "content": "Eres un experto consultor en ventas especializado en la metodología SPIN. Generas preguntas estratégicas personalizadas que ayudan a los vendedores a identificar necesidades reales del cliente y crear urgencia de compra."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=3000,
            temperature=0.7
        )
        
        return response.choices[0].message.content
        
    except Exception as e:
        print(f"Error generando contenido SPIN con IA: {e}")
        # Fallback a función original si la IA falla
        return generate_spin_questions_fallback(description, company_info, product_info)


def generate_spin_questions_fallback(description, company_info="", product_info=""):
    """
    Función de fallback que genera preguntas SPIN básicas si la IA no está disponible
    """
    # Análisis del contexto para generar preguntas específicas
    context_lower = description.lower()
    
    # Detectar industria/sector del contexto
    industry_keywords = {
        'tecnología': ['software', 'sistema', 'tecnología', 'digital', 'app', 'web', 'automatización'],
        'retail': ['tienda', 'venta', 'producto', 'inventario', 'retail', 'comercio'],
        'servicios': ['servicio', 'consultoría', 'asesoría', 'capacitación', 'formación'],
        'manufactura': ['producción', 'manufactura', 'fábrica', 'proceso', 'calidad'],
        'salud': ['salud', 'médico', 'hospital', 'clínica', 'paciente'],
        'educación': ['educación', 'escuela', 'universidad', 'estudiante', 'curso'],
        'finanzas': ['banco', 'financiero', 'préstamo', 'inversión', 'contabilidad']
    }
    
    detected_industry = 'general'
    for industry, keywords in industry_keywords.items():
        if any(keyword in context_lower for keyword in keywords):
            detected_industry = industry
            break
    
    # Detectar problemas/necesidades mencionadas
    pain_points = []
    if any(word in context_lower for word in ['problema', 'dificultad', 'reto', 'desafío']):
        pain_points.append('problemas_operacionales')
    if any(word in context_lower for word in ['costo', 'gasto', 'presupuesto', 'caro']):
        pain_points.append('costos_elevados')
    if any(word in context_lower for word in ['tiempo', 'lento', 'demora', 'eficiencia']):
        pain_points.append('ineficiencia_tiempo')
    if any(word in context_lower for word in ['competencia', 'mercado', 'ventaja']):
        pain_points.append('presion_competitiva')
    
    # Generar preguntas SPIN
    spin_content = f"""
🎯 METODOLOGÍA SPIN - PREGUNTAS ESTRATÉGICAS (Fallback)

{company_info}

CONTEXTO ANALIZADO:
{description}

═══════════════════════════════════════════════════════════════

📊 S - PREGUNTAS DE SITUACIÓN (Understanding Current State)
════════════════════════════════════════════════════════════

{generate_situation_questions(detected_industry, context_lower)}

═══════════════════════════════════════════════════════════════

⚠️ P - PREGUNTAS DE PROBLEMA (Identifying Pain Points)
═══════════════════════════════════════════════════════════

{generate_problem_questions(detected_industry, pain_points, context_lower)}

═══════════════════════════════════════════════════════════════

🔥 I - PREGUNTAS DE IMPLICACIÓN (Consequences & Impact)
═══════════════════════════════════════════════════════════

{generate_implication_questions(detected_industry, pain_points)}

═══════════════════════════════════════════════════════════════

✅ N - PREGUNTAS DE NECESIDAD-BENEFICIO (Value Proposition)
═══════════════════════════════════════════════════════════

{generate_need_payoff_questions(detected_industry, context_lower)}

═══════════════════════════════════════════════════════════════

🎯 ESTRATEGIA RECOMENDADA:
• Comenzar con 2-3 preguntas de Situación para entender el contexto
• Profundizar con Preguntas de Problema para identificar dolor
• Amplificar el impacto con preguntas de Implicación
• Cerrar con Necesidad-Beneficio para crear urgencia de solución

📋 PRÓXIMOS PASOS:
• Preparar casos de éxito específicos del sector
• Documentar respuestas del cliente para propuesta personalizada
• Definir cronograma de implementación basado en urgencia detectada

⚠️ Nota: Generado con sistema de fallback. Configure la IA para preguntas más personalizadas.
"""
    
    return spin_content


def generate_situation_questions(industry, context):
    """Genera preguntas de situación específicas por industria"""
    
    base_questions = [
        "¿Cómo manejan actualmente este proceso en su organización?",
        "¿Qué herramientas o sistemas utilizan para esto?",
        "¿Quién es responsable de supervisar esta área?",
        "¿Con qué frecuencia revisan o evalúan estos procesos?"
    ]
    
    industry_specific = {
        'tecnología': [
            "¿Qué stack tecnológico utilizan actualmente?",
            "¿Cómo gestionan el ciclo de desarrollo de software?",
            "¿Qué nivel de automatización tienen implementado?",
            "¿Cómo manejan la seguridad de datos y ciberseguridad?"
        ],
        'retail': [
            "¿Cómo controlan el inventario actualmente?",
            "¿Qué canales de venta utilizan?",
            "¿Cómo analizan el comportamiento de compra de sus clientes?",
            "¿Qué estrategias de marketing digital implementan?"
        ],
        'servicios': [
            "¿Cómo gestionan la relación con sus clientes?",
            "¿Qué procesos siguen para la entrega de servicios?",
            "¿Cómo miden la satisfacción del cliente?",
            "¿Qué herramientas usan para gestionar proyectos?"
        ],
        'finanzas': [
            "¿Cómo gestionan los procesos contables actualmente?",
            "¿Qué nivel de automatización tienen en facturación?",
            "¿Cómo realizan el seguimiento de flujo de caja?",
            "¿Qué reportes financieros generan regularmente?"
        ]
    }
    
    questions = base_questions + industry_specific.get(industry, [])
    return '\n'.join([f"• {q}" for q in questions[:6]])


def generate_problem_questions(industry, pain_points, context):
    """Genera preguntas de problema basadas en pain points detectados"""
    
    base_questions = [
        "¿Qué aspectos de este proceso les resultan más desafiantes?",
        "¿Hay algo que les gustaría que funcionara de manera diferente?",
        "¿Qué obstáculos enfrentan para lograr sus objetivos?"
    ]
    
    pain_point_questions = {
        'problemas_operacionales': [
            "¿Con qué frecuencia experimentan interrupciones en este proceso?",
            "¿Qué impacto tienen estos problemas en la productividad del equipo?",
            "¿Cuánto tiempo dedican a resolver problemas operacionales?"
        ],
        'costos_elevados': [
            "¿Sienten que están gastando más de lo necesario en esta área?",
            "¿Han calculado el costo de oportunidad de mantener el status quo?",
            "¿Qué porcentaje del presupuesto representa esta área actualmente?"
        ],
        'ineficiencia_tiempo': [
            "¿Cuánto tiempo podrían ahorrar si este proceso fuera más eficiente?",
            "¿Qué tareas repetitivas consumen más tiempo de su equipo?",
            "¿Han considerado el costo de las horas perdidas en procesos manuales?"
        ],
        'presion_competitiva': [
            "¿Cómo los afecta la presión competitiva en este aspecto?",
            "¿Qué ventajas tienen sus competidores que ustedes no?",
            "¿Qué riesgo ven de no evolucionar en esta área?"
        ]
    }
    
    questions = base_questions[:]
    for pain_point in pain_points:
        questions.extend(pain_point_questions.get(pain_point, []))
    
    return '\n'.join([f"• {q}" for q in questions[:6]])


def generate_implication_questions(industry, pain_points):
    """Genera preguntas de implicación para amplificar el dolor"""
    
    base_questions = [
        "¿Qué sucede si estos problemas continúan sin resolverse?",
        "¿Cómo afecta esto a la moral y productividad del equipo?",
        "¿Qué impacto tiene en la experiencia de sus clientes?",
        "¿Cómo podría esto afectar su crecimiento futuro?"
    ]
    
    specific_implications = [
        "¿Cuál es el costo real de no actuar ahora?",
        "¿Qué oportunidades podrían estar perdiendo?",
        "¿Cómo esto los posiciona frente a la competencia?",
        "¿Qué riesgos ven en el mediano y largo plazo?",
        "¿Cómo afecta esto la toma de decisiones estratégicas?",
        "¿Qué impacto tiene en la escalabilidad del negocio?"
    ]
    
    all_questions = base_questions + specific_implications
    return '\n'.join([f"• {q}" for q in all_questions[:6]])


def generate_need_payoff_questions(industry, context):
    """Genera preguntas de necesidad-beneficio para crear valor"""
    
    base_questions = [
        "¿Qué valor tendría para ustedes resolver este desafío?",
        "¿Cómo mejoraría su operación si tuvieran una solución eficaz?",
        "¿Qué beneficios esperarían ver en los primeros 90 días?",
        "¿Cómo mediría el éxito de una implementación?"
    ]
    
    value_questions = [
        "¿Cuál sería el impacto en ROI si optimizaran este proceso?",
        "¿Qué nuevas oportunidades se abrirían con una solución efectiva?",
        "¿Cómo esto les ayudaría a diferenciarse de la competencia?",
        "¿Qué valor agregado podrían ofrecer a sus clientes?",
        "¿Cómo esto contribuiría a sus objetivos estratégicos?",
        "¿Qué tranquilidad les daría tener esto resuelto?"
    ]
    
    all_questions = base_questions + value_questions
    return '\n'.join([f"• {q}" for q in all_questions[:6]])


# ===== VISTAS PARA ASISTENCIA DE CLIENTE =====

@login_required
@user_passes_test(is_agent)
def client_assistance_list(request):
    """Vista para listar los accesos públicos de proyectos para clientes"""
    from .models import ClientProjectAccess
    
    accesses = ClientProjectAccess.objects.select_related('project').order_by('-created_at')
    
    context = {
        'accesses': accesses,
        'title': 'Asistencia de Cliente - Proyectos Públicos'
    }
    return render(request, 'tickets/client_assistance_list.html', context)


@login_required
@user_passes_test(is_agent)
def client_assistance_create(request):
    """Vista para crear un nuevo acceso público para un proyecto"""
    from .models import ClientProjectAccess
    from .forms import ClientProjectAccessForm
    
    if request.method == 'POST':
        form = ClientProjectAccessForm(request.POST)
        if form.is_valid():
            access = form.save()
            messages.success(request, f'Acceso público creado exitosamente para el proyecto "{access.project.name}"')
            return redirect('client_assistance_list')
    else:
        form = ClientProjectAccessForm()
    
    context = {
        'form': form,
        'title': 'Crear Acceso Público para Proyecto'
    }
    return render(request, 'tickets/client_assistance_form.html', context)


@login_required
@user_passes_test(is_agent)
def client_assistance_edit(request, pk):
    """Vista para editar un acceso público existente"""
    from .models import ClientProjectAccess
    from .forms import ClientProjectAccessForm
    
    access = get_object_or_404(ClientProjectAccess, pk=pk)
    
    if request.method == 'POST':
        form = ClientProjectAccessForm(request.POST, instance=access)
        if form.is_valid():
            form.save()
            messages.success(request, 'Acceso público actualizado exitosamente')
            return redirect('client_assistance_list')
    else:
        form = ClientProjectAccessForm(instance=access)
    
    context = {
        'form': form,
        'access': access,
        'title': f'Editar Acceso - {access.project.name}'
    }
    return render(request, 'tickets/client_assistance_form.html', context)


@login_required
@user_passes_test(is_agent)
def client_time_entries_list(request, project_id=None):
    """Vista para listar las entradas de tiempo de clientes"""
    from .models import ClientTimeEntry, Project
    
    entries = ClientTimeEntry.objects.select_related('project').order_by('-created_at')
    projects = Project.objects.filter(client_access__isnull=False)
    
    # Filtrar por proyecto si se especifica
    if project_id:
        project = get_object_or_404(Project, pk=project_id)
        entries = entries.filter(project=project)
    else:
        project = None
    
    # Paginación
    paginator = Paginator(entries, 25)
    page_number = request.GET.get('page')
    entries = paginator.get_page(page_number)
    
    context = {
        'entries': entries,
        'projects': projects,
        'selected_project': project,
        'title': 'Entradas de Tiempo de Clientes'
    }
    return render(request, 'tickets/client_time_entries_list.html', context)


def client_time_entry_form(request, token):
    """Vista pública para que los clientes imputen horas"""
    from .models import ClientProjectAccess, ClientTimeEntry
    from .forms import ClientTimeEntryForm
    
    # Buscar el acceso público por token
    try:
        access = ClientProjectAccess.objects.select_related('project').get(
            public_token=token,
            is_active=True
        )
    except ClientProjectAccess.DoesNotExist:
        messages.error(request, 'El enlace no es válido o ha expirado.')
        return render(request, 'tickets/client_time_entry_error.html', {
            'error_message': 'El enlace no es válido o ha expirado.'
        })
    
    # Verificar si se pueden aceptar más entradas hoy
    if not access.can_accept_entries_today():
        messages.error(request, 'Se ha alcanzado el límite de entradas para hoy. Intente mañana.')
        return render(request, 'tickets/client_time_entry_error.html', {
            'error_message': 'Se ha alcanzado el límite de entradas para hoy.'
        })
    
    if request.method == 'POST':
        form = ClientTimeEntryForm(request.POST, access=access)
        if form.is_valid():
            entry = form.save(commit=False)
            entry.project = access.project
            
            # Capturar información del cliente
            entry.client_ip = request.META.get('REMOTE_ADDR')
            entry.user_agent = request.META.get('HTTP_USER_AGENT', '')
            
            entry.save()
            
            messages.success(request, '¡Sus horas han sido registradas exitosamente!')
            return render(request, 'tickets/client_time_entry_success.html', {
                'entry': entry,
                'project': access.project
            })
    else:
        form = ClientTimeEntryForm(access=access)
    
    context = {
        'form': form,
        'access': access,
        'project': access.project,
        'title': f'Registrar Horas - {access.project.name}'
    }
    return render(request, 'tickets/client_time_entry_public.html', context)


@login_required
@user_passes_test(is_agent)
def client_assistance_toggle(request, pk):
    """Vista para activar/desactivar un acceso público"""
    from .models import ClientProjectAccess
    
    access = get_object_or_404(ClientProjectAccess, pk=pk)
    access.is_active = not access.is_active
    access.save()
    
    status = 'activado' if access.is_active else 'desactivado'
    messages.success(request, f'Acceso público {status} exitosamente')
    
    return redirect('client_assistance_list')


@login_required
@user_passes_test(is_agent)
def client_assistance_delete(request, pk):
    """Vista para eliminar un acceso público"""
    from .models import ClientProjectAccess
    
    access = get_object_or_404(ClientProjectAccess, pk=pk)
    
    if request.method == 'POST':
        project_name = access.project.name
        access.delete()
        messages.success(request, f'Acceso público para "{project_name}" eliminado exitosamente')
        return redirect('client_assistance_list')
    
    context = {
        'access': access,
        'title': f'Eliminar Acceso - {access.project.name}'
    }
    return render(request, 'tickets/client_assistance_delete.html', context)


@login_required
@user_passes_test(is_agent)
def client_assistance_dashboard(request):
    """Dashboard de gerencia con KPIs de horas imputadas por clientes"""
    from django.db.models import Sum, Count, Avg
    from django.utils import timezone
    from datetime import timedelta, datetime
    from collections import defaultdict
    import json
    
    # Obtener parámetros de filtros
    project_filter = request.GET.get('project')
    category_filter = request.GET.get('category')
    date_from = request.GET.get('date_from')
    date_to = request.GET.get('date_to')
    
    # Query base
    entries = ClientTimeEntry.objects.select_related('project')
    
    # Aplicar filtros
    if project_filter:
        entries = entries.filter(project_id=project_filter)
    if category_filter:
        entries = entries.filter(category=category_filter)
    if date_from:
        entries = entries.filter(entry_date__gte=date_from)
    if date_to:
        entries = entries.filter(entry_date__lte=date_to)
    
    # Fechas importantes
    today = timezone.now().date()
    week_start = today - timedelta(days=today.weekday())
    month_start = today.replace(day=1)
    
    # ============= KPIs PRINCIPALES =============
    
    # 1. Total de horas (general)
    total_hours = entries.aggregate(total=Sum('hours'))['total'] or 0
    
    # 2. Horas esta semana
    week_hours = entries.filter(entry_date__gte=week_start).aggregate(total=Sum('hours'))['total'] or 0
    
    # 3. Horas este mes
    month_hours = entries.filter(entry_date__gte=month_start).aggregate(total=Sum('hours'))['total'] or 0
    
    # 4. Promedio diario (últimos 30 días)
    thirty_days_ago = today - timedelta(days=30)
    recent_entries = entries.filter(entry_date__gte=thirty_days_ago)
    total_recent_hours = recent_entries.aggregate(total=Sum('hours'))['total'] or 0
    avg_daily_hours = total_recent_hours / 30 if total_recent_hours > 0 else 0
    
    # 5. Total de clientes únicos
    unique_clients = entries.values('client_email').distinct().count()
    
    # 6. Total de entradas
    total_entries = entries.count()
    
    # ============= RANKINGS =============
    
    # Top 10 usuarios más activos (por horas totales) - usando nombre si está disponible
    top_users_total = (entries.values('client_name', 'client_email')
                       .annotate(
                           total_hours=Sum('hours'),
                           total_entries=Count('id')
                       )
                       .order_by('-total_hours')[:10])
    
    # Top 10 usuarios esta semana
    top_users_week = (entries.filter(entry_date__gte=week_start)
                      .values('client_name', 'client_email')
                      .annotate(
                          week_hours=Sum('hours'),
                          week_entries=Count('id')
                      )
                      .order_by('-week_hours')[:10])
    
    # ============= DISTRIBUCIONES =============
    
    # Distribución por categorías
    category_distribution_raw = (entries.values('category')
                           .annotate(
                               hours=Sum('hours'),
                               entries_count=Count('id')
                           )
                           .order_by('-hours'))
    
    # Agregar cálculo de promedio manual para mayor precisión
    category_distribution = []
    for cat in category_distribution_raw:
        total_hours = float(cat['hours'] or 0)
        entries_count = cat['entries_count']
        avg_per_entry = total_hours / entries_count if entries_count > 0 else 0
        
        category_distribution.append({
            'category': cat['category'],
            'hours': total_hours,
            'entries_count': entries_count,
            'avg_per_entry': round(avg_per_entry, 1)
        })
    
    # Distribución por proyectos
    project_distribution = (entries.values('project__name', 'project__color')
                          .annotate(
                              hours=Sum('hours'),
                              entries_count=Count('id')
                          )
                          .order_by('-hours'))
    
    # ============= TENDENCIAS TEMPORALES =============
    
    # Últimos 30 días - datos para gráfico de líneas
    daily_stats = defaultdict(lambda: {'hours': 0, 'entries': 0})
    
    # Generar fechas de los últimos 30 días
    last_30_days = []
    for i in range(30):
        date = today - timedelta(days=29-i)
        last_30_days.append(date)
        daily_stats[date.strftime('%Y-%m-%d')] = {'hours': 0, 'entries': 0}
    
    # Obtener datos reales
    daily_data = (recent_entries.extra(select={'date': 'DATE(entry_date)'})
                  .values('date')
                  .annotate(
                      hours=Sum('hours'),
                      entries_count=Count('id')
                  ))
    
    for day in daily_data:
        date_str = day['date']  # Ya es un string en formato YYYY-MM-DD
        if isinstance(date_str, str):
            daily_stats[date_str] = {
                'hours': float(day['hours'] or 0),
                'entries': day['entries_count']
            }
        else:
            # Si por alguna razón es un objeto date, convertir a string
            date_str = day['date'].strftime('%Y-%m-%d')
            daily_stats[date_str] = {
                'hours': float(day['hours'] or 0),
                'entries': day['entries_count']
            }
    
    # Preparar datos para Chart.js
    chart_labels = [date.strftime('%d/%m') for date in last_30_days]
    chart_hours = [daily_stats[date.strftime('%Y-%m-%d')]['hours'] for date in last_30_days]
    chart_entries = [daily_stats[date.strftime('%Y-%m-%d')]['entries'] for date in last_30_days]
    
    # Distribución semanal (últimas 4 semanas)
    weekly_stats = []
    for i in range(4):
        week_start_date = week_start - timedelta(weeks=i)
        week_end_date = week_start_date + timedelta(days=6)
        
        week_data = entries.filter(
            entry_date__gte=week_start_date,
            entry_date__lte=week_end_date
        ).aggregate(
            hours=Sum('hours'),
            entries_count=Count('id')
        )
        
        weekly_stats.append({
            'week': f"Sem {4-i}",
            'start_date': week_start_date,
            'end_date': week_end_date,
            'hours': float(week_data['hours'] or 0),
            'entries': week_data['entries_count']
        })
    
    weekly_stats.reverse()  # Ordenar cronológicamente
    
    # ============= ESTADÍSTICAS ADICIONALES =============
    
    # Horario más activo (por día de la semana)
    weekday_stats = defaultdict(lambda: {'hours': 0, 'entries': 0})
    weekday_names = ['Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado', 'Domingo']
    
    for entry in recent_entries:
        weekday = entry.entry_date.weekday()
        weekday_stats[weekday]['hours'] += float(entry.hours)
        weekday_stats[weekday]['entries'] += 1
    
    weekday_data = []
    for i in range(7):
        weekday_data.append({
            'day': weekday_names[i],
            'hours': weekday_stats[i]['hours'],
            'entries': weekday_stats[i]['entries']
        })
    
    # Comparación con período anterior
    prev_week_start = week_start - timedelta(days=7)
    prev_week_hours = entries.filter(
        entry_date__gte=prev_week_start,
        entry_date__lt=week_start
    ).aggregate(total=Sum('hours'))['total'] or 0
    
    week_growth = ((week_hours - prev_week_hours) / prev_week_hours * 100) if prev_week_hours > 0 else 0
    
    # ============= PREPARAR CONTEXTO =============
    
    # Calcular promedio general
    avg_general = total_hours / total_entries if total_entries > 0 else 0
    
    # Obtener listas para filtros
    projects = Project.objects.filter(client_access__isnull=False).distinct()
    categories = ClientTimeEntry.CATEGORY_CHOICES

    context = {
        'title': 'Dashboard de Asistencia de Cliente',
        
        # KPIs principales
        'total_hours': total_hours,
        'week_hours': week_hours,
        'month_hours': month_hours,
        'avg_daily_hours': round(avg_daily_hours, 1),
        'unique_clients': unique_clients,
        'total_entries': total_entries,
        'week_growth': round(week_growth, 1),
        'avg_general': round(avg_general, 1),        # Rankings
        'top_users_total': top_users_total,
        'top_users_week': top_users_week,
        
        # Distribuciones
        'category_distribution': category_distribution,
        'project_distribution': project_distribution,
        'weekday_data': weekday_data,
        'weekly_stats': weekly_stats,
        
        # Datos para gráficos (JSON)
        'chart_data': json.dumps({
            'labels': chart_labels,
            'hours': chart_hours,
            'entries': chart_entries,
            'categories': [
                {
                    'name': cat['category'],
                    'hours': float(cat['hours'] or 0),
                    'entries': cat['entries_count']
                } for cat in category_distribution
            ],
            'projects': [
                {
                    'name': proj['project__name'],
                    'color': proj['project__color'],
                    'hours': float(proj['hours'] or 0),
                    'entries': proj['entries_count']
                } for proj in project_distribution
            ],
            'weekdays': [
                {
                    'day': wd['day'],
                    'hours': wd['hours'],
                    'entries': wd['entries']
                } for wd in weekday_data
            ]
        }),
        
        # Filtros
        'projects': projects,
        'categories': categories,
        'selected_project': project_filter,
        'selected_category': category_filter,
        'selected_date_from': date_from,
        'selected_date_to': date_to,
        
        # Fechas
        'today': today,
        'week_start': week_start,
        'month_start': month_start,
    }
    
    return render(request, 'tickets/client_assistance_dashboard.html', context)


def client_dashboard_public(request, token):
    """Dashboard público para que los clientes vean sus estadísticas"""
    from .models import ClientProjectAccess, ClientTimeEntry
    from django.utils import timezone
    from datetime import timedelta
    from django.db.models import Sum, Count, Q, Avg
    from django.db.models.functions import TruncDate, TruncWeek, TruncMonth
    import json
    
    # Buscar el acceso público por dashboard token
    try:
        access = ClientProjectAccess.objects.select_related('project').get(
            dashboard_token=token,
            is_active=True
        )
    except ClientProjectAccess.DoesNotExist:
        return render(request, 'tickets/client_dashboard_error.html', {
            'error_message': 'El enlace del dashboard no es válido o ha expirado.'
        })
    
    # Fechas importantes
    today = timezone.now().date()
    week_start = today - timedelta(days=today.weekday())
    month_start = today.replace(day=1)
    
    # Filtros opcionales por nombre del cliente
    client_name = request.GET.get('client_name', '').strip()
    
    # Base queryset para las entradas del proyecto
    entries = ClientTimeEntry.objects.filter(project=access.project)
    
    # Aplicar filtro de nombre si se proporciona
    if client_name:
        entries = entries.filter(client_name__icontains=client_name)
    
    # KPIs Principales solicitados
    
    # 1. Total de horas este mes (del cliente específico si hay filtro)
    total_hours_this_month = entries.filter(
        entry_date__gte=month_start
    ).aggregate(total=Sum('hours'))['total'] or 0
    
    # 2. Horas en el proyecto este mes (del cliente específico si hay filtro)
    project_hours_this_month = entries.filter(
        entry_date__gte=month_start,
        project=access.project
    ).aggregate(total=Sum('hours'))['total'] or 0
    
    # 3. Total de horas en el proyecto (del cliente específico si hay filtro)
    total_project_hours = entries.filter(
        project=access.project
    ).aggregate(total=Sum('hours'))['total'] or 0
    
    # 4. Total de horas del equipo en el proyecto (todos los clientes)
    team_total_hours = ClientTimeEntry.objects.filter(
        project=access.project
    ).aggregate(total=Sum('hours'))['total'] or 0
    
    # KPIs adicionales para compatibilidad
    total_hours = total_project_hours  # Para mantener compatibilidad
    total_entries = entries.count()
    
    # Horas esta semana
    week_hours = entries.filter(
        entry_date__gte=week_start
    ).aggregate(total=Sum('hours'))['total'] or 0
    
    # Horas este mes (mantenemos por compatibilidad)
    month_hours = total_hours_this_month
    
    # Promedio diario
    days_active = entries.values('entry_date').distinct().count()
    avg_daily_hours = total_hours / max(days_active, 1)
    
    # Distribución por categorías
    category_distribution = entries.values('category').annotate(
        total_hours=Sum('hours'),
        total_entries=Count('id')
    ).order_by('-total_hours')
    
    # Clientes únicos (solo si no hay filtro de nombre)
    if not client_name:
        unique_clients = entries.values('client_name').distinct().count()
        
        # Top 10 clientes más activos
        top_clients = entries.values('client_name', 'client_email').annotate(
            total_hours=Sum('hours'),
            total_entries=Count('id')
        ).order_by('-total_hours')[:10]
    else:
        unique_clients = 1
        top_clients = []
    
    # Tendencia semanal (últimas 8 semanas)
    eight_weeks_ago = today - timedelta(weeks=8)
    weekly_trend = entries.filter(
        entry_date__gte=eight_weeks_ago
    ).extra(
        select={'week': 'strftime("%%Y-%%W", entry_date)'}
    ).values('week').annotate(
        total_hours=Sum('hours'),
        total_entries=Count('id')
    ).order_by('week')
    
    # Actividad diaria (últimos 30 días)
    thirty_days_ago = today - timedelta(days=30)
    daily_activity = entries.filter(
        entry_date__gte=thirty_days_ago
    ).extra(
        select={'date': 'DATE(entry_date)'}
    ).values('date').annotate(
        total_hours=Sum('hours'),
        total_entries=Count('id')
    ).order_by('date')
    
    # Actividad por día de la semana
    weekday_activity = entries.extra(
        select={'weekday': 'strftime("%%w", entry_date)'}
    ).values('weekday').annotate(
        total_hours=Sum('hours'),
        avg_hours=Avg('hours')
    ).order_by('weekday')
    
    # Mapear números de día a nombres
    weekday_names = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado']
    for item in weekday_activity:
        item['weekday_name'] = weekday_names[int(item['weekday'])]
    
    # Estadísticas por mes (últimos 6 meses)
    six_months_ago = today - timedelta(days=180)
    monthly_stats = entries.filter(
        entry_date__gte=six_months_ago
    ).extra(
        select={'month': 'strftime("%%Y-%%m", entry_date)'}
    ).values('month').annotate(
        total_hours=Sum('hours'),
        total_entries=Count('id'),
        avg_hours=Avg('hours')
    ).order_by('month')
    
    # Preparar datos para gráficos
    weekly_chart_data = {
        'labels': [item['week'] for item in weekly_trend],
        'hours': [float(item['total_hours']) for item in weekly_trend],
        'entries': [item['total_entries'] for item in weekly_trend]
    }
    
    daily_chart_data = {
        'labels': [item['date'] for item in daily_activity],
        'hours': [float(item['total_hours']) for item in daily_activity]
    }
    
    category_chart_data = {
        'labels': [item['category'].title() for item in category_distribution],
        'hours': [float(item['total_hours']) for item in category_distribution],
        'entries': [item['total_entries'] for item in category_distribution]
    }
    
    weekday_chart_data = {
        'labels': [item['weekday_name'] for item in weekday_activity],
        'hours': [float(item['total_hours']) for item in weekday_activity]
    }
    
    context = {
        'access': access,
        'project': access.project,
        'client_name': client_name,
        'title': f'Dashboard - {access.project.name}',
        
        # KPIs principales solicitados
        'total_hours_this_month': total_hours_this_month,
        'project_hours_this_month': project_hours_this_month,
        'total_project_hours': total_project_hours,
        'team_total_hours': team_total_hours,
        
        # KPIs adicionales para compatibilidad
        'total_hours': total_hours,
        'week_hours': week_hours,
        'month_hours': month_hours,
        'avg_daily_hours': round(avg_daily_hours, 1),
        'unique_clients': unique_clients,
        'total_entries': total_entries,
        
        # Distribuciones
        'category_distribution': category_distribution,
        'top_clients': top_clients,
        'weekday_activity': weekday_activity,
        'monthly_stats': monthly_stats,
        
        # Datos para gráficos (como JSON)
        'weekly_chart_data': json.dumps(weekly_chart_data),
        'daily_chart_data': json.dumps(daily_chart_data),
        'category_chart_data': json.dumps(category_chart_data),
        'weekday_chart_data': json.dumps(weekday_chart_data),
        
        # Fechas
        'today': today,
        'week_start': week_start,
        'month_start': month_start,
    }
    
    return render(request, 'tickets/client_dashboard_public.html', context)


# ============= VISTAS ACORTADOR DE URLS =============

@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def short_url_list(request):
    """Vista para listar todas las URLs cortas"""
    short_urls = ShortUrl.objects.filter(created_by=request.user).order_by('-created_at')
    
    context = {
        'page_title': 'Acortador de URLs',
        'short_urls': short_urls,
    }
    
    return render(request, 'tickets/short_url_list.html', context)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def short_url_create(request):
    """Vista para crear una nueva URL corta"""
    if request.method == 'POST':
        original_url = request.POST.get('original_url')
        title = request.POST.get('title', '')
        description = request.POST.get('description', '')
        expires_days = request.POST.get('expires_days')
        
        if original_url:
            # Verificar si ya existe una URL corta para esta URL
            existing = ShortUrl.objects.filter(
                original_url=original_url,
                created_by=request.user,
                is_active=True
            ).first()
            
            if existing:
                messages.info(request, f'Ya existe una URL corta para esta dirección: {existing.get_short_url()}')
                return redirect('short_url_list')
            
            # Crear nueva URL corta
            short_url = ShortUrl(
                original_url=original_url,
                title=title,
                description=description,
                short_code=ShortUrl.generate_short_code(),
                created_by=request.user
            )
            
            # Establecer fecha de expiración si se especifica
            if expires_days:
                try:
                    days = int(expires_days)
                    short_url.expires_at = timezone.now() + timezone.timedelta(days=days)
                except (ValueError, TypeError):
                    pass
            
            short_url.save()
            
            messages.success(request, f'URL corta creada exitosamente: {short_url.get_short_url()}')
            return redirect('short_url_list')
        else:
            messages.error(request, 'La URL es requerida.')
    
    context = {
        'page_title': 'Crear URL Corta',
    }
    
    return render(request, 'tickets/short_url_create.html', context)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def short_url_edit(request, pk):
    """Vista para editar una URL corta"""
    short_url = get_object_or_404(ShortUrl, pk=pk, created_by=request.user)
    
    if request.method == 'POST':
        short_url.title = request.POST.get('title', '')
        short_url.description = request.POST.get('description', '')
        short_url.is_active = request.POST.get('is_active') == 'on'
        
        expires_days = request.POST.get('expires_days')
        if expires_days:
            try:
                days = int(expires_days)
                short_url.expires_at = timezone.now() + timezone.timedelta(days=days)
            except (ValueError, TypeError):
                short_url.expires_at = None
        else:
            short_url.expires_at = None
        
        short_url.save()
        messages.success(request, 'URL corta actualizada exitosamente.')
        return redirect('short_url_list')
    
    context = {
        'page_title': 'Editar URL Corta',
        'short_url': short_url,
    }
    
    return render(request, 'tickets/short_url_edit.html', context)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def short_url_delete(request, pk):
    """Vista para eliminar una URL corta"""
    short_url = get_object_or_404(ShortUrl, pk=pk, created_by=request.user)
    
    if request.method == 'POST':
        short_url.delete()
        messages.success(request, 'URL corta eliminada exitosamente.')
        return redirect('short_url_list')
    
    context = {
        'page_title': 'Eliminar URL Corta',
        'short_url': short_url,
    }
    
    return render(request, 'tickets/short_url_delete.html', context)


def short_url_redirect(request, short_code):
    """Vista para redireccionar desde URL corta a URL original"""
    short_url = get_object_or_404(ShortUrl, short_code=short_code, is_active=True)
    
    # Verificar si ha expirado
    if short_url.is_expired():
        messages.error(request, 'Esta URL corta ha expirado.')
        return render(request, 'tickets/short_url_expired.html', {'short_url': short_url})
    
    # Incrementar contador de clics
    short_url.increment_clicks()
    
    # Redireccionar a la URL original
    return redirect(short_url.original_url)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def short_url_stats(request, pk):
    """Vista para ver estadísticas de una URL corta"""
    short_url = get_object_or_404(ShortUrl, pk=pk, created_by=request.user)
    
    context = {
        'page_title': f'Estadísticas - {short_url.short_code}',
        'short_url': short_url,
    }
    
    return render(request, 'tickets/short_url_stats.html', context)


# ==================== VISTAS DE CONJUNTOS DE PRODUCTOS ====================

@user_passes_test(is_agent_or_superuser, login_url='/')
def product_set_list(request):
    """Vista para listar conjuntos de productos"""
    product_sets = ProductSet.objects.filter(created_by=request.user).order_by('-created_at')
    
    context = {
        'page_title': 'Conjuntos de Productos',
        'product_sets': product_sets,
    }
    
    return render(request, 'tickets/product_set_list.html', context)


@user_passes_test(is_agent_or_superuser, login_url='/')
def product_set_create(request):
    """Vista para crear un conjunto de productos"""
    if request.method == 'POST':
        form = ProductSetForm(request.POST)
        formset = ProductItemFormSet(request.POST)
        
        if form.is_valid() and formset.is_valid():
            product_set = form.save(commit=False)
            product_set.created_by = request.user
            product_set.save()
            
            formset.instance = product_set
            formset.save()
            
            messages.success(request, f'Conjunto de productos "{product_set.title}" creado exitosamente.')
            return redirect('product_set_detail', pk=product_set.pk)
    else:
        form = ProductSetForm()
        # Crear formset vacío para creación
        formset = ProductItemFormSet(queryset=ProductItem.objects.none())
    
    context = {
        'page_title': 'Crear Conjunto de Productos',
        'form': form,
        'formset': formset,
    }
    
    return render(request, 'tickets/product_set_create.html', context)


@user_passes_test(is_agent_or_superuser, login_url='/')
def product_set_detail(request, pk):
    """Vista para ver detalles de un conjunto de productos"""
    product_set = get_object_or_404(ProductSet, pk=pk, created_by=request.user)
    products = product_set.products.all().order_by('order', 'name')
    
    context = {
        'page_title': f'Conjunto: {product_set.title}',
        'product_set': product_set,
        'products': products,
    }
    
    return render(request, 'tickets/product_set_detail.html', context)


@user_passes_test(is_agent_or_superuser, login_url='/')
def product_set_edit(request, pk):
    """Vista para editar un conjunto de productos"""
    product_set = get_object_or_404(ProductSet, pk=pk, created_by=request.user)
    
    if request.method == 'POST':
        form = ProductSetForm(request.POST, instance=product_set)
        formset = ProductItemFormSet(request.POST, instance=product_set)
        
        if form.is_valid() and formset.is_valid():
            form.save()
            formset.save()
            
            messages.success(request, f'Conjunto de productos "{product_set.title}" actualizado exitosamente.')
            return redirect('product_set_detail', pk=product_set.pk)
    else:
        form = ProductSetForm(instance=product_set)
        formset = ProductItemFormSet(instance=product_set)
    
    context = {
        'page_title': f'Editar: {product_set.title}',
        'form': form,
        'formset': formset,
        'product_set': product_set,
    }
    
    return render(request, 'tickets/product_set_edit.html', context)


@user_passes_test(is_agent_or_superuser, login_url='/')
def product_set_delete(request, pk):
    """Vista para eliminar un conjunto de productos"""
    product_set = get_object_or_404(ProductSet, pk=pk, created_by=request.user)
    
    if request.method == 'POST':
        product_set.delete()
        messages.success(request, f'Conjunto de productos "{product_set.title}" eliminado exitosamente.')
        return redirect('product_set_list')
    
    context = {
        'page_title': f'Eliminar: {product_set.title}',
        'product_set': product_set,
    }
    
    return render(request, 'tickets/product_set_delete.html', context)


@user_passes_test(is_agent_or_superuser, login_url='/')
def product_set_toggle_public(request, pk):
    """Vista para cambiar el estado público de un conjunto"""
    product_set = get_object_or_404(ProductSet, pk=pk, created_by=request.user)
    
    product_set.is_public = not product_set.is_public
    product_set.save()
    
    status = "público" if product_set.is_public else "privado"
    messages.success(request, f'Conjunto "{product_set.title}" marcado como {status}.')
    
    return redirect('product_set_detail', pk=product_set.pk)


def product_set_public(request, token):
    """Vista pública para mostrar conjunto de productos sin autenticación"""
    product_set = get_object_or_404(ProductSet, public_token=token, is_public=True)
    products = product_set.products.all().order_by('order', 'name')
    
    # Incrementar contador de vistas
    product_set.increment_views()
    
    context = {
        'page_title': product_set.title,
        'product_set': product_set,
        'products': products,
        'is_public_view': True,
    }
    
    return render(request, 'tickets/product_set_public.html', context)


@user_passes_test(is_agent_or_superuser, login_url='/')
def product_set_stats(request, pk):
    """Vista para mostrar estadísticas de un conjunto de productos"""
    product_set = get_object_or_404(ProductSet, pk=pk, created_by=request.user)
    
    # Calcular estadísticas adicionales
    from django.utils import timezone
    from datetime import timedelta
    
    days_active = (timezone.now() - product_set.created_at).days
    if days_active == 0:
        days_active = 1  # Al menos 1 día para evitar división por cero
    
    views_per_day = product_set.view_count / days_active if product_set.view_count > 0 else 0
    
    context = {
        'page_title': f'Estadísticas - {product_set.title}',
        'product_set': product_set,
        'days_active': days_active,
        'views_per_day': views_per_day,
    }
    
    return render(request, 'tickets/product_set_stats.html', context)


# ==================== PRECOTIZADOR VIEWS ====================

@user_passes_test(is_agent_or_superuser, login_url='/')
def precotizador_list(request):
    """Vista para listar todos los precotizadores"""
    precotizadores = Precotizador.objects.filter(created_by=request.user)
    
    context = {
        'page_title': 'Precotizadores',
        'precotizadores': precotizadores,
    }
    
    return render(request, 'tickets/precotizador_list.html', context)


@user_passes_test(is_agent_or_superuser, login_url='/')
def precotizador_create(request):
    """Vista para crear un nuevo precotizador"""
    if request.method == 'POST':
        form = PrecotizadorForm(request.POST)
        formset = PrecotizadorExampleFormSet(request.POST)
        
        if form.is_valid() and formset.is_valid():
            precotizador = form.save(commit=False)
            precotizador.created_by = request.user
            precotizador.save()
            
            # Guardar los ejemplos
            examples = formset.save(commit=False)
            for i, example in enumerate(examples):
                example.precotizador = precotizador
                example.order = i
                example.save()
            
            return redirect('precotizador_detail', pk=precotizador.pk)
    else:
        form = PrecotizadorForm()
        formset = PrecotizadorExampleFormSet()
    
    context = {
        'page_title': 'Crear Precotizador',
        'form': form,
        'formset': formset,
    }
    
    return render(request, 'tickets/precotizador_create.html', context)


@user_passes_test(is_agent_or_superuser, login_url='/')
def precotizador_detail(request, pk):
    """Vista para ver detalles de un precotizador"""
    precotizador = get_object_or_404(Precotizador, pk=pk, created_by=request.user)
    examples = precotizador.examples.all()
    quotes = precotizador.quotes.all()[:10]  # Últimas 10 cotizaciones
    
    context = {
        'page_title': f'Precotizador - {precotizador.title}',
        'precotizador': precotizador,
        'examples': examples,
        'quotes': quotes,
    }
    
    return render(request, 'tickets/precotizador_detail.html', context)


@user_passes_test(is_agent_or_superuser, login_url='/')
def precotizador_edit(request, pk):
    """Vista para editar un precotizador"""
    precotizador = get_object_or_404(Precotizador, pk=pk, created_by=request.user)
    
    if request.method == 'POST':
        form = PrecotizadorForm(request.POST, instance=precotizador)
        formset = PrecotizadorExampleFormSet(request.POST, instance=precotizador)
        
        if form.is_valid() and formset.is_valid():
            form.save()
            
            # Guardar los ejemplos
            examples = formset.save(commit=False)
            for i, example in enumerate(examples):
                example.order = i
                example.save()
            
            return redirect('precotizador_detail', pk=precotizador.pk)
    else:
        form = PrecotizadorForm(instance=precotizador)
        formset = PrecotizadorExampleFormSet(instance=precotizador)
    
    context = {
        'page_title': f'Editar - {precotizador.title}',
        'form': form,
        'formset': formset,
        'precotizador': precotizador,
    }
    
    return render(request, 'tickets/precotizador_create.html', context)


@user_passes_test(is_agent_or_superuser, login_url='/')
def precotizador_delete(request, pk):
    """Vista para eliminar un precotizador"""
    precotizador = get_object_or_404(Precotizador, pk=pk, created_by=request.user)
    
    if request.method == 'POST':
        precotizador.delete()
        return redirect('precotizador_list')
    
    context = {
        'page_title': f'Eliminar - {precotizador.title}',
        'precotizador': precotizador,
    }
    
    return render(request, 'tickets/precotizador_delete.html', context)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def precotizador_toggle_public_requests(request, pk):
    """Vista para activar/desactivar solicitudes públicas"""
    precotizador = get_object_or_404(Precotizador, pk=pk, created_by=request.user)
    
    if request.method == 'POST':
        is_active = precotizador.toggle_public_requests()
        
        if is_active:
            messages.success(
                request, 
                f'✅ Solicitudes públicas activadas para "{precotizador.title}". '
                f'Los clientes ahora pueden solicitar cotizaciones a través del enlace público.'
            )
        else:
            messages.info(
                request, 
                f'🔒 Solicitudes públicas desactivadas para "{precotizador.title}". '
                f'El enlace público ya no estará disponible.'
            )
        
        return redirect('precotizador_detail', pk=precotizador.pk)
    
    # Si no es POST, redirigir al detalle
    return redirect('precotizador_detail', pk=precotizador.pk)


@user_passes_test(is_agent_or_superuser, login_url='/')
def precotizador_quote(request, pk):
    """Vista para generar cotización con IA"""
    precotizador = get_object_or_404(Precotizador, pk=pk, created_by=request.user)
    
    if request.method == 'POST':
        form = PrecotizadorQuoteForm(request.POST)
        
        if form.is_valid():
            try:
                # Obtener configuración de OpenAI
                config = SystemConfiguration.objects.get(pk=1)
                
                if not config.openai_api_key:
                    raise Exception("No se ha configurado la API key de OpenAI")
                
                # Preparar el contexto para la IA
                examples_context = "\n".join([
                    f"- {example.description}: {example.estimated_hours} horas"
                    for example in precotizador.examples.all()
                ])
                
                # Crear el prompt para la IA
                prompt = f"""
Eres un experto en estimación de proyectos de software. 

CONTEXTO DEL CLIENTE:
{precotizador.client_description}

EJEMPLOS DE TRABAJOS ANTERIORES:
{examples_context}

SOLICITUD DEL CLIENTE:
{form.cleaned_data['client_request']}

INSTRUCCIONES:
Basándote en los ejemplos anteriores y el contexto del cliente, proporciona una estimación detallada.

Tu respuesta debe seguir EXACTAMENTE este formato:

HORAS ESTIMADAS: [número]

DESCRIPCIÓN DEL TRABAJO:
[Descripción detallada de lo que implica el proyecto, tecnologías a usar, fases del desarrollo, etc.]

RAZONAMIENTO:
[Explicación de por qué elegiste esa cantidad de horas basándote en los ejemplos y complejidad del proyecto]

DESGLOSE DE TAREAS:
- [Tarea 1]: X horas
- [Tarea 2]: Y horas
- [Tarea 3]: Z horas

Importante: Responde en texto plano, NO uses JSON. Sé específico y detallado.
"""
                
                from openai import OpenAI
                client = OpenAI(api_key=config.openai_api_key)
                
                response = client.chat.completions.create(
                    model=config.openai_model or "gpt-3.5-turbo",
                    messages=[
                        {"role": "system", "content": "Eres un experto en estimación de proyectos de software. Responde en texto plano siguiendo exactamente el formato solicitado."},
                        {"role": "user", "content": prompt}
                    ],
                    temperature=0.7,
                    max_tokens=1500
                )
                
                ai_content = response.choices[0].message.content.strip()
                
                # Extraer las horas estimadas de la respuesta
                import re
                hours_match = re.search(r'HORAS ESTIMADAS:\s*(\d+(?:\.\d+)?)', ai_content, re.IGNORECASE)
                estimated_hours = float(hours_match.group(1)) if hours_match else 10.0
                
                # Extraer las secciones de la respuesta
                description_match = re.search(r'DESCRIPCIÓN DEL TRABAJO:\s*(.*?)(?=\n\nRAZONAMIENTO:|$)', ai_content, re.DOTALL | re.IGNORECASE)
                reasoning_match = re.search(r'RAZONAMIENTO:\s*(.*?)(?=\n\nDESGLOSE|$)', ai_content, re.DOTALL | re.IGNORECASE)
                
                detailed_description = description_match.group(1).strip() if description_match else ai_content
                reasoning = reasoning_match.group(1).strip() if reasoning_match else ""
                
                # Crear la cotización
                quote = form.save(commit=False)
                quote.precotizador = precotizador
                quote.ai_estimated_hours = estimated_hours
                quote.ai_detailed_description = detailed_description
                quote.ai_reasoning = reasoning
                quote.ai_full_response = ai_content  # Guardar respuesta completa
                quote.save()
                
                return redirect('precotizador_quote_detail', pk=quote.pk)
                
            except SystemConfiguration.DoesNotExist:
                form.add_error(None, "No se encontró la configuración del sistema")
            except Exception as e:
                import traceback
                print(f"Error al generar cotización: {str(e)}")
                print(traceback.format_exc())
                form.add_error(None, f"Error al generar cotización: {str(e)}")
    else:
        form = PrecotizadorQuoteForm()
    
    context = {
        'page_title': f'Generar Cotización - {precotizador.title}',
        'precotizador': precotizador,
        'examples': precotizador.examples.all(),
        'form': form,
    }
    
    return render(request, 'tickets/precotizador_quote.html', context)


@user_passes_test(is_agent_or_superuser, login_url='/')
def precotizador_quote_detail(request, pk):
    """Vista para ver detalles de una cotización"""
    quote = get_object_or_404(PrecotizadorQuote, pk=pk, precotizador__created_by=request.user)
    
    context = {
        'page_title': f'Cotización #{quote.id}',
        'quote': quote,
    }
    
    return render(request, 'tickets/precotizador_quote_detail.html', context)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def precotizador_quote_edit(request, pk):
    """Vista para editar una cotización"""
    quote = get_object_or_404(PrecotizadorQuote, pk=pk, precotizador__created_by=request.user)
    
    if request.method == 'POST':
        # Obtener los datos del formulario
        client_request = request.POST.get('client_request', '').strip()
        ai_detailed_description = request.POST.get('ai_detailed_description', '').strip()
        ai_reasoning = request.POST.get('ai_reasoning', '').strip()
        new_status = request.POST.get('status', '').strip()
        
        # Validar que los campos obligatorios no estén vacíos
        if not client_request:
            messages.error(request, 'La solicitud del cliente es obligatoria.')
            return render(request, 'tickets/precotizador_quote_edit.html', {'quote': quote})
        
        if not ai_detailed_description:
            messages.error(request, 'La descripción del trabajo es obligatoria.')
            return render(request, 'tickets/precotizador_quote_edit.html', {'quote': quote})
        
        # Validar el estado
        valid_statuses = ['pending', 'accepted', 'rejected']
        if new_status not in valid_statuses:
            messages.error(request, 'Estado no válido.')
            return render(request, 'tickets/precotizador_quote_edit.html', {'quote': quote})
        
        # Obtener el estado anterior para el mensaje
        old_status = quote.status
        
        # Actualizar la cotización
        quote.client_request = client_request
        quote.ai_detailed_description = ai_detailed_description
        quote.ai_reasoning = ai_reasoning
        quote.status = new_status
        
        # Si se cambia de accepted/rejected a pending, limpiar datos de respuesta
        if old_status in ['accepted', 'rejected'] and new_status == 'pending':
            quote.client_response_date = None
            quote.client_comments = ''
            quote.save(update_fields=['client_request', 'ai_detailed_description', 'ai_reasoning', 'status', 'client_response_date', 'client_comments'])
            messages.success(request, 'Cotización actualizada y restablecida a estado pendiente. El cliente podrá responder nuevamente.')
        else:
            quote.save(update_fields=['client_request', 'ai_detailed_description', 'ai_reasoning', 'status'])
            if old_status != new_status:
                status_names = {'pending': 'Pendiente', 'accepted': 'Aceptada', 'rejected': 'Rechazada'}
                messages.success(request, f'Cotización actualizada. Estado cambiado de "{status_names[old_status]}" a "{status_names[new_status]}".')
            else:
                messages.success(request, 'Cotización actualizada exitosamente.')
        
        return redirect('precotizador_quote_detail', pk=quote.pk)
    
    context = {
        'page_title': f'Editar Cotización #{quote.id}',
        'quote': quote,
    }
    
    return render(request, 'tickets/precotizador_quote_edit.html', context)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def precotizador_quote_delete(request, pk):
    """Vista para eliminar una cotización"""
    quote = get_object_or_404(PrecotizadorQuote, pk=pk, precotizador__created_by=request.user)
    
    if request.method == 'POST':
        quote.delete()
        messages.success(request, 'Cotización eliminada exitosamente.')
        return redirect('precotizador_detail', pk=quote.precotizador.pk)
    
    context = {
        'page_title': f'Eliminar Cotización #{quote.id}',
        'quote': quote,
    }
    
    return render(request, 'tickets/precotizador_quote_delete.html', context)


@login_required
@user_passes_test(is_agent_or_superuser, login_url='/')
def precotizador_quote_share(request, pk):
    """Vista para compartir una cotización públicamente"""
    quote = get_object_or_404(PrecotizadorQuote, pk=pk, precotizador__created_by=request.user)
    
    if request.method == 'POST':
        # Generar token y hacer público
        quote.generate_public_token()
        quote.is_public = True
        quote.save(update_fields=['is_public'])
        
        messages.success(request, 'Cotización compartida exitosamente. El enlace público está disponible.')
        return redirect('precotizador_quote_detail', pk=quote.pk)
    
    context = {
        'page_title': f'Compartir Cotización #{quote.id}',
        'quote': quote,
    }
    
    return render(request, 'tickets/precotizador_quote_share.html', context)


def precotizador_quote_public(request, token):
    """Vista pública para que el cliente vea y responda la cotización"""
    quote = get_object_or_404(PrecotizadorQuote, public_share_token=token, is_public=True)
    
    if request.method == 'POST':
        # Solo permitir responder si la cotización está pendiente
        if quote.status != 'pending':
            messages.error(request, 'Esta cotización ya fue respondida anteriormente y no puede ser modificada.')
            return redirect('precotizador_quote_public', token=token)
        
        action = request.POST.get('action')
        client_comments = request.POST.get('client_comments', '')
        
        try:
            if action == 'accept':
                quote.accept(client_comments)
                messages.success(request, '¡Cotización aceptada! Nos pondremos en contacto contigo pronto.')
            elif action == 'reject':
                quote.reject(client_comments)
                messages.info(request, 'Cotización rechazada. Gracias por tu tiempo.')
            else:
                messages.error(request, 'Acción no válida.')
        except ValueError as e:
            messages.error(request, str(e))
        except Exception as e:
            messages.error(request, f'Error inesperado: {str(e)}')
        
        return redirect('precotizador_quote_public', token=token)
    
    context = {
        'page_title': f'Cotización #{quote.id} - {quote.precotizador.title}',
        'quote': quote,
        'can_respond': quote.can_be_responded(),
    }
    
    return render(request, 'tickets/precotizador_quote_public.html', context)


def precotizador_public_request(request, token):
    """Vista pública donde los clientes pueden solicitar cotizaciones"""
    precotizador = get_object_or_404(
        Precotizador, 
        public_request_token=token, 
        allow_public_requests=True
    )
    
    if request.method == 'POST':
        # Si es una petición AJAX, procesar la cotización
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return process_public_quote_ajax(request, precotizador)
        
        # Si no es AJAX, mostrar página de carga
        client_request = request.POST.get('client_request', '').strip()
        client_name = request.POST.get('client_name', '').strip()
        client_email = request.POST.get('client_email', '').strip()
        
        # Validaciones básicas
        if not client_request or len(client_request) < 50:
            messages.error(request, 'Por favor, proporciona más detalles sobre tu proyecto (mínimo 50 caracteres).')
            return render(request, 'tickets/precotizador_public_request.html', {
                'precotizador': precotizador,
                'client_request': client_request,
                'client_name': client_name,
                'client_email': client_email,
            })
        
        # Mostrar página de carga
        context = {
            'page_title': 'Generando tu Cotización...',
            'precotizador': precotizador,
            'client_request': client_request,
            'client_name': client_name,
            'client_email': client_email,
        }
        return render(request, 'tickets/precotizador_loading.html', context)
    
    context = {
        'page_title': f'Solicitar Cotización - {precotizador.title}',
        'precotizador': precotizador,
    }
    
    return render(request, 'tickets/precotizador_public_request.html', context)


def process_public_quote_ajax(request, precotizador):
    """Procesa la generación de cotización vía AJAX usando la misma lógica que funciona"""
    import json
    from django.http import JsonResponse
    
    try:
        client_request = request.POST.get('client_request', '').strip()
        client_name = request.POST.get('client_name', '').strip()
        client_email = request.POST.get('client_email', '').strip()
        
        print(f"[DEBUG] Procesando cotización para: {client_request[:50]}...")
        
        # Validaciones básicas
        if not client_request or len(client_request) < 50:
            return JsonResponse({
                'success': False,
                'error': 'Por favor, proporciona más detalles sobre tu proyecto (mínimo 50 caracteres).'
            })
        
        # Usar la misma lógica que precotizador_quote (que ya funciona)
        from tickets.models import SystemConfiguration
        import openai
        
        config = SystemConfiguration.objects.get(pk=1)
        if not config.openai_api_key:
            return JsonResponse({
                'success': False,
                'error': 'Error de configuración. API key no disponible.'
            })
        
        # Preparar contexto igual que en precotizador_quote
        examples_context = "\n".join([
            f"- {example.description}: {example.estimated_hours} horas"
            for example in precotizador.examples.all()
        ])
        
        # Usar el mismo prompt que funciona
        prompt = f"""
Eres un experto en estimación de proyectos de software. 

CONTEXTO DEL CLIENTE:
{precotizador.client_description}

EJEMPLOS DE TRABAJOS ANTERIORES:
{examples_context}

SOLICITUD DEL CLIENTE:
{client_request}

INSTRUCCIONES:
Basándote en los ejemplos anteriores y el contexto del cliente, proporciona una estimación detallada.

Tu respuesta debe seguir EXACTAMENTE este formato:

HORAS ESTIMADAS: [número]

DESCRIPCIÓN DEL TRABAJO:
[Descripción detallada y profesional del proyecto]

RAZONAMIENTO:
[Justificación de la estimación basada en complejidad y ejemplos anteriores]

DESGLOSE DE TAREAS:
[Lista de las principales tareas y tiempo estimado para cada una]
"""
        
        # Configurar OpenAI igual que en la función que funciona
        openai.api_key = config.openai_api_key
        
        # Hacer la llamada a OpenAI
        response = openai.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "Eres un experto consultor en desarrollo de software especializado en estimaciones precisas de proyectos."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=1500,
            temperature=0.7
        )
        
        ai_content = response.choices[0].message.content.strip()
        
        # Extraer información igual que en la función original
        import re
        from decimal import Decimal
        
        hours_match = re.search(r'HORAS ESTIMADAS:\s*(\d+(?:\.\d+)?)', ai_content, re.IGNORECASE)
        estimated_hours = Decimal(str(hours_match.group(1))) if hours_match else Decimal('10.0')
        
        description_match = re.search(r'DESCRIPCIÓN DEL TRABAJO:\s*(.*?)(?=\n\nRAZONAMIENTO:|$)', ai_content, re.DOTALL | re.IGNORECASE)
        reasoning_match = re.search(r'RAZONAMIENTO:\s*(.*?)(?=\n\nDESGLOSE|$)', ai_content, re.DOTALL | re.IGNORECASE)
        
        detailed_description = description_match.group(1).strip() if description_match else ai_content
        reasoning = reasoning_match.group(1).strip() if reasoning_match else ""
        
        # Formatear solicitud con datos del cliente
        formatted_request = client_request
        if client_name:
            formatted_request = f"Solicitado por: {client_name}\n\n{formatted_request}"
        if client_email:
            formatted_request = f"{formatted_request}\n\nContacto: {client_email}"
        
        # Crear cotización usando el mismo modelo
        from tickets.models import PrecotizadorQuote
        quote = PrecotizadorQuote.objects.create(
            precotizador=precotizador,
            client_request=formatted_request,
            ai_estimated_hours=estimated_hours,
            ai_detailed_description=detailed_description,
            ai_reasoning=reasoning,
            ai_full_response=ai_content,
            is_public=True  # Importante: hacer pública para el enlace
        )
        
        # Generar token público
        quote.generate_public_token()
        
        # Crear URL usando reverse
        from django.urls import reverse
        quote_url = request.build_absolute_uri(
            reverse('precotizador_quote_public', kwargs={'token': quote.public_share_token})
        )
        
        print(f"[DEBUG] Cotización {quote.id} creada exitosamente")
        
        return JsonResponse({
            'success': True,
            'quote_url': quote_url,
            'quote_id': quote.id,
            'estimated_hours': float(estimated_hours),  # Convertir a float para JSON
            'estimated_cost': quote.get_formatted_cost(),
            'message': '¡Tu cotización ha sido generada exitosamente!'
        })
        
    except Exception as e:
        import traceback
        print(f"[ERROR] Error en process_public_quote_ajax: {str(e)}")
        print(f"[ERROR] Traceback: {traceback.format_exc()}")
        return JsonResponse({
            'success': False,
            'error': f'Error técnico: {str(e)}'
        })



# ============= VISTAS PARA DOCUMENTACIONES DE EMPRESAS =============

@login_required
def company_documentation_list(request):
    """Lista de documentaciones de empresas"""
    # Mostrar todas las documentaciones
    documentations = CompanyDocumentation.objects.all()
    documentations = documentations.order_by('-created_at')
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(documentations, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_obj': page_obj,
        'page_title': 'Documentaciones de Empresas',
        'section': 'documentation'
    }
    
    return render(request, 'tickets/company_documentation_list.html', context)


@login_required
def company_documentation_create(request):
    """Crear nueva documentación de empresa"""
    if request.method == 'POST':
        form = CompanyDocumentationForm(request.POST, user=request.user)
        formset = CompanyDocumentationURLFormSet(request.POST)
        
        if form.is_valid() and formset.is_valid():
            documentation = form.save(commit=False)
            documentation.created_by = request.user
            documentation.save()
            
            # Guardar URLs
            formset.instance = documentation
            formset.save()
            
            messages.success(request, 'Documentación creada exitosamente.')
            return redirect('company_documentation_detail', pk=documentation.pk)
    else:
        form = CompanyDocumentationForm(user=request.user)
        formset = CompanyDocumentationURLFormSet()
    
    context = {
        'form': form,
        'formset': formset,
        'page_title': 'Crear Documentación',
        'section': 'documentation'
    }
    
    return render(request, 'tickets/company_documentation_form.html', context)


@login_required
def company_documentation_detail(request, pk):
    """Detalle de documentación de empresa"""
    documentation = get_object_or_404(CompanyDocumentation, pk=pk)
    
    urls = documentation.urls.filter(is_active=True).order_by('order', 'title')
    
    context = {
        'documentation': documentation,
        'urls': urls,
        'page_title': f'Documentación - {documentation.title}',
        'section': 'documentation'
    }
    
    return render(request, 'tickets/company_documentation_detail.html', context)


def company_documentation_edit(request, pk):
    """Editar documentación de empresa"""
    documentation = get_object_or_404(CompanyDocumentation, pk=pk)
    
    if request.method == 'POST':
        form = CompanyDocumentationForm(request.POST, instance=documentation, user=None)
        formset = CompanyDocumentationURLFormSet(request.POST, instance=documentation)
        
        if form.is_valid() and formset.is_valid():
            form.save()
            formset.save()
            
            messages.success(request, 'Documentación actualizada exitosamente.')
            return redirect('company_documentation_detail', pk=documentation.pk)
    else:
        form = CompanyDocumentationForm(instance=documentation, user=None)
        formset = CompanyDocumentationURLFormSet(instance=documentation)
    
    context = {
        'form': form,
        'formset': formset,
        'documentation': documentation,
        'page_title': f'Editar - {documentation.title}',
        'section': 'documentation'
    }
    
    return render(request, 'tickets/company_documentation_form.html', context)


@login_required
def company_documentation_delete(request, pk):
    """Eliminar documentación de empresa"""
    documentation = get_object_or_404(CompanyDocumentation, pk=pk)
    
    # Verificar permisos
    if not (request.user.is_superuser or 
            request.user.groups.filter(name='Administradores').exists() or
            (hasattr(request.user, 'profile') and 
             request.user.profile.company == documentation.company)):
        messages.error(request, 'No tienes permisos para eliminar esta documentación.')
        return redirect('company_documentation_list')
    
    if request.method == 'POST':
        documentation.delete()
        messages.success(request, 'Documentación eliminada exitosamente.')
        return redirect('company_documentation_list')
    
    context = {
        'documentation': documentation,
        'page_title': f'Eliminar - {documentation.title}',
        'section': 'documentation'
    }
    
    return render(request, 'tickets/company_documentation_delete.html', context)


@login_required
def company_documentation_toggle_public(request, pk):
    """Activar/desactivar acceso público a documentación"""
    documentation = get_object_or_404(CompanyDocumentation, pk=pk)
    
    # Verificar permisos
    if not (request.user.is_superuser or 
            request.user.groups.filter(name='Administradores').exists() or
            (hasattr(request.user, 'profile') and 
             request.user.profile.company == documentation.company)):
        messages.error(request, 'No tienes permisos para modificar esta documentación.')
        return redirect('company_documentation_list')
    
    if request.method == 'POST':
        documentation.is_public = not documentation.is_public
        documentation.save()
        
        if documentation.is_public:
            messages.success(request, 'Documentación ahora es pública. Los clientes pueden acceder con el enlace.')
        else:
            messages.warning(request, 'Documentación ya no es pública. El enlace ha sido desactivado.')
    
    return redirect('company_documentation_detail', pk=documentation.pk)


def company_documentation_public(request, token):
    """Vista pública para que los clientes vean documentaciones"""
    documentation = get_object_or_404(
        CompanyDocumentation, 
        public_token=token, 
        is_public=True
    )
    
    urls = documentation.urls.filter(is_active=True).order_by('order', 'title')
    
    context = {
        'documentation': documentation,
        'urls': urls,
        'page_title': f'{documentation.title} - {documentation.company.name}',
        'is_public_view': True
    }
    
    return render(request, 'tickets/company_documentation_public.html', context)


# ==========================================
# VISTAS PARA GESTIÓN INDIVIDUAL DE URLs DE DOCUMENTACIÓN
# ==========================================

@login_required
def company_documentation_url_create(request, doc_pk):
    """Crear nueva URL para documentación"""
    documentation = get_object_or_404(CompanyDocumentation, pk=doc_pk)
    
    # Verificar permisos
    if not (request.user.is_superuser or 
            request.user.groups.filter(name='Administradores').exists() or
            (hasattr(request.user, 'profile') and 
             request.user.profile.company == documentation.company)):
        messages.error(request, 'No tienes permisos para agregar enlaces a esta documentación.')
        return redirect('company_documentation_detail', pk=doc_pk)
    
    if request.method == 'POST':
        form = CompanyDocumentationURLForm(request.POST)
        if form.is_valid():
            url_obj = form.save(commit=False)
            url_obj.documentation = documentation
            
            # Asignar el siguiente orden disponible
            max_order = documentation.urls.aggregate(models.Max('order'))['order__max'] or 0
            url_obj.order = max_order + 1
            
            url_obj.save()
            messages.success(request, f'Enlace "{url_obj.title}" agregado exitosamente.')
            return redirect('company_documentation_detail', pk=doc_pk)
    else:
        form = CompanyDocumentationURLForm()
    
    context = {
        'form': form,
        'documentation': documentation,
        'page_title': f'Agregar Enlace - {documentation.title}',
        'section': 'documentation',
        'action': 'create'
    }
    
    return render(request, 'tickets/company_documentation_url_form.html', context)


@login_required
def company_documentation_url_edit(request, doc_pk, url_pk):
    """Editar URL específica de documentación"""
    documentation = get_object_or_404(CompanyDocumentation, pk=doc_pk)
    url_obj = get_object_or_404(CompanyDocumentationURL, pk=url_pk, documentation=documentation)
    
    # Verificar permisos
    if not (request.user.is_superuser or 
            request.user.groups.filter(name='Administradores').exists() or
            (hasattr(request.user, 'profile') and 
             request.user.profile.company == documentation.company)):
        messages.error(request, 'No tienes permisos para editar este enlace.')
        return redirect('company_documentation_detail', pk=doc_pk)
    
    if request.method == 'POST':
        form = CompanyDocumentationURLForm(request.POST, instance=url_obj)
        if form.is_valid():
            form.save()
            messages.success(request, f'Enlace "{url_obj.title}" actualizado exitosamente.')
            return redirect('company_documentation_detail', pk=doc_pk)
    else:
        form = CompanyDocumentationURLForm(instance=url_obj)
    
    context = {
        'form': form,
        'documentation': documentation,
        'url_obj': url_obj,
        'page_title': f'Editar Enlace - {url_obj.title}',
        'section': 'documentation',
        'action': 'edit'
    }
    
    return render(request, 'tickets/company_documentation_url_form.html', context)


@login_required
def company_documentation_url_delete(request, doc_pk, url_pk):
    """Eliminar URL específica de documentación"""
    documentation = get_object_or_404(CompanyDocumentation, pk=doc_pk)
    url_obj = get_object_or_404(CompanyDocumentationURL, pk=url_pk, documentation=documentation)
    
    # Verificar permisos
    if not (request.user.is_superuser or 
            request.user.groups.filter(name='Administradores').exists() or
            (hasattr(request.user, 'profile') and 
             request.user.profile.company == documentation.company)):
        messages.error(request, 'No tienes permisos para eliminar este enlace.')
        return redirect('company_documentation_detail', pk=doc_pk)
    
    if request.method == 'POST':
        title = url_obj.title
        url_obj.delete()
        messages.success(request, f'Enlace "{title}" eliminado exitosamente.')
        return redirect('company_documentation_detail', pk=doc_pk)
    
    context = {
        'documentation': documentation,
        'url_obj': url_obj,
        'page_title': f'Eliminar Enlace - {url_obj.title}',
        'section': 'documentation'
    }
    
    return render(request, 'tickets/company_documentation_url_delete.html', context)


@login_required
def company_documentation_url_toggle(request, doc_pk, url_pk):
    """Activar/desactivar URL específica de documentación"""
    documentation = get_object_or_404(CompanyDocumentation, pk=doc_pk)
    url_obj = get_object_or_404(CompanyDocumentationURL, pk=url_pk, documentation=documentation)
    
    # Verificar permisos
    if not (request.user.is_superuser or 
            request.user.groups.filter(name='Administradores').exists() or
            (hasattr(request.user, 'profile') and 
             request.user.profile.company == documentation.company)):
        messages.error(request, 'No tienes permisos para modificar este enlace.')
        return redirect('company_documentation_detail', pk=doc_pk)
    
    if request.method == 'POST':
        url_obj.is_active = not url_obj.is_active
        url_obj.save()
        
        status = 'activado' if url_obj.is_active else 'desactivado'
        messages.success(request, f'Enlace "{url_obj.title}" {status} exitosamente.')
    
    return redirect('company_documentation_detail', pk=doc_pk)


# ==========================================
# VISTAS PARA CONDICIONES DE USO
# ==========================================

@login_required
def terms_of_use_list(request):
    """Lista de condiciones de uso"""
    if not (request.user.is_superuser or request.user.groups.filter(name='Administradores').exists()):
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('dashboard')
    
    terms = TermsOfUse.objects.all()
    
    context = {
        'terms': terms,
        'page_title': 'Condiciones de Uso',
        'section': 'documentation'
    }
    
    return render(request, 'tickets/terms_of_use_list.html', context)


@login_required
def terms_of_use_create(request):
    """Crear nueva condición de uso"""
    if not (request.user.is_superuser or request.user.groups.filter(name='Administradores').exists()):
        messages.error(request, 'No tienes permisos para crear condiciones de uso.')
        return redirect('terms_of_use_list')
    
    if request.method == 'POST':
        form = TermsOfUseForm(request.POST)
        if form.is_valid():
            term = form.save(commit=False)
            term.created_by = request.user
            term.save()
            messages.success(request, f'Condición de uso "{term.title}" creada exitosamente.')
            return redirect('terms_of_use_detail', pk=term.pk)
    else:
        form = TermsOfUseForm()
    
    context = {
        'form': form,
        'page_title': 'Nueva Condición de Uso',
        'section': 'documentation',
        'action': 'create'
    }
    
    return render(request, 'tickets/terms_of_use_form.html', context)


@login_required
def terms_of_use_detail(request, pk):
    """Ver detalle de condición de uso"""
    if not (request.user.is_superuser or request.user.groups.filter(name='Administradores').exists()):
        messages.error(request, 'No tienes permisos para ver esta condición de uso.')
        return redirect('dashboard')
    
    term = get_object_or_404(TermsOfUse, pk=pk)
    
    context = {
        'term': term,
        'page_title': f'Condición de Uso: {term.title}',
        'section': 'documentation'
    }
    
    return render(request, 'tickets/terms_of_use_detail.html', context)


@login_required
def terms_of_use_edit(request, pk):
    """Editar condición de uso"""
    if not (request.user.is_superuser or request.user.groups.filter(name='Administradores').exists()):
        messages.error(request, 'No tienes permisos para editar condiciones de uso.')
        return redirect('terms_of_use_list')
    
    term = get_object_or_404(TermsOfUse, pk=pk)
    
    if request.method == 'POST':
        form = TermsOfUseForm(request.POST, instance=term)
        if form.is_valid():
            form.save()
            messages.success(request, f'Condición de uso "{term.title}" actualizada exitosamente.')
            return redirect('terms_of_use_detail', pk=term.pk)
    else:
        form = TermsOfUseForm(instance=term)
    
    context = {
        'form': form,
        'term': term,
        'page_title': f'Editar: {term.title}',
        'section': 'documentation',
        'action': 'edit'
    }
    
    return render(request, 'tickets/terms_of_use_form.html', context)


@login_required
def terms_of_use_delete(request, pk):
    """Eliminar condición de uso"""
    if not (request.user.is_superuser or request.user.groups.filter(name='Administradores').exists()):
        messages.error(request, 'No tienes permisos para eliminar condiciones de uso.')
        return redirect('terms_of_use_list')
    
    term = get_object_or_404(TermsOfUse, pk=pk)
    
    if request.method == 'POST':
        title = term.title
        term.delete()
        messages.success(request, f'Condición de uso "{title}" eliminada exitosamente.')
        return redirect('terms_of_use_list')
    
    context = {
        'term': term,
        'page_title': f'Eliminar: {term.title}',
        'section': 'documentation'
    }
    
    return render(request, 'tickets/terms_of_use_delete.html', context)


@login_required
def terms_of_use_toggle(request, pk):
    """Activar/desactivar condición de uso"""
    if not (request.user.is_superuser or request.user.groups.filter(name='Administradores').exists()):
        messages.error(request, 'No tienes permisos para cambiar el estado de condiciones de uso.')
        return redirect('terms_of_use_list')
    
    term = get_object_or_404(TermsOfUse, pk=pk)
    term.is_active = not term.is_active
    term.save()
    
    status = 'activada' if term.is_active else 'desactivada'
    messages.success(request, f'Condición de uso "{term.title}" {status} exitosamente.')
    
    return redirect('terms_of_use_list')


# ==========================================
# VISTAS PARA GENERADORES DE CONTACTOS
# ==========================================

@login_required
def contact_generator_list(request):
    """Lista de generadores de contactos"""
    if not is_agent(request.user):
        return redirect('dashboard')
    
    # Filtrar por empresa según permisos del usuario
    if request.user.is_superuser:
        generators = ContactGenerator.objects.all()
    else:
        # Obtener empresas del usuario
        user_companies = []
        if hasattr(request.user, 'company'):
            user_companies.append(request.user.company.id)
        if hasattr(request.user, 'additional_companies'):
            user_companies.extend(request.user.additional_companies.values_list('id', flat=True))
        
        generators = ContactGenerator.objects.filter(company_id__in=user_companies)
    
    generators = generators.order_by('-created_at')
    
    context = {
        'generators': generators,
        'page_title': 'Generadores de Contactos'
    }
    
    return render(request, 'tickets/contact_generator_list.html', context)


@login_required
def contact_generator_create(request):
    """Crear nuevo generador de contactos"""
    if not is_agent(request.user):
        return redirect('dashboard')
    
    if request.method == 'POST':
        form = ContactGeneratorForm(request.POST, user=request.user)
        if form.is_valid():
            generator = form.save(commit=False)
            generator.created_by = request.user
            generator.save()
            
            messages.success(request, f'Generador de contactos "{generator.title}" creado correctamente.')
            return redirect('contact_generator_detail', pk=generator.pk)
    else:
        form = ContactGeneratorForm(user=request.user)
    
    context = {
        'form': form,
        'page_title': 'Crear Generador de Contactos',
        'form_title': 'Nuevo Generador de Contactos'
    }
    
    return render(request, 'tickets/contact_generator_form.html', context)


@login_required
def contact_generator_detail(request, pk):
    """Detalle de un generador de contactos"""
    if not is_agent(request.user):
        return redirect('dashboard')
    
    generator = get_object_or_404(ContactGenerator, pk=pk)
    
    # Verificar permisos
    if not request.user.is_superuser:
        user_companies = []
        if hasattr(request.user, 'company'):
            user_companies.append(request.user.company.id)
        if hasattr(request.user, 'additional_companies'):
            user_companies.extend(request.user.additional_companies.values_list('id', flat=True))
        
        if generator.company.id not in user_companies:
            messages.error(request, 'No tienes permisos para ver este generador.')
            return redirect('contact_generator_list')
    
    # Obtener estadísticas de contactos generados
    recent_contacts = Contact.objects.filter(
        source=f"Generador: {generator.title}",
        created_by=generator.created_by
    ).order_by('-created_at')[:10]
    
    context = {
        'generator': generator,
        'recent_contacts': recent_contacts,
        'contacts_count': generator.get_contacts_count(),
        'page_title': f'Generador: {generator.title}'
    }
    
    return render(request, 'tickets/contact_generator_detail.html', context)


@login_required
def contact_generator_edit(request, pk):
    """Editar generador de contactos"""
    if not is_agent(request.user):
        return redirect('dashboard')
    
    generator = get_object_or_404(ContactGenerator, pk=pk)
    
    # Verificar permisos
    if not request.user.is_superuser:
        user_companies = []
        if hasattr(request.user, 'company'):
            user_companies.append(request.user.company.id)
        if hasattr(request.user, 'additional_companies'):
            user_companies.extend(request.user.additional_companies.values_list('id', flat=True))
        
        if generator.company.id not in user_companies:
            messages.error(request, 'No tienes permisos para editar este generador.')
            return redirect('contact_generator_list')
    
    if request.method == 'POST':
        form = ContactGeneratorForm(request.POST, instance=generator, user=request.user)
        if form.is_valid():
            form.save()
            messages.success(request, f'Generador "{generator.title}" actualizado correctamente.')
            return redirect('contact_generator_detail', pk=generator.pk)
    else:
        form = ContactGeneratorForm(instance=generator, user=request.user)
    
    context = {
        'form': form,
        'generator': generator,
        'page_title': f'Editar: {generator.title}',
        'form_title': f'Editar Generador: {generator.title}'
    }
    
    return render(request, 'tickets/contact_generator_form.html', context)


@login_required
def contact_generator_delete(request, pk):
    """Eliminar generador de contactos"""
    if not is_agent(request.user):
        return redirect('dashboard')
    
    generator = get_object_or_404(ContactGenerator, pk=pk)
    
    # Verificar permisos
    if not request.user.is_superuser:
        user_companies = []
        if hasattr(request.user, 'company'):
            user_companies.append(request.user.company.id)
        if hasattr(request.user, 'additional_companies'):
            user_companies.extend(request.user.additional_companies.values_list('id', flat=True))
        
        if generator.company.id not in user_companies:
            messages.error(request, 'No tienes permisos para eliminar este generador.')
            return redirect('contact_generator_list')
    
    if request.method == 'POST':
        generator_title = generator.title
        generator.delete()
        messages.success(request, f'Generador "{generator_title}" eliminado correctamente.')
        return redirect('contact_generator_list')
    
    context = {
        'generator': generator,
        'page_title': f'Eliminar: {generator.title}',
        'contacts_count': generator.get_contacts_count()
    }
    
    return render(request, 'tickets/contact_generator_delete.html', context)


@login_required
def contact_generator_toggle_active(request, pk):
    """Activar/desactivar generador de contactos"""
    if not is_agent(request.user):
        return redirect('dashboard')
    
    generator = get_object_or_404(ContactGenerator, pk=pk)
    
    # Verificar permisos
    if not request.user.is_superuser:
        user_companies = []
        if hasattr(request.user, 'company'):
            user_companies.append(request.user.company.id)
        if hasattr(request.user, 'additional_companies'):
            user_companies.extend(request.user.additional_companies.values_list('id', flat=True))
        
        if generator.company.id not in user_companies:
            messages.error(request, 'No tienes permisos para modificar este generador.')
            return redirect('contact_generator_list')
    
    generator.is_active = not generator.is_active
    generator.save()
    
    if generator.is_active:
        messages.success(request, f'Generador "{generator.title}" activado. El formulario público está disponible.')
    else:
        messages.warning(request, f'Generador "{generator.title}" desactivado. El formulario público no está disponible.')
    
    return redirect('contact_generator_detail', pk=generator.pk)


def contact_generator_public(request, token):
    """Vista pública para que los usuarios llenen el formulario de contacto"""
    generator = get_object_or_404(ContactGenerator, public_token=token, is_active=True)
    
    if request.method == 'POST':
        form = PublicContactForm(request.POST, generator=generator)
        if form.is_valid():
            contact = form.save(commit=False)
            contact.source = f"Generador: {generator.title}"
            contact.status = 'positive'  # Por defecto positivo
            contact.created_by = generator.created_by  # El usuario que creó el generador
            
            # Si no se proporcionó empresa o está vacía, usar la empresa del generador
            if not contact.company or contact.company.strip() == '':
                contact.company = generator.company.name
            
            contact.save()
            
            # Mostrar mensaje de éxito
            context = {
                'generator': generator,
                'success': True,
                'success_message': generator.success_message,
                'page_title': f'{generator.title} - {generator.company.name}',
                'is_public_view': True
            }
            return render(request, 'tickets/contact_generator_public.html', context)
    else:
        form = PublicContactForm(generator=generator)
    
    context = {
        'generator': generator,
        'form': form,
        'page_title': f'{generator.title} - {generator.company.name}',
        'is_public_view': True
    }
    
    return render(request, 'tickets/contact_generator_public.html', context)


@login_required
def company_request_generator_list(request):
    """Lista de generadores de solicitudes de empresa"""
    if not is_agent(request.user):
        return redirect('dashboard')

    if request.user.is_superuser:
        generators = CompanyRequestGenerator.objects.all()
    else:
        user_companies = []
        if hasattr(request.user, 'company'):
            user_companies.append(request.user.company.id)
        if hasattr(request.user, 'additional_companies'):
            user_companies.extend(request.user.additional_companies.values_list('id', flat=True))

        generators = CompanyRequestGenerator.objects.filter(company_id__in=user_companies)

    generators = generators.order_by('-created_at')

    context = {
        'generators': generators,
        'page_title': 'Generadores de Solicitudes Empresas'
    }
    return render(request, 'tickets/company_request_generator_list.html', context)


@login_required
def company_request_generator_create(request):
    if not is_agent(request.user):
        return redirect('dashboard')

    if request.method == 'POST':
        form = CompanyRequestGeneratorForm(request.POST, user=request.user)
        if form.is_valid():
            generator = form.save(commit=False)
            generator.created_by = request.user
            generator.save()
            messages.success(request, f'Generador "{generator.title}" creado correctamente.')
            return redirect('company_request_generator_detail', pk=generator.pk)
    else:
        form = CompanyRequestGeneratorForm(user=request.user)

    context = {
        'form': form,
        'page_title': 'Crear Generador de Solicitudes Empresas',
        'form_title': 'Nuevo Generador de Solicitudes'
    }
    return render(request, 'tickets/company_request_generator_form.html', context)


@login_required
def company_request_generator_detail(request, pk):
    if not is_agent(request.user):
        return redirect('dashboard')

    generator = get_object_or_404(CompanyRequestGenerator, pk=pk)

    if not request.user.is_superuser:
        user_companies = []
        if hasattr(request.user, 'company'):
            user_companies.append(request.user.company.id)
        if hasattr(request.user, 'additional_companies'):
            user_companies.extend(request.user.additional_companies.values_list('id', flat=True))

        if generator.company.id not in user_companies:
            messages.error(request, 'No tienes permisos para ver este generador.')
            return redirect('company_request_generator_list')

    recent_requests = generator.get_recent_requests()

    context = {
        'generator': generator,
        'recent_requests': recent_requests,
        'requests_count': generator.get_requests_count(),
        'page_title': f'Generador: {generator.title}'
    }
    return render(request, 'tickets/company_request_generator_detail.html', context)


@login_required
def company_request_generator_edit(request, pk):
    if not is_agent(request.user):
        return redirect('dashboard')

    generator = get_object_or_404(CompanyRequestGenerator, pk=pk)

    if not request.user.is_superuser:
        user_companies = []
        if hasattr(request.user, 'company'):
            user_companies.append(request.user.company.id)
        if hasattr(request.user, 'additional_companies'):
            user_companies.extend(request.user.additional_companies.values_list('id', flat=True))

        if generator.company.id not in user_companies:
            messages.error(request, 'No tienes permisos para editar este generador.')
            return redirect('company_request_generator_list')

    if request.method == 'POST':
        form = CompanyRequestGeneratorForm(request.POST, instance=generator, user=request.user)
        if form.is_valid():
            form.save()
            messages.success(request, f'Generador "{generator.title}" actualizado correctamente.')
            return redirect('company_request_generator_detail', pk=generator.pk)
    else:
        form = CompanyRequestGeneratorForm(instance=generator, user=request.user)

    context = {
        'form': form,
        'generator': generator,
        'page_title': f'Editar: {generator.title}',
        'form_title': f'Editar Generador: {generator.title}'
    }
    return render(request, 'tickets/company_request_generator_form.html', context)


@login_required
def company_request_generator_delete(request, pk):
    if not is_agent(request.user):
        return redirect('dashboard')

    generator = get_object_or_404(CompanyRequestGenerator, pk=pk)

    if not request.user.is_superuser:
        user_companies = []
        if hasattr(request.user, 'company'):
            user_companies.append(request.user.company.id)
        if hasattr(request.user, 'additional_companies'):
            user_companies.extend(request.user.additional_companies.values_list('id', flat=True))

        if generator.company.id not in user_companies:
            messages.error(request, 'No tienes permisos para eliminar este generador.')
            return redirect('company_request_generator_list')

    if request.method == 'POST':
        title = generator.title
        generator.delete()
        messages.success(request, f'Generador "{title}" eliminado correctamente.')
        return redirect('company_request_generator_list')

    context = {
        'generator': generator,
        'page_title': f'Eliminar: {generator.title}',
        'requests_count': generator.get_requests_count()
    }
    return render(request, 'tickets/company_request_generator_delete.html', context)


@login_required
def company_request_generator_toggle_active(request, pk):
    if not is_agent(request.user):
        return redirect('dashboard')

    generator = get_object_or_404(CompanyRequestGenerator, pk=pk)

    if not request.user.is_superuser:
        user_companies = []
        if hasattr(request.user, 'company'):
            user_companies.append(request.user.company.id)
        if hasattr(request.user, 'additional_companies'):
            user_companies.extend(request.user.additional_companies.values_list('id', flat=True))

        if generator.company.id not in user_companies:
            messages.error(request, 'No tienes permisos para modificar este generador.')
            return redirect('company_request_generator_list')

    generator.is_active = not generator.is_active
    generator.save()
    if generator.is_active:
        messages.success(request, f'Generador "{generator.title}" activado.')
    else:
        messages.warning(request, f'Generador "{generator.title}" desactivado.')

    return redirect('company_request_generator_detail', pk=generator.pk)


def company_request_public(request, token):
    """Vista pública para enviar solicitudes de empresas"""
    generator = get_object_or_404(CompanyRequestGenerator, public_token=token, is_active=True)

    if request.method == 'POST':
        form = PublicCompanyRequestForm(request.POST, generator=generator)
        if form.is_valid():
            req = form.save(commit=False)
            # generar secuencia
            req.sequence = generator.generate_sequence()
            req.generator = generator
            req.created_by = None  # público, no user asociado
            req.save()

            context = {
                'generator': generator,
                'success': True,
                'success_message': generator.success_message,
                'page_title': f'{generator.title} - {generator.company.name}',
                'is_public_view': True,
                'request_obj': req
            }
            return render(request, 'tickets/company_request_public.html', context)
    else:
        form = PublicCompanyRequestForm(generator=generator)

    context = {
        'generator': generator,
        'form': form,
        'page_title': f'{generator.title} - {generator.company.name}',
        'is_public_view': True
    }
    return render(request, 'tickets/company_request_public.html', context)


@login_required
def company_request_list(request, generator_pk):
    """Lista todas las solicitudes de un generador específico"""
    if not is_agent(request.user):
        return redirect('dashboard')
    
    generator = get_object_or_404(CompanyRequestGenerator, pk=generator_pk)
    
    # Verificar permisos
    if not request.user.is_superuser:
        user_companies = []
        if hasattr(request.user, 'company'):
            user_companies.append(request.user.company.id)
        if hasattr(request.user, 'additional_companies'):
            user_companies.extend(request.user.additional_companies.values_list('id', flat=True))
        
        if generator.company.id not in user_companies:
            messages.error(request, 'No tienes permisos para ver estas solicitudes.')
            return redirect('company_request_generator_list')
    
    # Filtros
    status_filter = request.GET.get('status', '')
    date_from = request.GET.get('date_from', '')
    date_to = request.GET.get('date_to', '')
    
    requests = CompanyRequest.objects.filter(generator=generator)
    
    if status_filter:
        requests = requests.filter(status=status_filter)
    
    if date_from:
        from datetime import datetime
        try:
            date_from_obj = datetime.strptime(date_from, '%Y-%m-%d').date()
            requests = requests.filter(request_date__gte=date_from_obj)
        except ValueError:
            pass
    
    if date_to:
        from datetime import datetime
        try:
            date_to_obj = datetime.strptime(date_to, '%Y-%m-%d').date()
            requests = requests.filter(request_date__lte=date_to_obj)
        except ValueError:
            pass
    
    requests = requests.order_by('-created_at')
    
    # KPIs
    total_requests = generator.get_requests_count()
    status_stats = {}
    for status_choice in CompanyRequest.STATUS_CHOICES:
        status_key = status_choice[0]
        status_stats[status_key] = CompanyRequest.objects.filter(
            generator=generator, status=status_key
        ).count()
    
    context = {
        'generator': generator,
        'requests': requests,
        'total_requests': total_requests,
        'status_stats': status_stats,
        'status_filter': status_filter,
        'date_from': date_from,
        'date_to': date_to,
        'page_title': f'Solicitudes de {generator.title}'
    }
    
    return render(request, 'tickets/company_request_list.html', context)


def public_tickets_and_requests_view(request):
    """Vista pública que muestra la última solicitud de empresa y listado de solicitudes"""
    
    # Obtener la última solicitud de empresa
    latest_request = CompanyRequest.objects.select_related(
        'generator', 'generator__company'
    ).order_by('-created_at').first()
    
    # Obtener todas las solicitudes de empresa (últimas 20)
    recent_requests = CompanyRequest.objects.select_related(
        'generator', 'generator__company'
    ).order_by('-created_at')[:20]
    
    # Estadísticas generales
    total_requests = CompanyRequest.objects.count()
    
    # Estadísticas por estado de solicitudes
    status_stats = {}
    for status_choice in CompanyRequest.STATUS_CHOICES:
        status_key = status_choice[0]
        status_stats[status_key] = CompanyRequest.objects.filter(status=status_key).count()
    
    context = {
        'latest_request': latest_request,
        'recent_requests': recent_requests,
        'total_requests': total_requests,
        'status_stats': status_stats,
        'page_title': 'Dashboard Público - Solicitudes de Empresa'
    }
    
    return render(request, 'tickets/public_tickets_and_requests.html', context)


@login_required
def update_company_request_status(request, request_id):
    """Vista AJAX para actualizar el estado de una solicitud de empresa"""
    if request.method == 'POST':
        try:
            company_request = get_object_or_404(CompanyRequest, id=request_id)
            new_status = request.POST.get('status')
            
            if new_status in dict(CompanyRequest.STATUS_CHOICES):
                company_request.status = new_status
                
                # Si se marca como ejecutada, registrar fecha y usuario
                if new_status == 'executed':
                    company_request.executed_at = timezone.now()
                    company_request.executed_by = request.user
                
                company_request.save()
                
                response_data = {
                    'success': True,
                    'message': f'Estado actualizado a {company_request.get_status_display()}',
                    'new_status': company_request.status,
                    'status_display': company_request.get_status_display()
                }
                
                # Agregar información de ejecución si está disponible
                if company_request.executed_at:
                    response_data['executed_at'] = company_request.executed_at.strftime('%d/%m/%Y %H:%M:%S')
                    response_data['executed_by'] = company_request.executed_by.get_full_name() or company_request.executed_by.username if company_request.executed_by else ''
                
                return JsonResponse(response_data)
            else:
                return JsonResponse({
                    'success': False,
                    'message': 'Estado no válido'
                })
        except Exception as e:
            return JsonResponse({
                'success': False,
                'message': str(e)
            })
    
    return JsonResponse({'success': False, 'message': 'Método no permitido'})


# ============= VISTAS PARA SISTEMA DE FORMULARIOS =============

@login_required
def form_list(request):
    """Lista de formularios"""
    forms = Form.objects.filter(created_by=request.user).order_by('-created_at')
    
    # Filtrar por empresa si es necesario
    if not (request.user.is_staff or request.user.is_superuser):
        user_companies = []
        if hasattr(request.user, 'company'):
            user_companies.append(request.user.company.id)
        if hasattr(request.user, 'additional_companies'):
            user_companies.extend(request.user.additional_companies.values_list('id', flat=True))
        forms = forms.filter(company_id__in=user_companies)
    
    context = {
        'forms': forms,
        'page_title': 'Mis Formularios'
    }
    return render(request, 'tickets/form_list.html', context)


@login_required
def form_create(request):
    """Crear formulario"""
    if request.method == 'POST':
        form = FormForm(request.POST, user=request.user)
        if form.is_valid():
            form_obj = form.save(commit=False)
            form_obj.created_by = request.user
            form_obj.save()
            messages.success(request, 'Formulario creado exitosamente')
            return redirect('form_detail', pk=form_obj.pk)
    else:
        form = FormForm(user=request.user)
    
    context = {
        'form': form,
        'page_title': 'Crear Formulario'
    }
    return render(request, 'tickets/form_form.html', context)


@login_required
def form_detail(request, pk):
    """Detalle del formulario"""
    form_obj = get_object_or_404(Form, pk=pk, created_by=request.user)
    
    # Obtener estadísticas
    total_responses = form_obj.get_total_responses()
    average_score = form_obj.get_average_score()
    recent_responses = form_obj.responses.all()[:10]
    
    context = {
        'form': form_obj,
        'total_responses': total_responses,
        'average_score': average_score,
        'recent_responses': recent_responses,
        'page_title': f'Formulario: {form_obj.title}'
    }
    return render(request, 'tickets/form_detail.html', context)


@login_required
def form_generate_ai_questions(request, pk):
    """Genera preguntas automáticamente usando IA basándose en título y descripción"""
    from django.http import JsonResponse
    from .models import Form, SystemConfiguration
    
    try:
        form_obj = get_object_or_404(Form, pk=pk, created_by=request.user)
        
        if request.method != 'POST':
            return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
        
        # Verificar configuración de IA
        config = SystemConfiguration.objects.first()
        if not config or not config.ai_chat_enabled or not config.openai_api_key:
            return JsonResponse({
                'success': False, 
                'error': 'OpenAI no está configurado. Por favor configura la API key en Configuración del Sistema.'
            }, status=400)
        
        # Generar preguntas con IA
        import openai
        client = openai.OpenAI(api_key=config.openai_api_key)
        
        prompt = f"""
Eres un experto en diseño de formularios y encuestas. Basándote en el siguiente título y descripción de un formulario, genera preguntas relevantes y útiles con sus posibles opciones de respuesta.

TÍTULO DEL FORMULARIO: {form_obj.title}

DESCRIPCIÓN DEL FORMULARIO: {form_obj.description}

INSTRUCCIONES:
- Genera entre 5 y 8 preguntas relevantes para este formulario
- Para cada pregunta, especifica el tipo más apropiado
- Proporciona opciones de respuesta cuando sea necesario
- Las preguntas deben ser claras, específicas y útiles
- Evita preguntas redundantes o innecesarias
- NO uses formato Markdown, solo texto plano
- Responde en español

FORMATO DE RESPUESTA REQUERIDO:
{{
  "questions": [
    {{
      "text": "Texto de la pregunta",
      "type": "text|textarea|select|radio|checkbox|number|email|date",
      "required": true/false,
      "options": ["opción 1", "opción 2", "opción 3"] // Solo para select, radio y checkbox
    }}
  ]
}}

Genera preguntas que sean apropiadas para el contexto del formulario descrito.
"""

        response = client.chat.completions.create(
            model=config.openai_model,
            messages=[
                {
                    "role": "system",
                    "content": "Eres un experto en diseño de formularios. Generas preguntas relevantes y útiles basándote en el título y descripción proporcionados. Respondes únicamente en formato JSON válido sin explicaciones adicionales."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            max_tokens=2000,
            temperature=0.7
        )
        
        # Obtener la respuesta de la IA
        ai_response = response.choices[0].message.content.strip()
        
        # Limpiar la respuesta si tiene formato markdown
        import re
        ai_response = re.sub(r'```json\s*', '', ai_response)
        ai_response = re.sub(r'```\s*$', '', ai_response)
        
        # Intentar parsear como JSON
        import json
        try:
            generated_data = json.loads(ai_response)
            questions = generated_data.get('questions', [])
            
            if not questions:
                return JsonResponse({
                    'success': False,
                    'error': 'No se pudieron generar preguntas. Intenta con una descripción más detallada.'
                })
            
            return JsonResponse({
                'success': True,
                'questions': questions,
                'form_title': form_obj.title,
                'form_description': form_obj.description,
                'total_generated': len(questions)
            })
            
        except json.JSONDecodeError:
            return JsonResponse({
                'success': False,
                'error': 'Error al procesar la respuesta de la IA. Por favor intenta de nuevo.',
                'raw_response': ai_response[:500]  # Primeros 500 caracteres para debug
            })
        
    except Exception as e:
        return JsonResponse({
            'success': False, 
            'error': f'Error generando preguntas: {str(e)}'
        }, status=500)


@login_required
def form_add_ai_questions(request, pk):
    """Agrega múltiples preguntas generadas por IA al formulario"""
    from django.http import JsonResponse
    from django.db import models
    from .models import Form, FormQuestion
    import json
    
    try:
        form_obj = get_object_or_404(Form, pk=pk, created_by=request.user)
        
        if request.method != 'POST':
            return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
        
        # Obtener las preguntas del request
        data = json.loads(request.body)
        questions = data.get('questions', [])
        
        if not questions:
            return JsonResponse({'success': False, 'error': 'No se proporcionaron preguntas'})
        
        # Obtener el último order para continuar la secuencia
        last_order = FormQuestion.objects.filter(form=form_obj).aggregate(
            max_order=models.Max('order')
        )['max_order'] or 0
        
        created_questions = []
        
        # Crear cada pregunta
        for i, question_data in enumerate(questions):
            # Mapear tipos de IA a tipos del modelo
            type_mapping = {
                'text': 'text',
                'textarea': 'text',  # Usar text para textarea también
                'select': 'multiple_choice',
                'radio': 'multiple_choice',
                'checkbox': 'multiple_choice',
                'number': 'number',
                'email': 'text',  # Usar text para email
                'date': 'text'    # Usar text para date también
            }
            
            question_type = type_mapping.get(question_data.get('type', 'text'), 'text')
            
            # Crear la pregunta
            question = FormQuestion.objects.create(
                form=form_obj,
                question_text=question_data.get('text', ''),
                question_type=question_type,
                order=last_order + i + 1,
                is_required=question_data.get('required', True)
            )
            
            # Si es multiple_choice y tiene opciones, crearlas
            if question_type == 'multiple_choice' and question_data.get('options'):
                from .models import FormQuestionOption
                for j, option_text in enumerate(question_data['options']):
                    FormQuestionOption.objects.create(
                        question=question,
                        option_text=option_text,
                        score=1  # Puntuación por defecto
                    )
            
            created_questions.append({
                'id': question.id,
                'text': question.question_text,
                'type': question.get_question_type_display(),
                'order': question.order
            })
        
        return JsonResponse({
            'success': True,
            'message': f'Se agregaron {len(created_questions)} preguntas al formulario',
            'created_questions': created_questions
        })
        
    except json.JSONDecodeError:
        return JsonResponse({'success': False, 'error': 'Datos JSON inválidos'}, status=400)
    except Exception as e:
        return JsonResponse({
            'success': False, 
            'error': f'Error creando preguntas: {str(e)}'
        }, status=500)


@login_required
def form_edit(request, pk):
    """Editar formulario"""
    form_obj = get_object_or_404(Form, pk=pk, created_by=request.user)
    
    if request.method == 'POST':
        form = FormForm(request.POST, instance=form_obj, user=request.user)
        if form.is_valid():
            form.save()
            messages.success(request, 'Formulario actualizado exitosamente')
            return redirect('form_detail', pk=form_obj.pk)
    else:
        form = FormForm(instance=form_obj, user=request.user)
    
    context = {
        'form': form,
        'form_obj': form_obj,
        'page_title': f'Editar: {form_obj.title}'
    }
    return render(request, 'tickets/form_form.html', context)


@login_required
def form_delete(request, pk):
    """Eliminar formulario"""
    form_obj = get_object_or_404(Form, pk=pk, created_by=request.user)
    
    if request.method == 'POST':
        form_title = form_obj.title
        form_obj.delete()
        messages.success(request, f'Formulario "{form_title}" eliminado exitosamente')
        return redirect('form_list')
    
    context = {
        'form': form_obj,
        'page_title': f'Eliminar: {form_obj.title}'
    }
    return render(request, 'tickets/form_delete.html', context)


# === VISTA PÚBLICA PARA RESPONDER FORMULARIOS ===

def form_public(request, token):
    """Vista pública para responder un formulario"""
    form_obj = get_object_or_404(Form, public_token=token, is_active=True)
    
    # Variable para controlar si se muestra el formulario
    form_submitted = False
    
    # Verificar si se solicita resetear el formulario
    if request.GET.get('reset') == '1':
        # Redirigir a la misma URL sin el parámetro reset para limpiar la URL
        from django.shortcuts import redirect
        return redirect('form_public', token=token)
    
    if request.method == 'POST':
        form = PublicFormResponseForm(request.POST, form=form_obj)
        if form.is_valid():
            # Crear la respuesta
            response = FormResponse.objects.create(
                form=form_obj,
                respondent_name=form.cleaned_data.get('respondent_name', ''),
                respondent_email=form.cleaned_data.get('respondent_email', '')
            )
            
            # Crear las respuestas individuales
            for question in form_obj.questions.all():
                field_name = f'question_{question.id}'
                if field_name in form.cleaned_data:
                    answer_value = form.cleaned_data[field_name]
                    
                    answer = FormAnswer.objects.create(
                        response=response,
                        question=question
                    )
                    
                    if question.question_type == 'text':
                        answer.text_answer = answer_value
                    elif question.question_type == 'number':
                        answer.number_answer = answer_value
                    elif question.question_type == 'multiple_choice':
                        option = FormQuestionOption.objects.get(id=answer_value)
                        answer.selected_option = option
                    
                    answer.save()
            
            # Calcular puntuación total
            response.calculate_total_score()
            
            # Marcar como enviado para mostrar mensaje de éxito
            form_submitted = True
            form = None  # Limpiar el formulario
    else:
        form = PublicFormResponseForm(form=form_obj)
    
    context = {
        'form': form,
        'form_obj': form_obj,
        'page_title': form_obj.title,
        'form_submitted': form_submitted
    }
    return render(request, 'tickets/form_public.html', context)


# === VISTA PARA RESPUESTAS ===

@login_required
def form_responses(request, pk):
    """Ver respuestas del formulario"""
    form_obj = get_object_or_404(Form, pk=pk, created_by=request.user)
    responses = form_obj.responses.all().order_by('-response_date')
    
    # Paginación
    paginator = Paginator(responses, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'form': form_obj,
        'page_obj': page_obj,
        'total_responses': form_obj.get_total_responses(),
        'average_score': form_obj.get_average_score(),
        'page_title': f'Respuestas - {form_obj.title}'
    }
    return render(request, 'tickets/form_responses.html', context)


@login_required
def form_response_detail(request, form_pk, response_pk):
    """Ver detalle de una respuesta específica"""
    form_obj = get_object_or_404(Form, pk=form_pk, created_by=request.user)
    response = get_object_or_404(FormResponse, pk=response_pk, form=form_obj)
    
    # Obtener todas las respuestas con sus preguntas
    answers = response.answers.select_related('question', 'selected_option').order_by('question__order')
    
    # Crear una estructura organizada de preguntas y respuestas
    questions_with_answers = []
    for question in form_obj.questions.all().order_by('order'):
        # Buscar la respuesta para esta pregunta
        answer = answers.filter(question=question).first()
        
        answer_data = {
            'question': question,
            'answer': answer,
            'display_answer': None,
            'score': 0
        }
        
        if answer:
            if question.question_type == 'text':
                answer_data['display_answer'] = answer.text_answer or 'Sin respuesta'
            elif question.question_type == 'number':
                answer_data['display_answer'] = answer.number_answer or 'Sin respuesta'
            elif question.question_type == 'multiple_choice':
                if answer.selected_option:
                    answer_data['display_answer'] = answer.selected_option.option_text
                    answer_data['score'] = answer.selected_option.score
                else:
                    answer_data['display_answer'] = 'Sin selección'
        else:
            answer_data['display_answer'] = 'Sin respuesta'
        
        questions_with_answers.append(answer_data)
    
    context = {
        'form': form_obj,
        'response': response,
        'questions_with_answers': questions_with_answers,
        'page_title': f'Detalle de Respuesta - {form_obj.title}'
    }
    return render(request, 'tickets/form_response_detail.html', context)


@login_required
def form_ai_analysis(request, pk):
    """Analiza las respuestas del formulario usando IA y propone mejoras"""
    from django.http import JsonResponse
    from .models import Form, SystemConfiguration
    import json
    
    try:
        form_obj = get_object_or_404(Form, pk=pk, created_by=request.user)
        
        if request.method != 'POST':
            return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
        
        # Verificar que haya respuestas
        responses = form_obj.responses.all()
        if not responses.exists():
            return JsonResponse({'success': False, 'error': 'No hay respuestas para analizar'})
        
        # Verificar configuración de IA
        config = SystemConfiguration.objects.first()
        if not config or not config.ai_chat_enabled or not config.openai_api_key:
            return JsonResponse({
                'success': False, 
                'error': 'OpenAI no está configurado. Por favor configura la API key en Configuración del Sistema.'
            }, status=400)
        
        # Recopilar datos de las respuestas
        analysis_data = {
            'form_title': form_obj.title,
            'form_description': form_obj.description,
            'total_responses': responses.count(),
            'average_score': form_obj.get_average_score(),
            'questions': [],
            'responses_summary': []
        }
        
        # Analizar cada pregunta
        for question in form_obj.questions.all():
            question_data = {
                'text': question.question_text,
                'type': question.question_type,
                'required': question.is_required,
                'answers': []
            }
            
            answers = question.formanswer_set.all()
            for answer in answers:
                if question.question_type == 'text':
                    if answer.text_answer:
                        question_data['answers'].append(answer.text_answer)
                elif question.question_type == 'number':
                    if answer.number_answer:
                        question_data['answers'].append(str(answer.number_answer))
                elif question.question_type == 'multiple_choice' and answer.selected_option:
                    question_data['answers'].append({
                        'option': answer.selected_option.option_text,
                        'score': answer.selected_option.score
                    })
            
            analysis_data['questions'].append(question_data)
        
        # Generar análisis con IA
        import openai
        client = openai.OpenAI(api_key=config.openai_api_key)
        
        prompt = f"""
Eres un experto en análisis de formularios y experiencia de usuario. Analiza los siguientes datos de un formulario y sus respuestas para proporcionar mejoras específicas y accionables.

DATOS DEL FORMULARIO:
Título: {analysis_data['form_title']}
Descripción: {analysis_data['form_description']}
Total de respuestas: {analysis_data['total_responses']}
Puntuación promedio: {analysis_data['average_score']}

PREGUNTAS Y RESPUESTAS:
{json.dumps(analysis_data['questions'], ensure_ascii=False, indent=2)}

INSTRUCCIONES:
1. Identifica problemas específicos en el formulario (preguntas confusas, opciones inadecuadas, etc.)
2. Propón mejoras concretas y aplicables
3. Evalúa la efectividad general del formulario
4. Proporciona recomendaciones prioritarias

FORMATO DE RESPUESTA REQUERIDO (JSON):
{{
    "overall_score": 8,
    "problems": [
        {{
            "type": "Pregunta confusa",
            "description": "La pregunta X no es clara",
            "severity": "Alta"
        }}
    ],
    "improvements": [
        {{
            "title": "Mejorar claridad",
            "description": "Reescribir la pregunta para ser más específica",
            "priority": "Alta",
            "steps": ["Paso 1", "Paso 2"]
        }}
    ],
    "strengths": ["Fortaleza 1", "Fortaleza 2"],
    "main_recommendation": "Recomendación principal"
}}

Responde únicamente en formato JSON válido, en español, sin explicaciones adicionales.
"""

        response = client.chat.completions.create(
            model=config.openai_model,
            messages=[
                {
                    "role": "system",
                    "content": "Eres un experto en análisis de formularios y UX. Respondes únicamente en formato JSON válido con análisis detallados y mejoras específicas."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            max_tokens=2000,
            temperature=0.7
        )
        
        # Obtener la respuesta de la IA
        ai_response = response.choices[0].message.content.strip()
        
        # Limpiar la respuesta si tiene formato markdown
        import re
        ai_response = re.sub(r'```json\s*', '', ai_response)
        ai_response = re.sub(r'```\s*$', '', ai_response)
        
        # Intentar parsear como JSON
        try:
            analysis_result = json.loads(ai_response)
            
            # Guardar el análisis en la base de datos
            from .models import FormAIAnalysis
            ai_analysis = FormAIAnalysis.objects.create(
                form=form_obj,
                created_by=request.user,
                overall_score=analysis_result.get('overall_score', 0),
                problems=analysis_result.get('problems', []),
                improvements=analysis_result.get('improvements', []),
                strengths=analysis_result.get('strengths', []),
                main_recommendation=analysis_result.get('main_recommendation', ''),
                total_responses=responses.count(),
                analysis_version='1.0'
            )
            
            return JsonResponse({
                'success': True,
                'analysis': analysis_result,
                'analysis_id': ai_analysis.id,
                'form_title': form_obj.title,
                'total_responses': responses.count(),
                'saved': True
            })
            
        except json.JSONDecodeError:
            return JsonResponse({
                'success': False,
                'error': 'Error al procesar el análisis de la IA. Por favor intenta de nuevo.',
                'raw_response': ai_response[:500]  # Primeros 500 caracteres para debug
            })
        
    except Exception as e:
        return JsonResponse({
            'success': False, 
            'error': f'Error realizando análisis: {str(e)}'
        }, status=500)


# ==================== VISTAS DE CONTROL DE LICENCIAS ====================

@login_required
def license_list(request):
    """Lista todas las licencias"""
    licenses = License.objects.all().order_by('-created_at')
    
    # Filtros
    company_filter = request.GET.get('company')
    status_filter = request.GET.get('status')
    product_filter = request.GET.get('product')
    
    if company_filter:
        licenses = licenses.filter(company_id=company_filter)
    if status_filter:
        licenses = licenses.filter(status=status_filter)
    if product_filter:
        licenses = licenses.filter(product__icontains=product_filter)
    
    # Estadísticas
    total_licenses = License.objects.count()
    active_licenses = License.objects.filter(status='active').count()
    expired_licenses = License.objects.filter(end_date__lt=timezone.now().date()).count()
    
    # Actualizar estados de licencias expiradas
    License.objects.filter(
        end_date__lt=timezone.now().date(),
        status='active'
    ).update(status='expired')
    
    companies = Company.objects.all()
    
    context = {
        'licenses': licenses,
        'companies': companies,
        'total_licenses': total_licenses,
        'active_licenses': active_licenses,
        'expired_licenses': expired_licenses,
        'title': 'Control de Licencias',
        'current_filters': {
            'company': company_filter,
            'status': status_filter,
            'product': product_filter,
        }
    }
    
    return render(request, 'tickets/license_list.html', context)


@login_required
def license_create(request):
    """Crear nueva licencia"""
    if request.method == 'POST':
        license_obj = License(
            company_id=request.POST.get('company'),
            product=request.POST.get('product'),
            start_date=request.POST.get('start_date'),
            end_date=request.POST.get('end_date'),
            notes=request.POST.get('notes', ''),
            created_by=request.user
        )
        
        # Si se proporciona una clave personalizada
        custom_key = request.POST.get('license_key', '').strip().upper()
        if custom_key:
            if len(custom_key) == 12 and custom_key.isalnum():
                if not License.objects.filter(license_key=custom_key).exists():
                    license_obj.license_key = custom_key
                else:
                    messages.error(request, 'La clave de licencia ya existe.')
                    return render(request, 'tickets/license_form.html', {
                        'companies': Company.objects.all(),
                        'title': 'Crear Licencia'
                    })
            else:
                messages.error(request, 'La clave debe tener exactamente 12 caracteres alfanuméricos.')
                return render(request, 'tickets/license_form.html', {
                    'companies': Company.objects.all(),
                    'title': 'Crear Licencia'
                })
        
        license_obj.save()
        messages.success(request, f'Licencia {license_obj.license_key} creada exitosamente.')
        return redirect('license_detail', pk=license_obj.pk)
    
    companies = Company.objects.all()
    context = {
        'companies': companies,
        'title': 'Crear Licencia'
    }
    
    return render(request, 'tickets/license_form.html', context)


@login_required
def license_detail(request, pk):
    """Detalle de una licencia"""
    license_obj = get_object_or_404(License, pk=pk)
    
    # Generar URL del QR
    qr_url = license_obj.get_qr_data()
    
    context = {
        'license': license_obj,
        'qr_url': qr_url,
        'title': f'Licencia {license_obj.license_key}'
    }
    
    return render(request, 'tickets/license_detail.html', context)


@login_required
def license_edit(request, pk):
    """Editar licencia"""
    license_obj = get_object_or_404(License, pk=pk)
    
    if request.method == 'POST':
        # Actualizar campos
        license_obj.company_id = request.POST.get('company')
        license_obj.product = request.POST.get('product')
        license_obj.start_date = request.POST.get('start_date')
        license_obj.end_date = request.POST.get('end_date')
        license_obj.status = request.POST.get('status')
        license_obj.notes = request.POST.get('notes', '')
        
        # Actualizar clave si se proporciona
        custom_key = request.POST.get('license_key', '').strip().upper()
        if custom_key and custom_key != license_obj.license_key:
            if len(custom_key) == 12 and custom_key.isalnum():
                if not License.objects.filter(license_key=custom_key).exclude(pk=pk).exists():
                    license_obj.license_key = custom_key
                else:
                    messages.error(request, 'La clave de licencia ya existe.')
                    return render(request, 'tickets/license_edit.html', {
                        'license': license_obj,
                        'companies': Company.objects.all(),
                        'title': f'Editar Licencia {license_obj.license_key}'
                    })
            else:
                messages.error(request, 'La clave debe tener exactamente 12 caracteres alfanuméricos.')
                return render(request, 'tickets/license_edit.html', {
                    'license': license_obj,
                    'companies': Company.objects.all(),
                    'title': f'Editar Licencia {license_obj.license_key}'
                })
        
        license_obj.save()
        messages.success(request, f'Licencia {license_obj.license_key} actualizada exitosamente.')
        return redirect('license_detail', pk=license_obj.pk)
    
    companies = Company.objects.all()
    context = {
        'license': license_obj,
        'companies': companies,
        'title': f'Editar Licencia {license_obj.license_key}'
    }
    
    return render(request, 'tickets/license_edit.html', context)


@login_required
def license_delete(request, pk):
    """Eliminar licencia"""
    license_obj = get_object_or_404(License, pk=pk)
    
    if request.method == 'POST':
        license_key = license_obj.license_key
        license_obj.delete()
        messages.success(request, f'Licencia {license_key} eliminada exitosamente.')
        return redirect('license_list')
    
    context = {
        'license': license_obj,
        'title': f'Eliminar Licencia {license_obj.license_key}'
    }
    
    return render(request, 'tickets/license_delete.html', context)


def license_public(request, uuid):
    """Vista pública de licencia usando UUID"""
    license_obj = get_object_or_404(License, public_uuid=uuid)
    
    context = {
        'license': license_obj,
        'title': f'Licencia {license_obj.license_key}',
        'is_public_view': True
    }
    
    return render(request, 'tickets/license_public.html', context)


def license_qr_view(request, pk):
    """Vista solo para mostrar el QR de la licencia"""
    license_obj = get_object_or_404(License, pk=pk)
    qr_url = license_obj.get_qr_data()
    
    context = {
        'license': license_obj,
        'qr_url': qr_url,
        'title': f'QR - Licencia {license_obj.license_key}'
    }
    
    return render(request, 'tickets/license_qr.html', context)


def license_api(request, uuid):
    """API para verificar licencia públicamente - devuelve JSON"""
    from django.http import JsonResponse
    
    try:
        license_obj = get_object_or_404(License, public_uuid=uuid)
        
        data = {
            'license_key': license_obj.license_key,
            'company': {
                'name': license_obj.company.name,
                'address': license_obj.company.address if hasattr(license_obj.company, 'address') else None,
            },
            'product': license_obj.product,
            'status': license_obj.status,
            'status_display': license_obj.get_status_display(),
            'start_date': license_obj.start_date.strftime('%Y-%m-%d'),
            'end_date': license_obj.end_date.strftime('%Y-%m-%d'),
            'is_active': license_obj.is_active(),
            'is_expired': license_obj.is_expired(),
            'days_until_expiry': license_obj.days_until_expiry(),
            'verification_timestamp': timezone.now().isoformat(),
            'valid': license_obj.is_active(),
        }
        
        return JsonResponse({
            'success': True,
            'license': data
        })
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': 'Licencia no encontrada'
        }, status=404)


@login_required
def form_ai_analysis_history(request, pk):
    """Muestra el historial de análisis de IA para un formulario"""
    form_obj = get_object_or_404(Form, pk=pk, created_by=request.user)
    
    # Obtener todos los análisis de este formulario
    analyses = form_obj.ai_analyses.all().order_by('-created_at')
    
    context = {
        'form': form_obj,
        'analyses': analyses,
        'title': f'Historial de Análisis - {form_obj.title}'
    }
    
    return render(request, 'tickets/form_ai_analysis_history.html', context)


@login_required
def form_ai_analysis_detail(request, form_pk, analysis_pk):
    """Muestra los detalles de un análisis específico"""
    form_obj = get_object_or_404(Form, pk=form_pk, created_by=request.user)
    analysis = get_object_or_404(form_obj.ai_analyses, pk=analysis_pk)
    
    context = {
        'form': form_obj,
        'analysis': analysis,
        'title': f'Análisis del {analysis.created_at.strftime("%d/%m/%Y %H:%M")}'
    }
    
    return render(request, 'tickets/form_ai_analysis_detail.html', context)


@login_required
def form_question_create(request, form_pk):
    """Crear pregunta para formulario"""
    form_obj = get_object_or_404(Form, pk=form_pk)
    
    # Verificar permisos
    if form_obj.created_by != request.user:
        messages.error(request, 'No tienes permisos para agregar preguntas a este formulario')
        return redirect('form_detail', pk=form_obj.pk)
    
    if request.method == 'POST':
        question = FormQuestion.objects.create(
            form=form_obj,
            question_text=request.POST.get('text'),
            question_type=request.POST.get('question_type'),
            order=int(request.POST.get('order', form_obj.questions.count() + 1)),
            is_required=bool(request.POST.get('is_required'))
        )
        messages.success(request, 'Pregunta agregada exitosamente')
        return redirect('form_detail', pk=form_obj.pk)
    
    return redirect('form_detail', pk=form_obj.pk)


@login_required
def form_question_edit(request, form_pk, question_pk):
    """Editar pregunta de formulario"""
    form_obj = get_object_or_404(Form, pk=form_pk)
    question = get_object_or_404(FormQuestion, pk=question_pk, form=form_obj)
    
    # Verificar permisos
    if form_obj.created_by != request.user:
        messages.error(request, 'No tienes permisos para editar preguntas de este formulario')
        return redirect('form_detail', pk=form_obj.pk)
    
    if request.method == 'POST':
        question.question_text = request.POST.get('text')
        question.question_type = request.POST.get('question_type')
        question.order = int(request.POST.get('order', question.order))
        question.is_required = bool(request.POST.get('is_required'))
        question.save()
        messages.success(request, 'Pregunta actualizada exitosamente')
        return redirect('form_detail', pk=form_obj.pk)
    
    context = {
        'form_obj': form_obj,
        'question': question,
        'page_title': 'Editar Pregunta'
    }
    return render(request, 'tickets/form_question_edit.html', context)


@login_required
def form_question_delete(request, form_pk, question_pk):
    """Eliminar pregunta de formulario"""
    form_obj = get_object_or_404(Form, pk=form_pk)
    question = get_object_or_404(FormQuestion, pk=question_pk, form=form_obj)
    
    # Verificar permisos
    if form_obj.created_by != request.user:
        messages.error(request, 'No tienes permisos para eliminar preguntas de este formulario')
        return redirect('form_detail', pk=form_obj.pk)
    
    if request.method == 'POST':
        question.delete()
        messages.success(request, 'Pregunta eliminada exitosamente')
        return redirect('form_detail', pk=form_obj.pk)
    
    context = {
        'form_obj': form_obj,
        'question': question,
        'page_title': 'Eliminar Pregunta'
    }
    return render(request, 'tickets/form_question_delete.html', context)


@login_required
def form_option_create(request, form_pk, question_pk):
    """Agregar opción a pregunta de selección múltiple"""
    form_obj = get_object_or_404(Form, pk=form_pk)
    question = get_object_or_404(FormQuestion, pk=question_pk, form=form_obj)
    
    # Verificar permisos
    if form_obj.created_by != request.user:
        messages.error(request, 'No tienes permisos para agregar opciones a este formulario')
        return redirect('form_detail', pk=form_obj.pk)
    
    if request.method == 'POST':
        option = FormQuestionOption.objects.create(
            question=question,
            option_text=request.POST.get('text'),
            order=int(request.POST.get('order', question.options.count() + 1)),
            score=int(request.POST.get('score', 0))
        )
        messages.success(request, 'Opción agregada exitosamente')
        return redirect('form_detail', pk=form_obj.pk)
    
    context = {
        'form_obj': form_obj,
        'question': question,
        'page_title': 'Agregar Opción'
    }
    return render(request, 'tickets/form_option_create.html', context)


@login_required
def form_option_update_score(request, form_pk, option_pk):
    """Actualizar puntuación de una opción via AJAX"""
    from django.http import JsonResponse
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        form_obj = get_object_or_404(Form, pk=form_pk, created_by=request.user)
        option = get_object_or_404(FormQuestionOption, pk=option_pk, question__form=form_obj)
        
        # Obtener nueva puntuación
        new_score = request.POST.get('score')
        if new_score is None:
            return JsonResponse({'success': False, 'error': 'Puntuación requerida'})
        
        try:
            new_score = int(new_score)
        except ValueError:
            return JsonResponse({'success': False, 'error': 'La puntuación debe ser un número entero'})
        
        # Actualizar puntuación
        old_score = option.score
        option.score = new_score
        option.save()
        
        return JsonResponse({
            'success': True,
            'message': f'Puntuación actualizada de {old_score} a {new_score}',
            'old_score': old_score,
            'new_score': new_score,
            'option_id': option.pk,
            'option_text': option.option_text
        })
        
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)


@login_required
def form_option_edit(request, form_pk, option_pk):
    """Editar opción completa (texto y puntuación)"""
    form_obj = get_object_or_404(Form, pk=form_pk, created_by=request.user)
    option = get_object_or_404(FormQuestionOption, pk=option_pk, question__form=form_obj)
    
    if request.method == 'POST':
        option.option_text = request.POST.get('text', option.option_text)
        option.score = int(request.POST.get('score', option.score))
        option.save()
        
        messages.success(request, 'Opción actualizada exitosamente')
        return redirect('form_detail', pk=form_obj.pk)
    
    context = {
        'form_obj': form_obj,
        'option': option,
        'question': option.question,
        'page_title': 'Editar Opción'
    }
    return render(request, 'tickets/form_option_edit.html', context)


@login_required
def form_option_delete(request, form_pk, option_pk):
    """Eliminar opción"""
    form_obj = get_object_or_404(Form, pk=form_pk, created_by=request.user)
    option = get_object_or_404(FormQuestionOption, pk=option_pk, question__form=form_obj)
    
    if request.method == 'POST':
        question_id = option.question.id
        option.delete()
        messages.success(request, 'Opción eliminada exitosamente')
        return redirect('form_detail', pk=form_obj.pk)
    
    context = {
        'form_obj': form_obj,
        'option': option,
        'question': option.question,
        'page_title': 'Eliminar Opción'
    }
    return render(request, 'tickets/form_option_delete.html', context)


# ==================== VISTAS DE ALCANCE ====================

def alcance_publico_list(request):
    """Vista pública de alcances - accesible sin autenticación"""
    alcances = Alcance.objects.filter(publico=True).order_by('-creado_en')
    
    context = {
        'alcances': alcances,
        'page_title': 'Alcances Públicos'
    }
    return render(request, 'tickets/alcance_publico_list.html', context)


@login_required
def alcance_list(request):
    """Vista de gestión de alcances - solo usuarios autenticados"""
    alcances = Alcance.objects.all().order_by('-creado_en')
    
    context = {
        'alcances': alcances,
        'page_title': 'Gestión de Alcances'
    }
    return render(request, 'tickets/alcance_list.html', context)


@login_required
def alcance_create(request):
    """Crear nuevo alcance"""
    if request.method == 'POST':
        titulo = request.POST.get('titulo')
        categoria = request.POST.get('categoria')
        descripcion = request.POST.get('descripcion')
        url = request.POST.get('url')
        publico = request.POST.get('publico') == 'on'
        
        alcance = Alcance.objects.create(
            titulo=titulo,
            categoria=categoria,
            descripcion=descripcion,
            url=url,
            publico=publico,
            creado_por=request.user
        )
        
        messages.success(request, 'Alcance creado exitosamente')
        return redirect('alcance_list')
    
    context = {
        'page_title': 'Crear Alcance'
    }
    return render(request, 'tickets/alcance_form.html', context)


@login_required
def alcance_edit(request, pk):
    """Editar alcance existente"""
    alcance = get_object_or_404(Alcance, pk=pk)
    
    if request.method == 'POST':
        alcance.titulo = request.POST.get('titulo')
        alcance.categoria = request.POST.get('categoria')
        alcance.descripcion = request.POST.get('descripcion')
        alcance.url = request.POST.get('url')
        alcance.publico = request.POST.get('publico') == 'on'
        alcance.save()
        
        messages.success(request, 'Alcance actualizado exitosamente')
        return redirect('alcance_list')
    
    context = {
        'alcance': alcance,
        'page_title': 'Editar Alcance'
    }
    return render(request, 'tickets/alcance_form.html', context)


@login_required
def alcance_delete(request, pk):
    """Eliminar alcance"""
    alcance = get_object_or_404(Alcance, pk=pk)
    
    if request.method == 'POST':
        alcance.delete()
        messages.success(request, 'Alcance eliminado exitosamente')
        return redirect('alcance_list')
    
    context = {
        'alcance': alcance,
        'page_title': 'Eliminar Alcance'
    }
    return render(request, 'tickets/alcance_confirm_delete.html', context)


# ==================== VISTAS DE WHATSAPP ====================

@login_required
def whatsapp_dashboard(request):
    """Dashboard principal de WhatsApp"""
    connection, created = WhatsAppConnection.objects.get_or_create(
        user=request.user,
        defaults={'status': 'disconnected'}
    )
    
    keywords = WhatsAppKeyword.objects.filter(connection=connection).order_by('-priority', 'keyword')
    recent_messages = WhatsAppMessage.objects.filter(connection=connection).order_by('-timestamp')[:20]
    
    # Estadísticas
    total_messages = WhatsAppMessage.objects.filter(connection=connection).count()
    auto_replies = WhatsAppMessage.objects.filter(connection=connection, message_type='auto_reply').count()
    total_keywords = keywords.count()
    active_keywords = keywords.filter(is_active=True).count()
    
    context = {
        'connection': connection,
        'keywords': keywords,
        'recent_messages': recent_messages,
        'total_messages': total_messages,
        'auto_replies': auto_replies,
        'total_keywords': total_keywords,
        'active_keywords': active_keywords,
        'page_title': 'WhatsApp - Dashboard'
    }
    return render(request, 'tickets/whatsapp_dashboard.html', context)


@login_required
def whatsapp_keyword_create(request):
    """Crear nueva palabra clave"""
    connection = WhatsAppConnection.objects.get_or_create(user=request.user)[0]
    
    if request.method == 'POST':
        keyword = request.POST.get('keyword')
        response = request.POST.get('response')
        is_exact_match = request.POST.get('is_exact_match') == 'on'
        is_case_sensitive = request.POST.get('is_case_sensitive') == 'on'
        priority = int(request.POST.get('priority', 0))
        
        WhatsAppKeyword.objects.create(
            connection=connection,
            keyword=keyword,
            response=response,
            is_exact_match=is_exact_match,
            is_case_sensitive=is_case_sensitive,
            priority=priority
        )
        
        messages.success(request, f'Palabra clave "{keyword}" creada exitosamente')
        return redirect('whatsapp_dashboard')
    
    context = {
        'connection': connection,
        'page_title': 'Nueva Palabra Clave'
    }
    return render(request, 'tickets/whatsapp_keyword_form.html', context)


@login_required
def whatsapp_keyword_edit(request, pk):
    """Editar palabra clave"""
    keyword = get_object_or_404(WhatsAppKeyword, pk=pk, connection__user=request.user)
    
    if request.method == 'POST':
        keyword.keyword = request.POST.get('keyword')
        keyword.response = request.POST.get('response')
        keyword.is_exact_match = request.POST.get('is_exact_match') == 'on'
        keyword.is_case_sensitive = request.POST.get('is_case_sensitive') == 'on'
        keyword.priority = int(request.POST.get('priority', 0))
        keyword.is_active = request.POST.get('is_active') == 'on'
        keyword.save()
        
        messages.success(request, 'Palabra clave actualizada exitosamente')
        return redirect('whatsapp_dashboard')
    
    context = {
        'keyword': keyword,
        'page_title': 'Editar Palabra Clave'
    }
    return render(request, 'tickets/whatsapp_keyword_form.html', context)


@login_required
def whatsapp_keyword_delete(request, pk):
    """Eliminar palabra clave"""
    keyword = get_object_or_404(WhatsAppKeyword, pk=pk, connection__user=request.user)
    
    if request.method == 'POST':
        keyword.delete()
        messages.success(request, 'Palabra clave eliminada exitosamente')
        return redirect('whatsapp_dashboard')
    
    context = {
        'keyword': keyword,
        'page_title': 'Eliminar Palabra Clave'
    }
    return render(request, 'tickets/whatsapp_keyword_delete.html', context)


@login_required
def whatsapp_connect(request):
    """Iniciar conexión de WhatsApp con servidor Node.js"""
    import requests
    
    connection = WhatsAppConnection.objects.get_or_create(user=request.user)[0]
    
    try:
        # Llamar al servidor Node.js para iniciar conexión
        response = requests.post('http://localhost:3000/connect', 
            json={'user_id': request.user.id},
            timeout=10
        )
        
        if response.status_code == 200:
            data = response.json()
            connection.status = data.get('status', 'connecting')
            connection.qr_code = data.get('qr', '')
            connection.save()
            
            # Manejar diferentes respuestas del servidor
            if data.get('already_connected'):
                messages.success(request, '✅ Ya estás conectado a WhatsApp')
            elif data.get('already_connecting'):
                messages.info(request, '⏳ Conexión en proceso. Escanea el código QR para continuar')
            elif data.get('already_exists'):
                messages.info(request, f"ℹ️ {data.get('message', 'Cliente existente')}")
            elif data.get('qr'):
                messages.success(request, '✅ Escanea el código QR con tu WhatsApp')
            else:
                messages.info(request, f"ℹ️ {data.get('message', 'Conexión iniciada')}")
        else:
            connection.status = 'error'
            connection.save()
            messages.error(request, f'❌ Error al conectar: {response.text}')
            
    except requests.exceptions.ConnectionError:
        connection.status = 'error'
        connection.save()
        messages.error(request, '❌ No se pudo conectar al servidor WhatsApp. Asegúrate de que esté ejecutándose en http://localhost:3000')
    except Exception as e:
        connection.status = 'error'
        connection.save()
        messages.error(request, f'❌ Error inesperado: {str(e)}')
    
    return redirect('whatsapp_dashboard')


@login_required
def whatsapp_disconnect(request):
    """Desconectar WhatsApp del servidor Node.js"""
    import requests
    
    connection = WhatsAppConnection.objects.get_or_create(user=request.user)[0]
    
    try:
        # Llamar al servidor Node.js para desconectar
        response = requests.post('http://localhost:3000/disconnect',
            json={'user_id': request.user.id},
            timeout=10
        )
        
        if response.status_code == 200:
            connection.status = 'disconnected'
            connection.qr_code = None
            connection.phone_number = None
            connection.save()
            messages.success(request, '✅ Desconectado de WhatsApp exitosamente')
        else:
            messages.error(request, f'❌ Error al desconectar: {response.text}')
            
    except requests.exceptions.ConnectionError:
        # Si el servidor no responde, marcar como desconectado de todas formas
        connection.status = 'disconnected'
        connection.qr_code = None
        connection.phone_number = None
        connection.save()
        messages.warning(request, '⚠️ Servidor WhatsApp no disponible. Conexión marcada como desconectada.')
    except Exception as e:
        messages.error(request, f'❌ Error inesperado: {str(e)}')
    
    return redirect('whatsapp_dashboard')


@login_required
def whatsapp_simulate_connection(request):
    """Simular conexión exitosa (solo para demostración)"""
    connection = WhatsAppConnection.objects.get_or_create(user=request.user)[0]
    connection.status = 'connected'
    connection.qr_code = None
    connection.save()
    
    # Crear mensaje de demostración
    WhatsAppMessage.objects.create(
        connection=connection,
        sender_number='+1234567890',
        message_text='Este es un mensaje de demostración del sistema',
        message_type='received'
    )
    
    messages.success(request, '✅ Conexión simulada exitosamente (modo demostración)')
    return redirect('whatsapp_dashboard')


@login_required
def whatsapp_status(request):
    """Obtener estado actual de la conexión (para AJAX polling)"""
    import requests
    from django.http import JsonResponse
    
    connection = WhatsAppConnection.objects.get_or_create(user=request.user)[0]
    
    try:
        # Consultar estado en el servidor Node.js
        response = requests.get(f'http://localhost:3000/status/{request.user.id}', timeout=5)
        
        if response.status_code == 200:
            data = response.json()
            
            # Actualizar estado en la base de datos
            connection.status = data.get('status', 'disconnected')
            connection.qr_code = data.get('qr', '')
            
            # Si está conectado, obtener información del usuario
            if connection.status == 'connected' and not connection.phone_number:
                try:
                    info_response = requests.get(f'http://localhost:3000/info/{request.user.id}', timeout=5)
                    if info_response.status_code == 200:
                        info_data = info_response.json()
                        if info_data.get('status') == 'connected' and info_data.get('info'):
                            connection.phone_number = info_data['info'].get('phone', '')
                except:
                    pass
            
            connection.save()
            
            return JsonResponse({
                'status': connection.status,
                'qr_code': connection.qr_code,
                'phone_number': connection.phone_number,
                'has_client': data.get('has_client', False)
            })
        else:
            return JsonResponse({
                'status': 'error',
                'error': 'Error al consultar servidor'
            }, status=500)
            
    except requests.exceptions.ConnectionError:
        connection.status = 'error'
        connection.save()
        return JsonResponse({
            'status': 'error',
            'error': 'Servidor WhatsApp no disponible'
        }, status=503)
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'error': str(e)
        }, status=500)


@login_required
def whatsapp_messages(request):
    """Ver historial de mensajes"""
    connection = WhatsAppConnection.objects.get_or_create(user=request.user)[0]
    messages_list = WhatsAppMessage.objects.filter(connection=connection).order_by('-timestamp')
    
    # Paginación
    paginator = Paginator(messages_list, 50)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'connection': connection,
        'page_obj': page_obj,
        'page_title': 'Mensajes WhatsApp'
    }
    return render(request, 'tickets/whatsapp_messages.html', context)


# ==================== VISTAS DE IMAGE TO PROMPT ====================

@login_required
def image_prompt_list(request):
    """Lista de todas las imágenes y prompts del usuario"""
    prompts = ImagePrompt.objects.filter(user=request.user).order_by('-created_at')
    
    # Filtros
    search = request.GET.get('search', '')
    if search:
        prompts = prompts.filter(
            Q(title__icontains=search) | 
            Q(generated_prompt__icontains=search) | 
            Q(custom_prompt__icontains=search) |
            Q(tags__icontains=search)
        )
    
    # Paginación
    paginator = Paginator(prompts, 12)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_obj': page_obj,
        'search': search,
        'total_prompts': ImagePrompt.objects.filter(user=request.user).count(),
        'page_title': 'Mis Prompts de Imágenes'
    }
    return render(request, 'tickets/image_prompt_list.html', context)


@login_required
def image_prompt_create(request):
    """Crear un nuevo prompt desde una imagen"""
    if request.method == 'POST':
        title = request.POST.get('title')
        tags = request.POST.get('tags', '')
        is_public = request.POST.get('is_public') == 'on'
        image_file = request.FILES.get('image')
        
        if not title or not image_file:
            messages.error(request, 'Por favor completa todos los campos requeridos')
            return render(request, 'tickets/image_prompt_create.html')
        
        # Crear el objeto ImagePrompt
        image_prompt = ImagePrompt.objects.create(
            user=request.user,
            title=title,
            image=image_file,
            tags=tags,
            is_public=is_public
        )
        
        # Generar prompt con IA
        try:
            from .models import SystemConfiguration
            config = SystemConfiguration.get_config()
            
            if not config.openai_api_key:
                messages.warning(request, 'Imagen guardada, pero no se pudo generar el prompt (API key no configurada)')
                return redirect('image_prompt_detail', pk=image_prompt.pk)
            
            # Usar OpenAI Vision para analizar la imagen
            from openai import OpenAI
            import base64
            
            client = OpenAI(api_key=config.openai_api_key)
            
            # Leer y codificar la imagen
            image_prompt.image.seek(0)
            image_data = base64.b64encode(image_prompt.image.read()).decode('utf-8')
            
            # Llamar a la API con vision
            response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": "Eres un experto en generar prompts detallados para DALL-E, Midjourney y Stable Diffusion. Analiza la imagen y genera un prompt descriptivo que capture todos los detalles visuales, estilo, composición, colores, iluminación y atmósfera. IMPORTANTE: Genera SOLO texto plano, sin usar formato Markdown, sin asteriscos, sin guiones, sin numeración. Todo debe ser texto corrido separado por comas o puntos."
                    },
                    {
                        "role": "user",
                        "content": [
                            {
                                "type": "text",
                                "text": "Analiza esta imagen y genera un prompt detallado en texto plano (sin formato Markdown) que describa el sujeto principal y elementos secundarios, el estilo artístico, los colores dominantes, la iluminación y atmósfera, la composición y perspectiva, y detalles técnicos de calidad. Genera un prompt optimizado para generadores de imágenes por IA, todo en texto corrido sin formato especial."
                            },
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{image_data}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=800
            )
            
            generated_prompt = response.choices[0].message.content.strip()
            tokens_used = response.usage.total_tokens
            
            # Actualizar el objeto
            image_prompt.generated_prompt = generated_prompt
            image_prompt.tokens_used = tokens_used
            image_prompt.save()
            
            messages.success(request, 'Imagen subida y prompt generado exitosamente!')
            return redirect('image_prompt_detail', pk=image_prompt.pk)
            
        except Exception as e:
            messages.warning(request, f'Imagen guardada, pero hubo un error al generar el prompt: {str(e)}')
            return redirect('image_prompt_detail', pk=image_prompt.pk)
    
    context = {
        'page_title': 'Generar Prompt desde Imagen'
    }
    return render(request, 'tickets/image_prompt_create.html', context)


@login_required
def image_prompt_detail(request, pk):
    """Ver detalle de un prompt de imagen"""
    image_prompt = get_object_or_404(ImagePrompt, pk=pk, user=request.user)
    
    context = {
        'image_prompt': image_prompt,
        'page_title': f'Prompt: {image_prompt.title}'
    }
    return render(request, 'tickets/image_prompt_detail.html', context)


@login_required
def image_prompt_edit(request, pk):
    """Editar un prompt de imagen"""
    image_prompt = get_object_or_404(ImagePrompt, pk=pk, user=request.user)
    
    if request.method == 'POST':
        image_prompt.title = request.POST.get('title')
        image_prompt.custom_prompt = request.POST.get('custom_prompt')
        image_prompt.tags = request.POST.get('tags', '')
        image_prompt.is_public = request.POST.get('is_public') == 'on'
        image_prompt.save()
        
        messages.success(request, 'Prompt actualizado exitosamente')
        return redirect('image_prompt_detail', pk=image_prompt.pk)
    
    context = {
        'image_prompt': image_prompt,
        'page_title': f'Editar: {image_prompt.title}'
    }
    return render(request, 'tickets/image_prompt_edit.html', context)


@login_required
def image_prompt_delete(request, pk):
    """Eliminar un prompt de imagen"""
    image_prompt = get_object_or_404(ImagePrompt, pk=pk, user=request.user)
    
    if request.method == 'POST':
        title = image_prompt.title
        image_prompt.delete()
        messages.success(request, f'Prompt "{title}" eliminado exitosamente')
        return redirect('image_prompt_list')
    
    context = {
        'image_prompt': image_prompt,
        'page_title': f'Eliminar: {image_prompt.title}'
    }
    return render(request, 'tickets/image_prompt_delete.html', context)


def public_image_prompts(request):
    """Vista pública de prompts de imágenes"""
    prompts = ImagePrompt.objects.filter(is_public=True).order_by('-created_at')
    
    # Filtros
    search = request.GET.get('search', '')
    if search:
        prompts = prompts.filter(
            Q(title__icontains=search) | 
            Q(generated_prompt__icontains=search) | 
            Q(custom_prompt__icontains=search) |
            Q(tags__icontains=search)
        )
    
    # Paginación
    paginator = Paginator(prompts, 12)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_obj': page_obj,
        'search': search,
        'total_prompts': ImagePrompt.objects.filter(is_public=True).count(),
        'page_title': 'Prompts Públicos'
    }
    return render(request, 'tickets/public_image_prompts.html', context)


def public_image_prompt_detail(request, pk):
    """Vista pública del detalle de un prompt de imagen"""
    image_prompt = get_object_or_404(ImagePrompt, pk=pk, is_public=True)
    
    context = {
        'image_prompt': image_prompt,
        'page_title': f'Prompt: {image_prompt.title}'
    }
    return render(request, 'tickets/public_image_prompt_detail.html', context)


# ==================== GERENTES IA ====================

def get_user_companies(user):
    """Función auxiliar para obtener empresas del usuario"""
    # Si es staff, puede ver todas las empresas
    if user.is_staff:
        return Company.objects.all()
    else:
        # Para usuarios normales, buscar empresas donde tiene proyectos o tickets
        # O simplemente retornar todas (ya que Company no tiene created_by)
        # Por ahora retornamos todas las empresas
        return Company.objects.all()

@login_required
def ai_manager_list(request):
    """Lista de gerentes IA de la empresa del usuario"""
    user_companies = get_user_companies(request.user)
    
    if not user_companies.exists():
        messages.warning(request, 'No tienes una empresa asignada. Por favor crea una empresa primero.')
        return redirect('dashboard')
    
    # Obtener TODOS los gerentes de TODAS las empresas del usuario
    managers = AIManager.objects.filter(
        company__in=user_companies, 
        is_active=True
    ).select_related('company').order_by('company', 'category', 'name')
    
    context = {
        'managers': managers,
        'companies': user_companies,
        'total_companies': user_companies.count(),
        'page_title': 'Gerentes IA'
    }
    return render(request, 'tickets/ai_manager_list.html', context)


@login_required
def ai_manager_create(request):
    """Crear un nuevo gerente IA"""
    user_companies = get_user_companies(request.user)
    
    if not user_companies.exists():
        messages.warning(request, 'No tienes una empresa asignada.')
        return redirect('dashboard')
    
    if request.method == 'POST':
        company_id = request.POST.get('company')
        name = request.POST.get('name')
        category = request.POST.get('category')
        description = request.POST.get('description', '')
        instructions = request.POST.get('instructions')
        telegram_enabled = request.POST.get('telegram_enabled') == 'on'
        telegram_bot_token = request.POST.get('telegram_bot_token', '').strip()
        telegram_chat_id = request.POST.get('telegram_chat_id', '').strip()
        
        if not all([company_id, name, category, instructions]):
            messages.error(request, 'Por favor completa todos los campos requeridos')
        else:
            company = get_object_or_404(Company, pk=company_id)
            AIManager.objects.create(
                company=company,
                name=name,
                category=category,
                description=description,
                instructions=instructions,
                telegram_enabled=telegram_enabled,
                telegram_bot_token=telegram_bot_token,
                telegram_chat_id=telegram_chat_id,
                created_by=request.user
            )
            messages.success(request, f'Gerente IA "{name}" creado exitosamente')
            return redirect('ai_manager_list')
    
    context = {
        'companies': user_companies,
        'page_title': 'Crear Gerente IA'
    }
    return render(request, 'tickets/ai_manager_form.html', context)


@login_required
def ai_manager_detail(request, pk):
    """Detalle de un gerente IA"""
    manager = get_object_or_404(AIManager, pk=pk)
    
    # Verificar que el usuario pertenece a la empresa
    user_companies = get_user_companies(request.user)
    
    if manager.company not in user_companies:
        messages.error(request, 'No tienes permiso para ver este gerente IA')
        return redirect('ai_manager_list')
    
    # Obtener últimas reuniones
    recent_meetings = manager.meetings.select_related('user').order_by('-created_at')[:10]
    
    # Obtener resúmenes
    summaries = manager.summaries.order_by('-created_at')[:5]
    
    # Estadísticas dinámicas (se actualizan en tiempo real)
    meetings = manager.meetings.all()
    total_meetings = meetings.count()
    active_users = meetings.values('user').distinct().count()
    total_summaries = manager.summaries.count()
    total_tokens = meetings.aggregate(total=Sum('tokens_used'))['total'] or 0
    
    stats = {
        'total_meetings': total_meetings,
        'active_users': active_users,
        'total_summaries': total_summaries,
        'total_tokens': total_tokens,
    }
    
    context = {
        'manager': manager,
        'recent_meetings': recent_meetings,
        'summaries': summaries,
        'stats': stats,
        'page_title': manager.name
    }
    return render(request, 'tickets/ai_manager_detail.html', context)


@login_required
def ai_manager_edit(request, pk):
    """Editar un gerente IA"""
    manager = get_object_or_404(AIManager, pk=pk)
    
    # Verificar permisos
    user_companies = get_user_companies(request.user)
    
    if manager.company not in user_companies:
        messages.error(request, 'No tienes permiso para editar este gerente IA')
        return redirect('ai_manager_list')
    
    if request.method == 'POST':
        manager.name = request.POST.get('name')
        manager.category = request.POST.get('category')
        manager.description = request.POST.get('description', '')
        manager.instructions = request.POST.get('instructions')
        manager.is_active = request.POST.get('is_active') == 'on'
        
        # Telegram integration
        manager.telegram_enabled = request.POST.get('telegram_enabled') == 'on'
        manager.telegram_bot_token = request.POST.get('telegram_bot_token', '').strip()
        manager.telegram_chat_id = request.POST.get('telegram_chat_id', '').strip()
        
        manager.save()
        
        messages.success(request, 'Gerente IA actualizado exitosamente')
        return redirect('ai_manager_detail', pk=manager.pk)
    
    context = {
        'manager': manager,
        'page_title': f'Editar: {manager.name}'
    }
    return render(request, 'tickets/ai_manager_edit.html', context)


@login_required
def ai_manager_delete(request, pk):
    """Eliminar un gerente IA"""
    manager = get_object_or_404(AIManager, pk=pk)
    
    # Verificar permisos
    user_companies = get_user_companies(request.user)
    
    if manager.company not in user_companies:
        messages.error(request, 'No tienes permiso para eliminar este gerente IA')
        return redirect('ai_manager_list')
    
    if request.method == 'POST':
        name = manager.name
        manager.delete()
        messages.success(request, f'Gerente IA "{name}" eliminado exitosamente')
        return redirect('ai_manager_list')
    
    # Estadísticas para la página de confirmación
    meetings = manager.meetings.all()
    stats = {
        'total_meetings': meetings.count(),
        'total_summaries': manager.summaries.count(),
        'total_participants': meetings.values('user').distinct().count(),
    }
    
    context = {
        'manager': manager,
        'stats': stats,
        'page_title': f'Eliminar: {manager.name}'
    }
    return render(request, 'tickets/ai_manager_delete.html', context)


@login_required
def ai_manager_meeting_create(request, pk):
    """Crear una reunión con un gerente IA"""
    manager = get_object_or_404(AIManager, pk=pk, is_active=True)
    
    # Verificar permisos
    user_companies = get_user_companies(request.user)
    
    if manager.company not in user_companies:
        messages.error(request, 'No tienes permiso para reunirte con este gerente IA')
        return redirect('ai_manager_list')
    
    if request.method == 'POST':
        title = request.POST.get('title')
        input_type = request.POST.get('input_type', 'text')
        user_input = request.POST.get('user_input')
        audio_file = request.FILES.get('audio_file')
        attachments = request.FILES.getlist('attachments')
        
        # Si está en modo audio y hay archivo pero no texto, transcribir
        if input_type == 'audio' and audio_file and not user_input:
            try:
                from .models import SystemConfiguration
                config = SystemConfiguration.get_config()
                
                if config.openai_api_key:
                    from openai import OpenAI
                    client = OpenAI(api_key=config.openai_api_key)
                    
                    # Transcribir audio con Whisper
                    audio_file.seek(0)
                    transcription = client.audio.transcriptions.create(
                        model="whisper-1",
                        file=audio_file
                    )
                    user_input = transcription.text
            except Exception as e:
                messages.error(request, f'Error al transcribir audio: {str(e)}')
                return render(request, 'tickets/ai_manager_meeting_form.html', {
                    'manager': manager,
                    'page_title': f'Nueva Reunión con {manager.name}'
                })
        
        if not title or not user_input:
            messages.error(request, 'Por favor completa todos los campos requeridos')
            return render(request, 'tickets/ai_manager_meeting_form.html', {
                'manager': manager,
                'page_title': f'Nueva Reunión con {manager.name}'
            })
        
        # Procesar archivos adjuntos para incluir en el contexto de IA
        attachments_context = ""
        if attachments:
            attachments_context = f"\n\nArchivos adjuntos proporcionados ({len(attachments)}):\n"
            for att in attachments:
                file_size_kb = att.size / 1024
                attachments_context += f"- {att.name} ({file_size_kb:.1f} KB, tipo: {att.content_type})\n"
            attachments_context += "\nNOTA: Considera que el usuario ha compartido estos archivos como contexto adicional para su reunión."
        
        # Procesar con IA
        try:
            from .models import SystemConfiguration
            config = SystemConfiguration.get_config()
            
            if not config.openai_api_key:
                messages.warning(request, 'Reunión guardada, pero no se pudo generar respuesta IA (API key no configurada)')
                meeting = AIManagerMeeting.objects.create(
                    ai_manager=manager,
                    user=request.user,
                    title=title,
                    input_type=input_type,
                    user_input=user_input,
                    audio_file=audio_file,
                    ai_response='No disponible',
                    ai_summary='No disponible'
                )
                return redirect('ai_manager_meeting_detail', pk=meeting.pk)
            
            from openai import OpenAI
            client = OpenAI(api_key=config.openai_api_key)
            
            # Obtener historial de reuniones previas del usuario con este gerente
            previous_meetings = AIManagerMeeting.objects.filter(
                ai_manager=manager,
                user=request.user
            ).order_by('-created_at')[:5]
            
            context_history = ""
            if previous_meetings.exists():
                context_history = "\n\nHistorial reciente de reuniones:\n"
                for i, meeting in enumerate(previous_meetings, 1):
                    context_history += f"\n{i}. {meeting.title}\n"
                    context_history += f"   Usuario dijo: {meeting.user_input[:200]}...\n"
                    context_history += f"   Resumen: {meeting.ai_summary[:200]}...\n"
            
            # Llamar a la IA
            response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": f"""{manager.instructions}

Información de la empresa: {manager.company.name}
Tu rol: {manager.name} - {manager.get_category_display()}
Descripción: {manager.description}

{context_history}
{attachments_context}

Tu objetivo es:
1. Escuchar atentamente lo que el usuario comparte
2. Proporcionar un análisis constructivo y empático
3. Identificar áreas de mejora específicas y accionables
4. Dar recomendaciones prácticas basadas en el contexto de la empresa
5. Motivar y apoyar al usuario en su crecimiento

IMPORTANTE: 
- NO uses formato Markdown (nada de **, ##, ###, -, *, etc.)
- Para resaltar texto importante usa HTML: <strong>texto</strong>
- Escribe párrafos normales separados por saltos de línea
- Usa listas simples con números o guiones HTML si es necesario
- Responde de manera profesional pero cercana
- Sé específico en tus recomendaciones"""
                    },
                    {
                        "role": "user",
                        "content": f"Tema: {title}\n\n{user_input}"
                    }
                ],
                max_tokens=1000
            )
            
            ai_response = response.choices[0].message.content.strip()
            tokens_used = response.usage.total_tokens
            
            # Generar resumen corto
            summary_response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": "Resume en 2-3 líneas lo más importante de esta reunión. NO uses Markdown. Usa <strong>texto</strong> para resaltar palabras clave."
                    },
                    {
                        "role": "user",
                        "content": f"Usuario dijo: {user_input}\n\nRespuesta: {ai_response}"
                    }
                ],
                max_tokens=150
            )
            
            ai_summary = summary_response.choices[0].message.content.strip()
            tokens_used += summary_response.usage.total_tokens
            
            # Identificar áreas de mejora
            improvements_response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": "Lista 3-5 áreas de mejora específicas basadas en lo discutido. NO uses Markdown. Usa <strong>texto</strong> para resaltar. Formato: lista simple con números, cada área en una línea."
                    },
                    {
                        "role": "user",
                        "content": f"Contexto: {title}\n\n{user_input}"
                    }
                ],
                max_tokens=200
            )
            
            improvement_areas = improvements_response.choices[0].message.content.strip()
            tokens_used += improvements_response.usage.total_tokens
            
            # Crear la reunión
            meeting = AIManagerMeeting.objects.create(
                ai_manager=manager,
                user=request.user,
                title=title,
                input_type=input_type,
                user_input=user_input,
                audio_file=audio_file,
                ai_response=ai_response,
                ai_summary=ai_summary,
                improvement_areas=improvement_areas,
                tokens_used=tokens_used
            )
            
            # Guardar los archivos adjuntos
            from .models import AIManagerMeetingAttachment
            for attachment_file in attachments:
                AIManagerMeetingAttachment.objects.create(
                    meeting=meeting,
                    file=attachment_file
                )
            
            # Enviar por Telegram si está habilitado
            if manager.telegram_enabled and manager.telegram_bot_token and manager.telegram_chat_id:
                try:
                    from .telegram_utils import send_telegram_message
                    from django.utils import timezone
                    
                    # Formatear mensaje para Telegram (solo lo compartido y respuesta)
                    telegram_message = f"""
📝 *Nueva Reunión con {manager.name}*
🏢 {manager.company.name}
👤 {request.user.get_full_name() or request.user.username}
📅 {timezone.now().strftime('%d/%m/%Y %H:%M')}

━━━━━━━━━━━━━━━━

*📌 TEMA*
{title}

━━━━━━━━━━━━━━━━

*💬 LO QUE COMPARTIÓ*
{user_input}

━━━━━━━━━━━━━━━━

*🤖 RESPUESTA DEL GERENTE IA*
{ai_response}
"""
                    
                    send_telegram_message(
                        bot_token=manager.telegram_bot_token,
                        chat_id=manager.telegram_chat_id,
                        message=telegram_message,
                        parse_mode='Markdown'
                    )
                    
                    messages.success(request, 'Reunión registrada, análisis generado y enviado por Telegram exitosamente')
                except Exception as telegram_error:
                    messages.success(request, f'Reunión registrada exitosamente (Telegram: {str(telegram_error)})')
            else:
                messages.success(request, 'Reunión registrada y análisis generado exitosamente')
            
            return redirect('ai_manager_meeting_detail', pk=meeting.pk)
            
        except Exception as e:
            messages.error(request, f'Error al procesar la reunión: {str(e)}')
            return render(request, 'tickets/ai_manager_meeting_form.html', {
                'manager': manager,
                'page_title': f'Nueva Reunión con {manager.name}'
            })
    
    context = {
        'manager': manager,
        'page_title': f'Nueva Reunión con {manager.name}'
    }
    return render(request, 'tickets/ai_manager_meeting_form.html', context)


@login_required
def ai_manager_meetings(request, pk):
    """Lista de reuniones de un gerente IA"""
    manager = get_object_or_404(AIManager, pk=pk)
    
    # Verificar permisos
    user_companies = get_user_companies(request.user)
    
    if manager.company not in user_companies:
        messages.error(request, 'No tienes permiso para ver estas reuniones')
        return redirect('ai_manager_list')
    
    # Si es admin/gerente, ver todas. Si no, solo las suyas
    if request.user.is_staff or request.user == manager.created_by:
        meetings = manager.meetings.select_related('user').order_by('-created_at')
    else:
        meetings = manager.meetings.filter(user=request.user).order_by('-created_at')
    
    # Filtros
    search = request.GET.get('search', '')
    input_type = request.GET.get('input_type', '')
    user_filter = request.GET.get('user', '')
    
    if search:
        meetings = meetings.filter(
            Q(title__icontains=search) | 
            Q(user_input__icontains=search) |
            Q(ai_summary__icontains=search)
        )
    
    if input_type:
        meetings = meetings.filter(input_type=input_type)
    
    if user_filter:
        meetings = meetings.filter(user_id=user_filter)
    
    # Estadísticas dinámicas
    all_meetings = manager.meetings.all()
    stats = {
        'total_meetings': all_meetings.count(),
        'text_meetings': all_meetings.filter(input_type='text').count(),
        'audio_meetings': all_meetings.filter(input_type='audio').count(),
        'unique_users': all_meetings.values('user').distinct().count(),
    }
    
    # Usuarios únicos para el filtro
    users = User.objects.filter(
        id__in=manager.meetings.values_list('user_id', flat=True).distinct()
    ).order_by('first_name', 'last_name')
    
    # Paginación
    paginator = Paginator(meetings, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'manager': manager,
        'meetings': page_obj,
        'page_obj': page_obj,
        'is_paginated': page_obj.has_other_pages(),
        'stats': stats,
        'users': users,
        'page_title': f'Reuniones - {manager.name}'
    }
    return render(request, 'tickets/ai_manager_meetings.html', context)


@login_required
def ai_manager_meeting_detail(request, pk):
    """Detalle de una reunión"""
    meeting = get_object_or_404(AIManagerMeeting, pk=pk)
    
    # Verificar permisos
    if meeting.user != request.user and not request.user.is_staff:
        messages.error(request, 'No tienes permiso para ver esta reunión')
        return redirect('ai_manager_list')
    
    context = {
        'meeting': meeting,
        'page_title': meeting.title
    }
    return render(request, 'tickets/ai_manager_meeting_detail.html', context)


@login_required
def ai_manager_generate_summary(request, pk):
    """Generar resumen general del gerente IA"""
    manager = get_object_or_404(AIManager, pk=pk)
    
    # Verificar permisos (solo admin o creador)
    if not request.user.is_staff and request.user != manager.created_by:
        messages.error(request, 'No tienes permiso para generar resúmenes')
        return redirect('ai_manager_detail', pk=pk)
    
    if request.method == 'POST':
        period_start = request.POST.get('period_start')
        period_end = request.POST.get('period_end')
        
        if not period_start or not period_end:
            messages.error(request, 'Por favor selecciona las fechas')
            return redirect('ai_manager_detail', pk=pk)
        
        try:
            from datetime import datetime
            start_date = datetime.strptime(period_start, '%Y-%m-%d').date()
            end_date = datetime.strptime(period_end, '%Y-%m-%d').date()
            
            # Obtener reuniones del período
            meetings = manager.meetings.filter(
                created_at__date__gte=start_date,
                created_at__date__lte=end_date
            ).select_related('user')
            
            if not meetings.exists():
                messages.warning(request, 'No hay reuniones en este período')
                return redirect('ai_manager_detail', pk=pk)
            
            # Generar resumen con IA
            from .models import SystemConfiguration
            config = SystemConfiguration.get_config()
            
            if not config.openai_api_key:
                messages.warning(request, 'No se puede generar resumen (API key no configurada)')
                return redirect('ai_manager_detail', pk=pk)
            
            from openai import OpenAI
            client = OpenAI(api_key=config.openai_api_key)
            
            # Preparar contexto de todas las reuniones
            meetings_context = ""
            for i, meeting in enumerate(meetings, 1):
                meetings_context += f"\n\n=== Reunión {i}: {meeting.title} ===\n"
                meetings_context += f"Usuario: {meeting.user.username}\n"
                meetings_context += f"Fecha: {meeting.created_at.strftime('%d/%m/%Y')}\n"
                meetings_context += f"Entrada: {meeting.user_input[:500]}...\n"
                meetings_context += f"Resumen: {meeting.ai_summary}\n"
                meetings_context += f"Áreas de mejora: {meeting.improvement_areas}\n"
            
            # Generar resumen
            response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": f"""Eres {manager.name}, {manager.get_category_display()} de {manager.company.name}.

Analiza todas las reuniones del período y genera un resumen ejecutivo completo que incluya:
1. Resumen general de lo discutido
2. Patrones y tendencias identificadas
3. Logros y progreso del equipo
4. Desafíos principales
5. Recomendaciones estratégicas para la empresa

IMPORTANTE:
- NO uses formato Markdown (nada de **, ##, ###, -, *, etc.)
- Para resaltar texto importante usa HTML: <strong>texto</strong>
- Escribe párrafos normales separados por saltos de línea doble
- Usa números simples (1., 2., 3.) para las listas
- Sé específico, profesional y orientado a la acción"""
                    },
                    {
                        "role": "user",
                        "content": f"""Período: {start_date.strftime('%d/%m/%Y')} - {end_date.strftime('%d/%m/%Y')}
Total de reuniones: {meetings.count()}
Participantes únicos: {meetings.values('user').distinct().count()}

{meetings_context}

Por favor genera el resumen ejecutivo completo."""
                    }
                ],
                max_tokens=2000
            )
            
            summary_text = response.choices[0].message.content.strip()
            tokens_used = response.usage.total_tokens
            
            # Generar insights clave
            insights_response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": "Extrae 5-7 insights clave más importantes del resumen. NO uses Markdown. Usa <strong>texto</strong> para resaltar conceptos clave. Formato: lista numerada simple (1., 2., 3., etc.)."
                    },
                    {
                        "role": "user",
                        "content": summary_text
                    }
                ],
                max_tokens=500
            )
            
            key_insights = insights_response.choices[0].message.content.strip()
            tokens_used += insights_response.usage.total_tokens
            
            # Generar recomendaciones
            recommendations_response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": "Genera 5-7 recomendaciones estratégicas específicas y accionables para la empresa. NO uses Markdown. Usa <strong>texto</strong> para resaltar acciones clave. Formato: lista numerada simple (1., 2., 3., etc.)."
                    },
                    {
                        "role": "user",
                        "content": summary_text
                    }
                ],
                max_tokens=500
            )
            
            recommendations = recommendations_response.choices[0].message.content.strip()
            tokens_used += recommendations_response.usage.total_tokens
            
            # Crear el resumen
            summary = AIManagerSummary.objects.create(
                ai_manager=manager,
                period_start=start_date,
                period_end=end_date,
                summary_text=summary_text,
                key_insights=key_insights,
                recommendations=recommendations,
                total_meetings=meetings.count(),
                participants_count=meetings.values('user').distinct().count(),
                tokens_used=tokens_used
            )
            
            # Enviar por Telegram si está habilitado
            if manager.telegram_enabled and manager.telegram_chat_id and manager.telegram_bot_token:
                try:
                    from .telegram_utils import send_telegram_message
                    
                    # Formatear mensaje para Telegram
                    telegram_message = f"""
📊 *Resumen Ejecutivo - {manager.name}*
🏢 {manager.company.name}

📅 *Período:* {start_date.strftime('%d/%m/%Y')} - {end_date.strftime('%d/%m/%Y')}
👥 *Participantes:* {summary.participants_count}
📝 *Reuniones:* {summary.total_meetings}

━━━━━━━━━━━━━━━━

*📝 RESUMEN*
{summary_text}

━━━━━━━━━━━━━━━━

*💡 INSIGHTS CLAVE*
{key_insights}

━━━━━━━━━━━━━━━━

*🎯 RECOMENDACIONES*
{recommendations}
"""
                    
                    success = send_telegram_message(
                        bot_token=manager.telegram_bot_token,
                        chat_id=manager.telegram_chat_id,
                        message=telegram_message,
                        parse_mode='Markdown'
                    )
                    
                    if success:
                        messages.success(request, 'Resumen ejecutivo generado y enviado por Telegram exitosamente')
                    else:
                        messages.warning(request, 'Resumen generado pero no se pudo enviar por Telegram')
                    
                except Exception as telegram_error:
                    messages.warning(request, f'Resumen generado pero error al enviar por Telegram: {str(telegram_error)}')
            else:
                messages.success(request, 'Resumen ejecutivo generado exitosamente')
            
            return redirect('ai_manager_detail', pk=pk)
            
        except Exception as e:
            messages.error(request, f'Error al generar resumen: {str(e)}')
            return redirect('ai_manager_detail', pk=pk)
    
    # GET: Mostrar formulario
    from datetime import date
    meetings = manager.meetings.all()
    stats = {
        'total_meetings': meetings.count(),
        'active_users': meetings.values('user').distinct().count(),
        'total_summaries': manager.summaries.count(),
    }
    
    context = {
        'manager': manager,
        'stats': stats,
        'today': date.today().isoformat(),
        'page_title': f'Generar Resumen - {manager.name}'
    }
    return render(request, 'tickets/ai_manager_summary_form.html', context)


@login_required
def ai_manager_summary_detail(request, pk):
    """Ver detalle de un resumen ejecutivo"""
    summary = get_object_or_404(AIManagerSummary, pk=pk)
    
    # Verificar permisos
    user_companies = get_user_companies(request.user)
    
    if summary.ai_manager.company not in user_companies:
        messages.error(request, 'No tienes permiso para ver este resumen')
        return redirect('ai_manager_list')
    
    context = {
        'summary': summary,
        'page_title': f'Resumen Ejecutivo - {summary.ai_manager.name}'
    }
    return render(request, 'tickets/ai_manager_summary_detail.html', context)


# ==================== COMPANY AI DASHBOARD ====================

def clean_markdown_to_html(text):
    """Convierte Markdown a HTML y limpia formato"""
    import re
    
    # Reemplazar **texto** con <strong>texto</strong>
    text = re.sub(r'\*\*(.*?)\*\*', r'<strong>\1</strong>', text)
    
    # Reemplazar *texto* con <em>texto</em>
    text = re.sub(r'\*(.*?)\*', r'<em>\1</em>', text)
    
    # Reemplazar ### título con <strong>título</strong>
    text = re.sub(r'###\s+(.*?)(\n|$)', r'<strong>\1</strong><br><br>', text)
    text = re.sub(r'##\s+(.*?)(\n|$)', r'<strong>\1</strong><br><br>', text)
    text = re.sub(r'#\s+(.*?)(\n|$)', r'<strong>\1</strong><br><br>', text)
    
    # Reemplazar saltos de línea dobles con <br><br>
    text = re.sub(r'\n\n+', '<br><br>', text)
    
    # Reemplazar saltos de línea simples con <br>
    text = re.sub(r'\n', '<br>', text)
    
    # Limpiar listas con - o *
    text = re.sub(r'<br>\s*[-*]\s+', '<br>• ', text)
    
    return text.strip()


@login_required
def company_ai_dashboard_list(request):
    """Lista de empresas con gerentes IA"""
    user_companies = get_user_companies(request.user)
    
    # Obtener estadísticas de cada empresa
    companies_data = []
    for company in user_companies:
        managers = AIManager.objects.filter(company=company)
        meetings = AIManagerMeeting.objects.filter(ai_manager__company=company)
        
        # Solo incluir empresas que tengan al menos un gerente O al menos una reunión
        total_managers = managers.count()
        total_meetings = meetings.count()
        
        if total_managers > 0 or total_meetings > 0:
            companies_data.append({
                'company': company,
                'total_managers': total_managers,
                'active_managers': managers.filter(is_active=True).count(),
                'total_meetings': total_meetings,
                'total_participants': meetings.values('user').distinct().count(),
                'total_summaries': CompanyAISummary.objects.filter(company=company).count(),
            })
    
    context = {
        'companies_data': companies_data,
        'page_title': 'Dashboard Empresarial IA'
    }
    return render(request, 'tickets/company_ai_dashboard_list.html', context)


@login_required
def company_ai_dashboard_detail(request, pk):
    """Dashboard detallado de una empresa con sus gerentes IA"""
    company = get_object_or_404(Company, pk=pk)
    
    # Verificar permisos
    user_companies = get_user_companies(request.user)
    
    if company not in user_companies:
        messages.error(request, 'No tienes permiso para ver este dashboard')
        return redirect('company_ai_dashboard_list')
    
    # Obtener todos los gerentes de la empresa
    managers = AIManager.objects.filter(company=company).prefetch_related('meetings')
    
    # Obtener todas las reuniones
    all_meetings = AIManagerMeeting.objects.filter(ai_manager__company=company)
    
    # Estadísticas generales
    total_meetings = all_meetings.count()
    total_participants = all_meetings.values('user').distinct().count()
    total_tokens = all_meetings.aggregate(total=Sum('tokens_used'))['total'] or 0
    
    # Estadísticas por gerente
    managers_stats = []
    for manager in managers:
        manager_meetings = all_meetings.filter(ai_manager=manager)
        managers_stats.append({
            'manager': manager,
            'total_meetings': manager_meetings.count(),
            'active_users': manager_meetings.values('user').distinct().count(),
            'total_tokens': manager_meetings.aggregate(total=Sum('tokens_used'))['total'] or 0,
        })
    
    # Usuarios participantes con conteo de reuniones
    from django.db.models import Count
    participants = User.objects.filter(
        id__in=all_meetings.values_list('user_id', flat=True).distinct()
    ).annotate(
        meeting_count=Count('ai_manager_meetings', filter=Q(ai_manager_meetings__ai_manager__company=company))
    ).order_by('first_name', 'last_name')
    
    # Resúmenes empresariales
    company_summaries = CompanyAISummary.objects.filter(company=company).order_by('-created_at')[:5]
    
    # Reuniones recientes
    recent_meetings = all_meetings.select_related('ai_manager', 'user').order_by('-created_at')[:10]
    
    context = {
        'company': company,
        'managers': managers,
        'managers_stats': managers_stats,
        'participants': participants,
        'company_summaries': company_summaries,
        'recent_meetings': recent_meetings,
        'total_meetings': total_meetings,
        'total_participants': total_participants,
        'total_tokens': total_tokens,
        'page_title': f'Dashboard - {company.name}'
    }
    return render(request, 'tickets/company_ai_dashboard_detail.html', context)


@login_required
def company_ai_generate_summary(request, pk):
    """Generar resumen empresarial general"""
    
    company = get_object_or_404(Company, pk=pk)
    
    # Verificar permisos (solo admin o staff)
    user_companies = get_user_companies(request.user)
    
    if company not in user_companies:
        messages.error(request, 'No tienes permiso para generar resúmenes')
        return redirect('company_ai_dashboard_list')
    
    if not request.user.is_staff:
        messages.error(request, 'Solo administradores pueden generar resúmenes empresariales')
        return redirect('company_ai_dashboard_detail', pk=pk)
    
    if request.method == 'POST':
        period_start = request.POST.get('period_start')
        period_end = request.POST.get('period_end')
        
        if not period_start or not period_end:
            messages.error(request, 'Por favor selecciona las fechas')
            return redirect('company_ai_dashboard_detail', pk=pk)
        
        try:
            from datetime import datetime
            start_date = datetime.strptime(period_start, '%Y-%m-%d').date()
            end_date = datetime.strptime(period_end, '%Y-%m-%d').date()
            
            # Obtener todos los gerentes y reuniones del período
            managers = AIManager.objects.filter(company=company)
            meetings = AIManagerMeeting.objects.filter(
                ai_manager__company=company,
                created_at__date__gte=start_date,
                created_at__date__lte=end_date
            ).select_related('ai_manager', 'user')
            
            if not meetings.exists():
                messages.warning(request, 'No hay reuniones en este período')
                return redirect('company_ai_dashboard_detail', pk=pk)
            
            # Generar resumen con IA
            from .models import SystemConfiguration
            config = SystemConfiguration.get_config()
            
            if not config.openai_api_key:
                messages.warning(request, 'No se puede generar resumen (API key no configurada)')
                return redirect('company_ai_dashboard_detail', pk=pk)
            
            from openai import OpenAI
            client = OpenAI(api_key=config.openai_api_key)
            
            # Preparar contexto agrupado por gerente
            managers_context = ""
            for manager in managers:
                manager_meetings = meetings.filter(ai_manager=manager)
                if manager_meetings.exists():
                    managers_context += f"\n\n{'='*60}\n"
                    managers_context += f"GERENTE: {manager.name} ({manager.get_category_display()})\n"
                    managers_context += f"Total de reuniones: {manager_meetings.count()}\n"
                    managers_context += f"{'='*60}\n"
                    
                    for i, meeting in enumerate(manager_meetings[:10], 1):  # Max 10 por gerente
                        managers_context += f"\nReunión {i}: {meeting.title}\n"
                        managers_context += f"Usuario: {meeting.user.get_full_name() or meeting.user.username}\n"
                        managers_context += f"Fecha: {meeting.created_at.strftime('%d/%m/%Y')}\n"
                        managers_context += f"Resumen: {meeting.ai_summary[:300]}...\n"
            
            # Generar resumen ejecutivo
            response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": f"""Eres un analista ejecutivo de {company.name}.

Analiza toda la información de los diferentes gerentes IA y genera un resumen ejecutivo empresarial completo.

{f"OBJETIVOS EMPRESARIALES A CONSIDERAR:{chr(10)}{company.business_objectives}{chr(10)}{chr(10)}" if company.business_objectives else ""}Incluye:
1. Visión general del desempeño de la empresa
2. Análisis transversal de todas las áreas
3. Patrones y tendencias identificadas a nivel empresa
4. Sinergias y áreas de oportunidad entre departamentos
{f"5. Evaluación del progreso hacia los objetivos empresariales definidos" if company.business_objectives else ""}

IMPORTANTE SOBRE EL FORMATO:
- NO uses formato Markdown (nada de **, ##, ###, -, *, etc.)
- Para resaltar texto importante usa HTML: <strong>texto</strong>
- Para saltos de línea usa <br> o <br><br> para doble espacio
- Escribe en párrafos claros separados con <br><br>
- Usa listas con números seguidos de punto y <br> entre items
- Enfoque estratégico para la dirección"""
                    },
                    {
                        "role": "user",
                        "content": f"""Período: {start_date.strftime('%d/%m/%Y')} - {end_date.strftime('%d/%m/%Y')}
Empresa: {company.name}
Total de gerentes activos: {managers.filter(is_active=True).count()}
Total de reuniones: {meetings.count()}
Participantes únicos: {meetings.values('user').distinct().count()}

{managers_context}

Genera el resumen ejecutivo empresarial."""
                    }
                ],
                max_tokens=2500
            )
            
            executive_summary = response.choices[0].message.content.strip()
            executive_summary = clean_markdown_to_html(executive_summary)
            tokens_used = response.usage.total_tokens
            
            # Generar métricas clave
            metrics_response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": f"""Extrae 5-7 métricas y KPIs clave del resumen.

{f"OBJETIVOS EMPRESARIALES:{chr(10)}{company.business_objectives}{chr(10)}{chr(10)}Prioriza métricas relacionadas con estos objetivos.{chr(10)}{chr(10)}" if company.business_objectives else ""}FORMATO:
- NO uses formato Markdown (nada de **, ##, ###, -, *, etc.)
- Usa <strong>texto</strong> para resaltar números y métricas importantes
- Usa <br> para separar cada métrica
- Lista numerada simple: 1. Métrica<br>2. Métrica<br>etc.
- Cada métrica debe tener el valor destacado con <strong>"""
                    },
                    {
                        "role": "user",
                        "content": executive_summary
                    }
                ],
                max_tokens=500
            )
            
            key_metrics = metrics_response.choices[0].message.content.strip()
            key_metrics = clean_markdown_to_html(key_metrics)
            tokens_used += metrics_response.usage.total_tokens
            
            # Generar destacados por departamento
            highlights_response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": """Resume los logros más importantes de cada departamento/gerente.

FORMATO:
- NO uses formato Markdown (nada de **, ##, ###, -, *, etc.)
- Usa <strong>texto</strong> para resaltar logros importantes
- Usa <br><br> para separar departamentos
- Usa <br> para separar logros dentro de un departamento
- Organiza por departamento con el nombre del departamento en <strong>Departamento:</strong>"""
                    },
                    {
                        "role": "user",
                        "content": managers_context
                    }
                ],
                max_tokens=800
            )
            
            department_highlights = highlights_response.choices[0].message.content.strip()
            department_highlights = clean_markdown_to_html(department_highlights)
            tokens_used += highlights_response.usage.total_tokens
            
            # Generar desafíos
            challenges_response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": """Identifica los 5-7 desafíos más importantes que enfrenta la empresa.

FORMATO:
- NO uses formato Markdown (nada de **, ##, ###, -, *, etc.)
- Usa <strong>texto</strong> para resaltar desafíos críticos
- Usa <br> para separar cada desafío
- Lista numerada simple: 1. Desafío<br>2. Desafío<br>etc.
- Cada desafío debe ser claro y accionable"""
                    },
                    {
                        "role": "user",
                        "content": executive_summary
                    }
                ],
                max_tokens=600
            )
            
            challenges = challenges_response.choices[0].message.content.strip()
            challenges = clean_markdown_to_html(challenges)
            tokens_used += challenges_response.usage.total_tokens
            
            # Generar recomendaciones estratégicas
            recommendations_response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": f"""Genera 7-10 recomendaciones estratégicas para la dirección.

{f"OBJETIVOS EMPRESARIALES:{chr(10)}{company.business_objectives}{chr(10)}{chr(10)}Las recomendaciones deben estar alineadas con estos objetivos.{chr(10)}{chr(10)}" if company.business_objectives else ""}FORMATO:
- NO uses formato Markdown (nada de **, ##, ###, -, *, etc.)
- Usa <strong>texto</strong> para resaltar acciones clave y prioridades
- Usa <br> para separar cada recomendación
- Lista numerada con prioridades: 1. [ALTA] Recomendación<br>2. [MEDIA] Recomendación<br>etc.
- Cada recomendación debe ser específica y accionable"""
                    },
                    {
                        "role": "user",
                        "content": executive_summary
                    }
                ],
                max_tokens=800
            )
            
            strategic_recommendations = recommendations_response.choices[0].message.content.strip()
            strategic_recommendations = clean_markdown_to_html(strategic_recommendations)
            tokens_used += recommendations_response.usage.total_tokens
            
            # Crear el resumen empresarial
            summary = CompanyAISummary.objects.create(
                company=company,
                period_start=start_date,
                period_end=end_date,
                executive_summary=executive_summary,
                key_metrics=key_metrics,
                department_highlights=department_highlights,
                challenges=challenges,
                strategic_recommendations=strategic_recommendations,
                total_managers=managers.count(),
                total_meetings=meetings.count(),
                total_participants=meetings.values('user').distinct().count(),
                tokens_used=tokens_used,
                generated_by=request.user
            )
            
            messages.success(request, 'Resumen empresarial generado exitosamente')
            return redirect('company_ai_summary_detail', pk=summary.pk)
            
        except Exception as e:
            messages.error(request, f'Error al generar resumen: {str(e)}')
            return redirect('company_ai_dashboard_detail', pk=pk)
    
    # GET: Mostrar formulario
    from datetime import date
    managers = AIManager.objects.filter(company=company)
    meetings = AIManagerMeeting.objects.filter(ai_manager__company=company)
    
    stats = {
        'total_managers': managers.count(),
        'total_meetings': meetings.count(),
        'total_participants': meetings.values('user').distinct().count(),
        'total_summaries': CompanyAISummary.objects.filter(company=company).count(),
    }
    
    context = {
        'company': company,
        'stats': stats,
        'today': date.today().isoformat(),
        'page_title': f'Generar Resumen Empresarial - {company.name}'
    }
    return render(request, 'tickets/company_ai_summary_form.html', context)


@login_required
def company_ai_summary_detail(request, pk):
    """Ver detalle de un resumen empresarial"""
    summary = get_object_or_404(CompanyAISummary, pk=pk)
    
    # Verificar permisos
    user_companies = get_user_companies(request.user)
    
    if summary.company not in user_companies:
        messages.error(request, 'No tienes permiso para ver este resumen')
        return redirect('company_ai_dashboard_list')
    
    context = {
        'summary': summary,
        'page_title': f'Resumen Empresarial - {summary.company.name}'
    }
    return render(request, 'tickets/company_ai_summary_detail.html', context)


# =============================================================================
# VISTAS PARA DASHBOARD DE DESEMPEÑO DE USUARIOS IA
# =============================================================================

@login_required
def user_ai_performance_dashboard(request):
    """Dashboard principal de desempeño de usuarios con IA"""
    user_companies = get_user_companies(request.user)
    
    # Obtener usuarios con reuniones de IA
    from django.db.models import Count, Avg, Max
    users_with_meetings = User.objects.filter(
        ai_manager_meetings__ai_manager__company__in=user_companies
    ).annotate(
        meeting_count=Count('ai_manager_meetings'),
        last_meeting=Max('ai_manager_meetings__created_at'),
        avg_score=Avg('ai_performance_evaluations__overall_score')
    ).filter(meeting_count__gt=0).distinct().order_by('-meeting_count')
    
    # Preparar datos
    users_data = []
    for user in users_with_meetings:
        latest_evaluation = user.ai_performance_evaluations.order_by('-evaluation_date').first()
        
        users_data.append({
            'user': user,
            'meeting_count': user.meeting_count,
            'last_meeting': user.last_meeting,
            'avg_score': user.avg_score or 0,
            'latest_evaluation': latest_evaluation,
            'has_evaluation': latest_evaluation is not None
        })
    
    context = {
        'users_data': users_data,
        'total_users': len(users_data),
        'page_title': 'Dashboard de Desempeño de Usuarios IA'
    }
    return render(request, 'tickets/user_ai_performance_dashboard.html', context)


@login_required
def user_ai_performance_detail(request, user_id):
    """Detalle de desempeño de un usuario específico"""
    user = get_object_or_404(User, pk=user_id)
    user_companies = get_user_companies(request.user)
    
    # Verificar que el usuario tiene reuniones en empresas accesibles
    user_meetings = AIManagerMeeting.objects.filter(
        user=user,
        ai_manager__company__in=user_companies
    )
    
    if not user_meetings.exists():
        messages.error(request, 'Este usuario no tiene reuniones registradas')
        return redirect('user_ai_performance_dashboard')
    
    # Obtener evaluaciones
    evaluations = UserAIPerformanceEvaluation.objects.filter(user=user).order_by('-evaluation_date')
    
    # Estadísticas
    from django.db.models import Avg, Count
    stats = {
        'total_meetings': user_meetings.count(),
        'total_evaluations': evaluations.count(),
        'avg_score': evaluations.aggregate(Avg('overall_score'))['overall_score__avg'] or 0,
        'latest_score': evaluations.first().overall_score if evaluations.exists() else 0,
    }
    
    # Datos para gráfico de progreso
    chart_data = {
        'labels': [eval.evaluation_date.strftime('%d/%m/%Y') for eval in evaluations[:10][::-1]],
        'overall_scores': [eval.overall_score for eval in evaluations[:10][::-1]],
        'productivity_scores': [eval.productivity_score for eval in evaluations[:10][::-1]],
        'communication_scores': [eval.communication_score for eval in evaluations[:10][::-1]],
    }
    
    context = {
        'evaluated_user': user,
        'evaluations': evaluations,
        'stats': stats,
        'chart_data': chart_data,
        'page_title': f'Desempeño de {user.get_full_name()}'
    }
    return render(request, 'tickets/user_ai_performance_detail.html', context)


@login_required
def user_ai_performance_generate(request, user_id):
    """Generar nueva evaluación de desempeño para un usuario"""
    user = get_object_or_404(User, pk=user_id)
    user_companies = get_user_companies(request.user)
    
    if request.method == 'POST':
        period_start = request.POST.get('period_start')
        period_end = request.POST.get('period_end')
        
        if not period_start or not period_end:
            messages.error(request, 'Por favor selecciona las fechas del período')
            return redirect('user_ai_performance_detail', user_id=user_id)
        
        try:
            from datetime import datetime
            start_date = datetime.strptime(period_start, '%Y-%m-%d').date()
            end_date = datetime.strptime(period_end, '%Y-%m-%d').date()
            
            # Obtener reuniones del período
            meetings = AIManagerMeeting.objects.filter(
                user=user,
                ai_manager__company__in=user_companies,
                created_at__date__gte=start_date,
                created_at__date__lte=end_date
            ).select_related('ai_manager')
            
            if not meetings.exists():
                messages.warning(request, 'No hay reuniones en este período')
                return redirect('user_ai_performance_detail', user_id=user_id)
            
            # Generar evaluación con IA
            from .models import SystemConfiguration
            config = SystemConfiguration.get_config()
            
            if not config.openai_api_key:
                messages.error(request, 'No hay API key configurada')
                return redirect('user_ai_performance_detail', user_id=user_id)
            
            from openai import OpenAI
            client = OpenAI(api_key=config.openai_api_key)
            
            # Preparar contexto de reuniones
            meetings_context = ""
            for i, meeting in enumerate(meetings[:20], 1):  # Limitar a 20 reuniones
                meetings_context += f"\nReunión {i} - {meeting.created_at.strftime('%d/%m/%Y')}:\n"
                meetings_context += f"Gerente: {meeting.ai_manager.name}\n"
                meetings_context += f"Tema: {meeting.title}\n"
                meetings_context += f"Input del usuario: {meeting.user_input[:300]}...\n"
                meetings_context += f"Resumen: {meeting.ai_summary[:200]}...\n"
                meetings_context += f"Áreas de mejora: {meeting.improvement_areas[:150]}...\n\n"
            
            # Llamada 1: Evaluación general y puntuaciones
            evaluation_response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": f"""Eres un evaluador de desempeño experto. Analiza las reuniones del usuario y genera una evaluación completa.

Usuario: {user.get_full_name()}
Período: {start_date} a {end_date}
Total de reuniones: {meetings.count()}

{meetings_context}

Genera una evaluación con:
1. Puntuación general (1-100)
2. Productividad (1-100)
3. Comunicación (1-100)
4. Logro de objetivos (1-100)
5. Consistencia (1-100)

FORMATO DE RESPUESTA (EXACTAMENTE ASÍ):
OVERALL: [número]
PRODUCTIVITY: [número]
COMMUNICATION: [número]
GOALS: [número]
CONSISTENCY: [número]

Luego agrega un análisis de 2-3 párrafos explicando las puntuaciones. NO uses Markdown, usa <strong>texto</strong> para resaltar."""
                    }
                ],
                max_tokens=600
            )
            
            eval_text = evaluation_response.choices[0].message.content.strip()
            tokens_used = evaluation_response.usage.total_tokens
            
            # Parsear puntuaciones
            import re
            overall_match = re.search(r'OVERALL:\s*(\d+)', eval_text)
            productivity_match = re.search(r'PRODUCTIVITY:\s*(\d+)', eval_text)
            communication_match = re.search(r'COMMUNICATION:\s*(\d+)', eval_text)
            goals_match = re.search(r'GOALS:\s*(\d+)', eval_text)
            consistency_match = re.search(r'CONSISTENCY:\s*(\d+)', eval_text)
            
            overall_score = int(overall_match.group(1)) if overall_match else 75
            productivity_score = int(productivity_match.group(1)) if productivity_match else 75
            communication_score = int(communication_match.group(1)) if communication_match else 75
            goal_achievement_score = int(goals_match.group(1)) if goals_match else 75
            consistency_score = int(consistency_match.group(1)) if consistency_match else 75
            
            # Extraer resumen (después de las puntuaciones)
            summary_parts = eval_text.split('CONSISTENCY:')
            ai_summary = summary_parts[1].strip() if len(summary_parts) > 1 else eval_text
            ai_summary = clean_markdown_to_html(ai_summary)
            
            # Llamada 2: Fortalezas
            strengths_response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": f"""Identifica las 3-5 principales fortalezas del usuario basándote en sus reuniones.

{meetings_context[:2000]}

Lista las fortalezas de forma concreta y específica. NO uses Markdown, usa <strong>texto</strong> para resaltar. Formato: lista numerada simple."""
                    }
                ],
                max_tokens=300
            )
            
            strengths = strengths_response.choices[0].message.content.strip()
            strengths = clean_markdown_to_html(strengths)
            tokens_used += strengths_response.usage.total_tokens
            
            # Llamada 3: Áreas de mejora
            improvement_response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": f"""Identifica las 3-5 principales áreas de mejora del usuario.

{meetings_context[:2000]}

Lista las áreas que necesitan trabajo. Sé constructivo. NO uses Markdown, usa <strong>texto</strong> para resaltar."""
                    }
                ],
                max_tokens=300
            )
            
            improvement_areas = improvement_response.choices[0].message.content.strip()
            improvement_areas = clean_markdown_to_html(improvement_areas)
            tokens_used += improvement_response.usage.total_tokens
            
            # Llamada 4: Recomendaciones de capacitación
            training_response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": f"""Sugiere 3-5 cursos, entrenamientos o recursos específicos que ayudarían al usuario a mejorar.

Áreas de mejora identificadas:
{improvement_areas}

Proporciona recomendaciones concretas (nombres de cursos, temas, plataformas). NO uses Markdown, usa <strong>texto</strong> para resaltar."""
                    }
                ],
                max_tokens=300
            )
            
            training_recommendations = training_response.choices[0].message.content.strip()
            training_recommendations = clean_markdown_to_html(training_recommendations)
            tokens_used += training_response.usage.total_tokens
            
            # Crear la evaluación
            evaluation = UserAIPerformanceEvaluation.objects.create(
                user=user,
                company=meetings.first().ai_manager.company,
                evaluation_date=end_date,
                overall_score=overall_score,
                productivity_score=productivity_score,
                communication_score=communication_score,
                goal_achievement_score=goal_achievement_score,
                consistency_score=consistency_score,
                improvement_areas=improvement_areas,
                training_recommendations=training_recommendations,
                strengths=strengths,
                meetings_analyzed=meetings.count(),
                period_start=start_date,
                period_end=end_date,
                ai_summary=ai_summary,
                tokens_used=tokens_used,
                generated_by=request.user
            )
            
            messages.success(request, f'Evaluación generada exitosamente. Puntuación: {overall_score}/100')
            return redirect('user_ai_performance_detail', user_id=user_id)
            
        except Exception as e:
            messages.error(request, f'Error al generar evaluación: {str(e)}')
            return redirect('user_ai_performance_detail', user_id=user_id)
    
    return redirect('user_ai_performance_detail', user_id=user_id)


# ============= VISTAS PARA RASTREADOR WEB =============

@login_required
def website_tracker_list(request):
    """Lista de rastreos realizados"""
    trackers = WebsiteTracker.objects.filter(user=request.user).order_by('-created_at')
    
    context = {
        'trackers': trackers,
        'page_title': 'Rastreador Web'
    }
    return render(request, 'tickets/website_tracker_list.html', context)


@login_required
def website_tracker_create(request):
    """Crear nuevo rastreo de sitio web/IP"""
    if request.method == 'POST':
        target = request.POST.get('target', '').strip()
        
        if not target:
            messages.error(request, 'Debes proporcionar una URL o IP')
            return redirect('website_tracker_list')
        
        try:
            # Importar la función de rastreo
            from .web_tracker_utils import track_website
            
            # Realizar el rastreo
            result = track_website(target)
            
            # Crear el registro
            tracker = WebsiteTracker.objects.create(
                target=target,
                user=request.user,
                is_active=result['is_active'],
                ping_response_time=result['ping_response_time'],
                ip_address=result['ip_address'] or '',
                cname_records=result['cname_records'],
                txt_records=result['txt_records'],
                mx_records=result['mx_records'],
                ns_records=result['ns_records'],
                http_status_code=result['http_status_code'],
                http_headers=result['http_headers'],
                redirect_url=result['redirect_url'] or '',
                server_software=result['server_software'] or '',
                technologies=result['technologies'],
                ssl_valid=result['ssl_valid'],
                ssl_issuer=result['ssl_issuer'] or '',
                ssl_expiry_date=result['ssl_expiry_date'],
                page_title=result['page_title'] or '',
                meta_description=result['meta_description'] or '',
                page_size=result['page_size'],
                load_time=result['load_time'],
                error_message=result['error_message'] or ''
            )
            
            messages.success(request, f'Rastreo completado exitosamente para {target}')
            return redirect('website_tracker_detail', pk=tracker.pk)
            
        except Exception as e:
            messages.error(request, f'Error al realizar el rastreo: {str(e)}')
            return redirect('website_tracker_list')
    
    return redirect('website_tracker_list')


@login_required
def website_tracker_detail(request, pk):
    """Detalle de un rastreo"""
    tracker = get_object_or_404(WebsiteTracker, pk=pk, user=request.user)
    
    context = {
        'tracker': tracker,
        'page_title': f'Rastreo - {tracker.target}'
    }
    return render(request, 'tickets/website_tracker_detail.html', context)


@login_required
def website_tracker_delete(request, pk):
    """Eliminar un rastreo"""
    tracker = get_object_or_404(WebsiteTracker, pk=pk, user=request.user)
    
    if request.method == 'POST':
        target = tracker.target
        tracker.delete()
        messages.success(request, f'Rastreo de {target} eliminado exitosamente')
        return redirect('website_tracker_list')
    
    context = {
        'tracker': tracker,
        'page_title': f'Eliminar rastreo - {tracker.target}'
    }
    return render(request, 'tickets/website_tracker_delete.html', context)


# ============= VIEWS PARA GENERADOR DE CONTRATOS LEGALES =============

@login_required
def legal_contract_list(request):
    """Lista de contratos legales"""
    contracts = LegalContract.objects.filter(user=request.user).select_related(
        'company', 'client_company', 'user'
    ).order_by('-created_at')
    
    # Filtros
    status_filter = request.GET.get('status', '')
    search = request.GET.get('search', '')
    
    if status_filter:
        contracts = contracts.filter(status=status_filter)
    
    if search:
        contracts = contracts.filter(
            Q(name__icontains=search) |
            Q(contract_type__icontains=search) |
            Q(company__name__icontains=search) |
            Q(client_company__name__icontains=search)
        )
    
    # Paginación
    paginator = Paginator(contracts, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_obj': page_obj,
        'status_filter': status_filter,
        'search': search,
        'page_title': 'Contratos Legales'
    }
    return render(request, 'tickets/legal_contract_list.html', context)


@login_required
def legal_contract_create(request):
    """Crear nuevo contrato legal"""
    if request.method == 'POST':
        try:
            contract = LegalContract.objects.create(
                name=request.POST.get('name'),
                contract_type=request.POST.get('contract_type'),
                objective_prompt=request.POST.get('objective_prompt'),
                company_id=request.POST.get('company'),
                client_company_id=request.POST.get('client_company'),
                start_date=request.POST.get('start_date') or None,
                end_date=request.POST.get('end_date') or None,
                amount=request.POST.get('amount') or None,
                currency=request.POST.get('currency', 'USD'),
                user=request.user,
                status='draft'
            )
            
            messages.success(request, 'Contrato creado exitosamente')
            return redirect('legal_contract_detail', pk=contract.pk)
            
        except Exception as e:
            messages.error(request, f'Error al crear el contrato: {str(e)}')
    
    companies = Company.objects.filter(is_active=True).order_by('name')
    
    context = {
        'companies': companies,
        'page_title': 'Nuevo Contrato Legal'
    }
    return render(request, 'tickets/legal_contract_form.html', context)


@login_required
def legal_contract_detail(request, pk):
    """Detalle de un contrato legal"""
    contract = get_object_or_404(
        LegalContract.objects.select_related('company', 'client_company', 'user'),
        pk=pk,
        user=request.user
    )
    
    context = {
        'contract': contract,
        'page_title': f'Contrato - {contract.name}'
    }
    return render(request, 'tickets/legal_contract_detail.html', context)


@login_required
def legal_contract_edit(request, pk):
    """Editar contrato legal"""
    contract = get_object_or_404(LegalContract, pk=pk, user=request.user)
    
    if request.method == 'POST':
        try:
            contract.name = request.POST.get('name')
            contract.contract_type = request.POST.get('contract_type')
            contract.objective_prompt = request.POST.get('objective_prompt')
            contract.company_id = request.POST.get('company')
            contract.client_company_id = request.POST.get('client_company')
            contract.start_date = request.POST.get('start_date') or None
            contract.end_date = request.POST.get('end_date') or None
            contract.amount = request.POST.get('amount') or None
            contract.currency = request.POST.get('currency', 'USD')
            contract.notes = request.POST.get('notes', '')
            contract.save()
            
            messages.success(request, 'Contrato actualizado exitosamente')
            return redirect('legal_contract_detail', pk=contract.pk)
            
        except Exception as e:
            messages.error(request, f'Error al actualizar el contrato: {str(e)}')
    
    companies = Company.objects.filter(is_active=True).order_by('name')
    
    context = {
        'contract': contract,
        'companies': companies,
        'page_title': f'Editar - {contract.name}'
    }
    return render(request, 'tickets/legal_contract_form.html', context)


@login_required
def legal_contract_delete(request, pk):
    """Eliminar contrato legal"""
    contract = get_object_or_404(LegalContract, pk=pk, user=request.user)
    
    if request.method == 'POST':
        name = contract.name
        contract.delete()
        messages.success(request, f'Contrato "{name}" eliminado exitosamente')
        return redirect('legal_contract_list')
    
    context = {
        'contract': contract,
        'page_title': f'Eliminar - {contract.name}'
    }
    return render(request, 'tickets/legal_contract_delete.html', context)


@login_required
def legal_contract_update_content(request, pk):
    """Actualizar el contenido generado del contrato"""
    contract = get_object_or_404(LegalContract, pk=pk, user=request.user)
    
    if request.method == 'POST':
        try:
            new_content = request.POST.get('generated_content', '').strip()
            if not new_content:
                messages.error(request, 'El contenido no puede estar vacío')
                return redirect('legal_contract_detail', pk=contract.pk)
            
            contract.generated_content = new_content
            contract.save()
            
            messages.success(request, 'Contenido del contrato actualizado exitosamente')
        except Exception as e:
            messages.error(request, f'Error al actualizar el contenido: {str(e)}')
    
    return redirect('legal_contract_detail', pk=contract.pk)


@login_required
def legal_contract_generate(request, pk):
    """Generar contrato con IA"""
    contract = get_object_or_404(LegalContract, pk=pk, user=request.user)
    
    if request.method == 'POST':
        try:
            contract.generate_with_ai()
            messages.success(request, 'Contrato generado exitosamente con IA')
        except Exception as e:
            messages.error(request, f'Error al generar el contrato: {str(e)}')
        
        return redirect('legal_contract_detail', pk=contract.pk)
    
    return redirect('legal_contract_detail', pk=contract.pk)


@login_required
def legal_contract_download_pdf(request, pk):
    """Descargar contrato en PDF"""
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
    from reportlab.lib import colors
    from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_JUSTIFY
    from io import BytesIO
    import markdown
    from bs4 import BeautifulSoup
    
    contract = get_object_or_404(LegalContract, pk=pk, user=request.user)
    
    # Crear el PDF en memoria
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter, rightMargin=72, leftMargin=72,
                            topMargin=72, bottomMargin=18)
    
    # Estilos
    styles = getSampleStyleSheet()
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=18,
        textColor=colors.HexColor('#2C3E50'),
        spaceAfter=30,
        alignment=TA_CENTER,
        fontName='Helvetica-Bold'
    )
    
    heading_style = ParagraphStyle(
        'CustomHeading',
        parent=styles['Heading2'],
        fontSize=14,
        textColor=colors.HexColor('#34495E'),
        spaceAfter=12,
        spaceBefore=12,
        fontName='Helvetica-Bold'
    )
    
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=11,
        leading=16,
        alignment=TA_JUSTIFY,
        spaceAfter=10
    )
    
    # Contenido del PDF
    story = []
    
    # Título
    story.append(Paragraph(contract.name.upper(), title_style))
    story.append(Spacer(1, 0.2 * inch))
    
    # Información de las partes
    story.append(Paragraph("PARTES CONTRATANTES", heading_style))
    
    parties_data = [
        ['PROVEEDOR:', contract.company.name],
        ['Dirección:', contract.company.address or 'N/A'],
        ['Teléfono:', contract.company.phone or 'N/A'],
        ['Email:', contract.company.email or 'N/A'],
        ['', ''],
        ['CLIENTE:', contract.client_company.name],
        ['Dirección:', contract.client_company.address or 'N/A'],
        ['Teléfono:', contract.client_company.phone or 'N/A'],
        ['Email:', contract.client_company.email or 'N/A'],
    ]
    
    parties_table = Table(parties_data, colWidths=[2*inch, 4*inch])
    parties_table.setStyle(TableStyle([
        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
        ('TOPPADDING', (0, 0), (-1, -1), 6),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
    ]))
    
    story.append(parties_table)
    story.append(Spacer(1, 0.3 * inch))
    
    # Detalles del contrato
    if contract.start_date or contract.end_date or contract.amount:
        story.append(Paragraph("DETALLES DEL CONTRATO", heading_style))
        
        details_data = []
        if contract.start_date:
            details_data.append(['Fecha de inicio:', contract.start_date.strftime('%d/%m/%Y')])
        if contract.end_date:
            details_data.append(['Fecha de finalización:', contract.end_date.strftime('%d/%m/%Y')])
        if contract.amount:
            details_data.append(['Monto:', f'{contract.amount} {contract.currency}'])
        
        details_table = Table(details_data, colWidths=[2*inch, 4*inch])
        details_table.setStyle(TableStyle([
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ('TOPPADDING', (0, 0), (-1, -1), 6),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
        ]))
        
        story.append(details_table)
        story.append(Spacer(1, 0.3 * inch))
    
    # Contenido generado
    if contract.generated_content:
        story.append(Paragraph("CONTENIDO DEL CONTRATO", heading_style))
        story.append(Spacer(1, 0.1 * inch))
        
        # Convertir Markdown a HTML y luego a paragraphs
        html_content = markdown.markdown(contract.generated_content)
        soup = BeautifulSoup(html_content, 'html.parser')
        
        for element in soup.find_all(['p', 'h1', 'h2', 'h3', 'ul', 'ol']):
            if element.name in ['h1', 'h2', 'h3']:
                story.append(Paragraph(element.get_text(), heading_style))
            elif element.name == 'p':
                story.append(Paragraph(element.get_text(), normal_style))
            elif element.name in ['ul', 'ol']:
                for li in element.find_all('li'):
                    story.append(Paragraph(f"• {li.get_text()}", normal_style))
            story.append(Spacer(1, 0.1 * inch))
    
    # Firmas
    story.append(PageBreak())
    story.append(Spacer(1, 1 * inch))
    story.append(Paragraph("FIRMAS", heading_style))
    story.append(Spacer(1, 0.5 * inch))
    
    signatures_data = [
        ['_' * 40, '_' * 40],
        [contract.company.name, contract.client_company.name],
        ['Proveedor', 'Cliente'],
    ]
    
    signatures_table = Table(signatures_data, colWidths=[3*inch, 3*inch])
    signatures_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 1), (-1, 2), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('TOPPADDING', (0, 0), (-1, -1), 10),
    ]))
    
    story.append(signatures_table)
    
    # Pie de página con fecha
    story.append(Spacer(1, 0.5 * inch))
    footer_text = f"Documento generado el {timezone.now().strftime('%d de %B de %Y')}"
    story.append(Paragraph(footer_text, ParagraphStyle('Footer', parent=styles['Normal'],
                                                        fontSize=9, textColor=colors.grey,
                                                        alignment=TA_CENTER)))
    
    # Construir el PDF
    doc.build(story)
    
    # Obtener el valor del PDF
    pdf = buffer.getvalue()
    buffer.close()
    
    # Crear la respuesta
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="contrato_{contract.pk}_{contract.name.replace(" ", "_")}.pdf"'
    response.write(pdf)
    
    return response


@login_required
def legal_contract_toggle_public(request, pk):
    """Activar/desactivar acceso público del contrato"""
    contract = get_object_or_404(LegalContract, pk=pk, user=request.user)
    
    if request.method == 'POST':
        contract.is_public = not contract.is_public
        contract.save()
        
        status = 'activado' if contract.is_public else 'desactivado'
        messages.success(request, f'Acceso público {status} para el contrato')
        
        return redirect('legal_contract_detail', pk=contract.pk)
    
    return redirect('legal_contract_detail', pk=contract.pk)


def legal_contract_public(request, token):
    """Vista pública del contrato (sin autenticación)"""
    contract = get_object_or_404(
        LegalContract.objects.select_related('company', 'client_company'),
        public_token=token,
        is_public=True
    )
    
    context = {
        'contract': contract,
        'page_title': contract.name,
        'is_public_view': True
    }
    return render(request, 'tickets/legal_contract_public.html', context)


def legal_contract_public_pdf(request, token):
    """Descargar PDF público del contrato (sin autenticación)"""
    from reportlab.lib.pagesizes import letter
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
    from reportlab.lib import colors
    from reportlab.lib.enums import TA_CENTER, TA_JUSTIFY
    from io import BytesIO
    import markdown
    from bs4 import BeautifulSoup
    
    contract = get_object_or_404(LegalContract, public_token=token, is_public=True)
    
    # Usar el mismo código que legal_contract_download_pdf pero sin requerir autenticación
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter, rightMargin=72, leftMargin=72,
                            topMargin=72, bottomMargin=18)
    
    styles = getSampleStyleSheet()
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=18,
        textColor=colors.HexColor('#2C3E50'),
        spaceAfter=30,
        alignment=TA_CENTER,
        fontName='Helvetica-Bold'
    )
    
    heading_style = ParagraphStyle(
        'CustomHeading',
        parent=styles['Heading2'],
        fontSize=14,
        textColor=colors.HexColor('#34495E'),
        spaceAfter=12,
        spaceBefore=12,
        fontName='Helvetica-Bold'
    )
    
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=11,
        leading=16,
        alignment=TA_JUSTIFY,
        spaceAfter=10
    )
    
    story = []
    story.append(Paragraph(contract.name.upper(), title_style))
    story.append(Spacer(1, 0.2 * inch))
    
    story.append(Paragraph("PARTES CONTRATANTES", heading_style))
    
    parties_data = [
        ['PROVEEDOR:', contract.company.name],
        ['Dirección:', contract.company.address or 'N/A'],
        ['Teléfono:', contract.company.phone or 'N/A'],
        ['Email:', contract.company.email or 'N/A'],
        ['', ''],
        ['CLIENTE:', contract.client_company.name],
        ['Dirección:', contract.client_company.address or 'N/A'],
        ['Teléfono:', contract.client_company.phone or 'N/A'],
        ['Email:', contract.client_company.email or 'N/A'],
    ]
    
    parties_table = Table(parties_data, colWidths=[2*inch, 4*inch])
    parties_table.setStyle(TableStyle([
        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
        ('TOPPADDING', (0, 0), (-1, -1), 6),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
    ]))
    
    story.append(parties_table)
    story.append(Spacer(1, 0.3 * inch))
    
    if contract.start_date or contract.end_date or contract.amount:
        story.append(Paragraph("DETALLES DEL CONTRATO", heading_style))
        
        details_data = []
        if contract.start_date:
            details_data.append(['Fecha de inicio:', contract.start_date.strftime('%d/%m/%Y')])
        if contract.end_date:
            details_data.append(['Fecha de finalización:', contract.end_date.strftime('%d/%m/%Y')])
        if contract.amount:
            details_data.append(['Monto:', f'{contract.amount} {contract.currency}'])
        
        details_table = Table(details_data, colWidths=[2*inch, 4*inch])
        details_table.setStyle(TableStyle([
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#2C3E50')),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ('TOPPADDING', (0, 0), (-1, -1), 6),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
        ]))
        
        story.append(details_table)
        story.append(Spacer(1, 0.3 * inch))
    
    if contract.generated_content:
        story.append(Paragraph("CONTENIDO DEL CONTRATO", heading_style))
        story.append(Spacer(1, 0.1 * inch))
        
        html_content = markdown.markdown(contract.generated_content)
        soup = BeautifulSoup(html_content, 'html.parser')
        
        for element in soup.find_all(['p', 'h1', 'h2', 'h3', 'ul', 'ol']):
            if element.name in ['h1', 'h2', 'h3']:
                story.append(Paragraph(element.get_text(), heading_style))
            elif element.name == 'p':
                story.append(Paragraph(element.get_text(), normal_style))
            elif element.name in ['ul', 'ol']:
                for li in element.find_all('li'):
                    story.append(Paragraph(f"• {li.get_text()}", normal_style))
            story.append(Spacer(1, 0.1 * inch))
    
    story.append(PageBreak())
    story.append(Spacer(1, 1 * inch))
    story.append(Paragraph("FIRMAS", heading_style))
    story.append(Spacer(1, 0.5 * inch))
    
    signatures_data = [
        ['_' * 40, '_' * 40],
        [contract.company.name, contract.client_company.name],
        ['Proveedor', 'Cliente'],
    ]
    
    signatures_table = Table(signatures_data, colWidths=[3*inch, 3*inch])
    signatures_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 1), (-1, 2), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('TOPPADDING', (0, 0), (-1, -1), 10),
    ]))
    
    story.append(signatures_table)
    story.append(Spacer(1, 0.5 * inch))
    
    footer_text = f"Documento generado el {timezone.now().strftime('%d de %B de %Y')}"
    story.append(Paragraph(footer_text, ParagraphStyle('Footer', parent=styles['Normal'],
                                                        fontSize=9, textColor=colors.grey,
                                                        alignment=TA_CENTER)))
    
    doc.build(story)
    pdf = buffer.getvalue()
    buffer.close()
    
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="contrato_{contract.name.replace(" ", "_")}.pdf"'
    response.write(pdf)
    
    return response


# ============================================================================
# VISTAS PARA REVISIÓN DE CONTRATOS DE PROVEEDORES
# ============================================================================

@login_required
def supplier_contract_review_list(request):
    """Lista de revisiones de contratos de proveedores"""
    from .models import SupplierContractReview
    
    reviews = SupplierContractReview.objects.filter(user=request.user).select_related('company')
    
    # Filtros
    search = request.GET.get('search', '')
    if search:
        reviews = reviews.filter(
            Q(name__icontains=search) |
            Q(supplier_name__icontains=search)
        )
    
    company_id = request.GET.get('company')
    if company_id:
        reviews = reviews.filter(company_id=company_id)
    
    status = request.GET.get('status')
    if status:
        reviews = reviews.filter(status=status)
    
    risk_level = request.GET.get('risk_level')
    if risk_level:
        reviews = reviews.filter(risk_level=risk_level)
    
    # Paginación
    paginator = Paginator(reviews, 12)
    page_number = request.GET.get('page')
    reviews = paginator.get_page(page_number)
    
    companies = Company.objects.filter(is_active=True).order_by('name')
    
    context = {
        'reviews': reviews,
        'companies': companies,
        'page_title': 'Revisión de Contratos de Proveedores'
    }
    return render(request, 'tickets/supplier_contract_review_list.html', context)


@login_required
def supplier_contract_review_create(request):
    """Crear nueva revisión de contrato"""
    from .models import SupplierContractReview
    
    if request.method == 'POST':
        try:
            review = SupplierContractReview()
            review.user = request.user
            review.name = request.POST.get('name')
            review.supplier_name = request.POST.get('supplier_name')
            review.company_id = request.POST.get('company')
            review.contract_text = request.POST.get('contract_text', '')
            
            # Manejar archivo
            if 'contract_file' in request.FILES:
                review.contract_file = request.FILES['contract_file']
            
            review.internal_notes = request.POST.get('internal_notes', '')
            review.save()
            
            messages.success(request, 'Contrato guardado exitosamente. Ahora puedes generar la revisión con IA.')
            return redirect('supplier_contract_review_detail', pk=review.pk)
            
        except Exception as e:
            messages.error(request, f'Error al guardar el contrato: {str(e)}')
    
    companies = Company.objects.filter(is_active=True).order_by('name')
    
    context = {
        'companies': companies,
        'page_title': 'Nueva Revisión de Contrato'
    }
    return render(request, 'tickets/supplier_contract_review_form.html', context)


@login_required
def supplier_contract_review_detail(request, pk):
    """Detalle de revisión de contrato"""
    from .models import SupplierContractReview
    
    review = get_object_or_404(SupplierContractReview, pk=pk, user=request.user)
    
    context = {
        'review': review,
        'page_title': review.name
    }
    return render(request, 'tickets/supplier_contract_review_detail.html', context)


@login_required
def supplier_contract_review_edit(request, pk):
    """Editar revisión de contrato"""
    from .models import SupplierContractReview
    
    review = get_object_or_404(SupplierContractReview, pk=pk, user=request.user)
    
    if request.method == 'POST':
        try:
            review.name = request.POST.get('name')
            review.supplier_name = request.POST.get('supplier_name')
            review.company_id = request.POST.get('company')
            review.contract_text = request.POST.get('contract_text', '')
            
            # Manejar archivo
            if 'contract_file' in request.FILES:
                review.contract_file = request.FILES['contract_file']
            
            review.internal_notes = request.POST.get('internal_notes', '')
            review.save()
            
            messages.success(request, 'Contrato actualizado exitosamente')
            return redirect('supplier_contract_review_detail', pk=review.pk)
            
        except Exception as e:
            messages.error(request, f'Error al actualizar el contrato: {str(e)}')
    
    companies = Company.objects.filter(is_active=True).order_by('name')
    
    context = {
        'review': review,
        'companies': companies,
        'page_title': f'Editar - {review.name}'
    }
    return render(request, 'tickets/supplier_contract_review_form.html', context)


@login_required
def supplier_contract_review_delete(request, pk):
    """Eliminar revisión de contrato"""
    from .models import SupplierContractReview
    
    review = get_object_or_404(SupplierContractReview, pk=pk, user=request.user)
    
    if request.method == 'POST':
        name = review.name
        review.delete()
        messages.success(request, f'Revisión "{name}" eliminada exitosamente')
        return redirect('supplier_contract_review_list')
    
    context = {
        'review': review,
        'page_title': f'Eliminar - {review.name}'
    }
    return render(request, 'tickets/supplier_contract_review_delete.html', context)


@login_required
def supplier_contract_review_generate(request, pk):
    """Generar revisión con IA"""
    from .models import SupplierContractReview
    
    review = get_object_or_404(SupplierContractReview, pk=pk, user=request.user)
    
    if request.method == 'POST':
        try:
            review.review_with_ai()
            messages.success(request, 'Revisión generada exitosamente con IA')
        except Exception as e:
            messages.error(request, f'Error al generar revisión: {str(e)}')
    
    return redirect('supplier_contract_review_detail', pk=review.pk)


@login_required
def supplier_contract_review_update_status(request, pk):
    """Actualizar el estado de la revisión"""
    from .models import SupplierContractReview
    
    review = get_object_or_404(SupplierContractReview, pk=pk, user=request.user)
    
    if request.method == 'POST':
        new_status = request.POST.get('status')
        if new_status in dict(SupplierContractReview.REVIEW_STATUS_CHOICES).keys():
            review.status = new_status
            review.save()
            messages.success(request, f'Estado actualizado a {review.get_status_display()}')
        else:
            messages.error(request, 'Estado inválido')
    
    return redirect('supplier_contract_review_detail', pk=review.pk)


@login_required
def supplier_contract_review_download_pdf(request, pk):
    """Descargar revisión en PDF"""
    from .models import SupplierContractReview
    from reportlab.lib.pagesizes import letter
    from reportlab.lib import colors
    from reportlab.lib.units import inch
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.enums import TA_CENTER, TA_LEFT
    from io import BytesIO
    
    review = get_object_or_404(SupplierContractReview, pk=pk, user=request.user)
    
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter,
                           rightMargin=72, leftMargin=72,
                           topMargin=72, bottomMargin=18)
    
    story = []
    styles = getSampleStyleSheet()
    
    # Título
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        textColor=colors.HexColor('#1a365d'),
        spaceAfter=30,
        alignment=TA_CENTER
    )
    story.append(Paragraph("REVISIÓN DE CONTRATO DE PROVEEDOR", title_style))
    story.append(Spacer(1, 0.3 * inch))
    
    # Información básica
    info_data = [
        ['Contrato:', review.name],
        ['Proveedor:', review.supplier_name],
        ['Empresa Revisora:', review.company.name],
        ['Estado:', review.get_status_display()],
        ['Nivel de Riesgo:', review.get_risk_level_display()],
        ['Fecha de Revisión:', review.reviewed_at.strftime('%d/%m/%Y') if review.reviewed_at else 'Pendiente'],
    ]
    
    info_table = Table(info_data, colWidths=[2*inch, 4*inch])
    info_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#e6f2ff')),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('GRID', (0, 0), (-1, -1), 1, colors.grey),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
    ]))
    
    story.append(info_table)
    story.append(Spacer(1, 0.5 * inch))
    
    # Revisión de IA
    if review.ai_review:
        story.append(Paragraph("ANÁLISIS COMPLETO", styles['Heading2']))
        story.append(Spacer(1, 0.2 * inch))
        
        # Procesar el contenido línea por línea
        review_lines = review.ai_review.split('\n')
        for line in review_lines:
            if line.strip():
                story.append(Paragraph(line, styles['BodyText']))
                story.append(Spacer(1, 0.1 * inch))
    
    # Footer
    story.append(Spacer(1, 0.5 * inch))
    footer_text = f"Documento generado el {timezone.now().strftime('%d de %B de %Y')}"
    story.append(Paragraph(footer_text, ParagraphStyle('Footer', parent=styles['Normal'],
                                                        fontSize=9, textColor=colors.grey,
                                                        alignment=TA_CENTER)))
    
    doc.build(story)
    pdf = buffer.getvalue()
    buffer.close()
    
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="revision_contrato_{review.name.replace(" ", "_")}.pdf"'
    response.write(pdf)
    
    return response


# =====================================================
# VISTAS DE ENLACES DE PAGO PAYPAL
# =====================================================

@login_required
def paypal_link_list(request):
    """Lista de enlaces de pago de PayPal"""
    from .models import PayPalPaymentLink
    
    links = PayPalPaymentLink.objects.filter(user=request.user).select_related('company')
    
    # Filtros
    search = request.GET.get('search', '')
    if search:
        links = links.filter(
            Q(product_name__icontains=search) |
            Q(description__icontains=search)
        )
    
    company_id = request.GET.get('company')
    if company_id:
        links = links.filter(company_id=company_id)
    
    status = request.GET.get('status')
    if status:
        links = links.filter(status=status)
    
    # Paginación
    paginator = Paginator(links, 12)
    page_number = request.GET.get('page')
    links = paginator.get_page(page_number)
    
    companies = Company.objects.filter(is_active=True).order_by('name')
    
    context = {
        'links': links,
        'companies': companies,
        'page_title': 'Enlaces de Pago PayPal'
    }
    return render(request, 'tickets/paypal_link_list.html', context)


@login_required
def paypal_link_create(request):
    """Crear nuevo enlace de pago"""
    from .models import PayPalPaymentLink
    
    if request.method == 'POST':
        try:
            link = PayPalPaymentLink()
            link.user = request.user
            link.product_name = request.POST.get('product_name')
            link.description = request.POST.get('description', '')
            link.amount = request.POST.get('amount')
            
            company_id = request.POST.get('company')
            if company_id:
                link.company_id = company_id
            
            # Manejar archivo adjunto
            if 'attachment' in request.FILES:
                link.attachment = request.FILES['attachment']
                link.attachment_name = request.POST.get('attachment_name', link.attachment.name)
            
            # Fecha de expiración (opcional)
            expires_at = request.POST.get('expires_at')
            if expires_at:
                from datetime import datetime
                link.expires_at = datetime.strptime(expires_at, '%Y-%m-%d')
            
            link.notes = request.POST.get('notes', '')
            link.save()
            
            messages.success(request, f'Enlace de pago creado exitosamente. URL: {link.public_url}')
            return redirect('paypal_link_detail', pk=link.pk)
            
        except Exception as e:
            messages.error(request, f'Error al crear el enlace: {str(e)}')
    
    companies = Company.objects.filter(is_active=True).order_by('name')
    
    context = {
        'companies': companies,
        'page_title': 'Nuevo Enlace de Pago'
    }
    return render(request, 'tickets/paypal_link_form.html', context)


@login_required
def paypal_link_detail(request, pk):
    """Detalle del enlace de pago"""
    from .models import PayPalPaymentLink
    
    link = get_object_or_404(PayPalPaymentLink, pk=pk, user=request.user)
    
    context = {
        'link': link,
        'page_title': link.product_name
    }
    return render(request, 'tickets/paypal_link_detail.html', context)


@login_required
def paypal_link_edit(request, pk):
    """Editar producto de pago (plantilla reutilizable)"""
    from .models import PayPalPaymentLink
    
    link = get_object_or_404(PayPalPaymentLink, pk=pk, user=request.user)
    
    # Los productos reutilizables siempre pueden editarse
    # Los cambios NO afectan a las órdenes ya creadas
    
    if request.method == 'POST':
        try:
            link.product_name = request.POST.get('product_name')
            link.description = request.POST.get('description', '')
            link.amount = request.POST.get('amount')
            
            company_id = request.POST.get('company')
            link.company_id = company_id if company_id else None
            
            # Manejar archivo adjunto
            if 'attachment' in request.FILES:
                link.attachment = request.FILES['attachment']
                link.attachment_name = request.POST.get('attachment_name', link.attachment.name)
            
            # Fecha de expiración
            expires_at = request.POST.get('expires_at')
            if expires_at:
                from datetime import datetime
                link.expires_at = datetime.strptime(expires_at, '%Y-%m-%d')
            else:
                link.expires_at = None
            
            link.notes = request.POST.get('notes', '')
            link.save()
            
            messages.success(request, 'Producto actualizado exitosamente. Los cambios solo afectarán a las nuevas compras.')
            return redirect('paypal_link_detail', pk=link.pk)
            
        except Exception as e:
            messages.error(request, f'Error al actualizar el enlace: {str(e)}')
    
    companies = Company.objects.filter(is_active=True).order_by('name')
    
    context = {
        'link': link,
        'companies': companies,
        'page_title': f'Editar - {link.product_name}'
    }
    return render(request, 'tickets/paypal_link_form.html', context)


@login_required
def paypal_link_delete(request, pk):
    """Eliminar enlace de pago"""
    from .models import PayPalPaymentLink
    
    link = get_object_or_404(PayPalPaymentLink, pk=pk, user=request.user)
    
    # No permitir eliminación si ya está pagado
    if link.status == 'paid':
        messages.warning(request, 'No se puede eliminar un enlace que ya ha sido pagado')
        return redirect('paypal_link_detail', pk=link.pk)
    
    if request.method == 'POST':
        product_name = link.product_name
        link.delete()
        messages.success(request, f'Enlace "{product_name}" eliminado exitosamente')
        return redirect('paypal_link_list')
    
    context = {
        'link': link,
        'page_title': f'Eliminar - {link.product_name}'
    }
    return render(request, 'tickets/paypal_link_delete.html', context)


@login_required
def paypal_link_cancel(request, pk):
    """Cancelar enlace de pago"""
    from .models import PayPalPaymentLink
    
    link = get_object_or_404(PayPalPaymentLink, pk=pk, user=request.user)
    
    if link.status in ['active']:
        link.status = 'cancelled'
        link.save()
        messages.success(request, 'Enlace cancelado exitosamente')
    else:
        messages.warning(request, f'No se puede cancelar un enlace con estado {link.get_status_display()}')
    
    return redirect('paypal_link_detail', pk=link.pk)


@login_required
def paypal_generate_public_catalog_token(request):
    """Generar o regenerar token público para catálogo de productos"""
    import uuid
    from .models import SystemConfiguration
    
    if request.method == 'POST':
        config = SystemConfiguration.get_config()
        
        # Generar nuevo token
        new_token = uuid.uuid4()
        config.products_catalog_token = new_token
        config.save()
        
        # Construir URL pública
        public_url = request.build_absolute_uri(
            f'/public/products/{new_token}/'
        )
        
        messages.success(request, f'Token público generado exitosamente. URL: {public_url}')
        return JsonResponse({
            'success': True,
            'token': str(new_token),
            'url': public_url
        })
    
    return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)


def public_products_catalog(request, token):
    """Vista pública para mostrar catálogo de productos"""
    from .models import Product, SystemConfiguration
    
    # Verificar token
    config = SystemConfiguration.get_config()
    
    if not config.products_catalog_token or str(config.products_catalog_token) != str(token):
        messages.error(request, 'Token inválido o catálogo no disponible')
        return render(request, 'tickets/public_products_error.html', status=404)
    
    # Obtener productos activos
    products = Product.objects.filter(is_active=True).order_by('name')
    
    # Información de configuración para el catálogo
    catalog_info = {
        'company_name': config.company_name if hasattr(config, 'company_name') else 'Nuestra Empresa',
        'currency_symbol': '€',  # Puedes obtenerlo de config
    }
    
    context = {
        'products': products,
        'catalog_info': catalog_info,
        'token': token,
    }
    return render(request, 'tickets/public_products_catalog.html', context)


def create_payment_from_product(request, token, product_id):
    """Crear enlace de pago desde producto del catálogo público"""
    from .models import Product, SystemConfiguration, PayPalPaymentLink
    
    # Verificar token
    config = SystemConfiguration.get_config()
    
    if not config.products_catalog_token or str(config.products_catalog_token) != str(token):
        messages.error(request, 'Token inválido')
        return redirect('home')
    
    # Obtener producto
    product = get_object_or_404(Product, id=product_id, is_active=True)
    
    # Crear enlace de pago automáticamente
    payment_link = PayPalPaymentLink.objects.create(
        product_name=product.name,
        description=product.description,
        amount=product.price,
        status='active',
        user=product.created_by,  # Usar el creador del producto
        company=None  # O puedes asociarlo a una empresa si el producto tiene
    )
    
    # Construir URL pública del enlace de pago
    payment_link.public_url = request.build_absolute_uri(
        f'/paypal-payment/{payment_link.public_token}/'
    )
    payment_link.save()
    
    # Redirigir a la página de pago
    return redirect('paypal_payment_page', token=payment_link.public_token)


# Vista de debug para PayPal (solo para admins)
@login_required
def paypal_debug_config(request):
    """Vista para verificar configuración de PayPal"""
    from .models import SystemConfiguration
    
    config = SystemConfiguration.objects.first()
    
    debug_info = {
        'config_exists': config is not None,
        'paypal_enabled': config.paypal_enabled if config else False,
        'paypal_mode': config.paypal_mode if config else 'No configurado',
        'client_id_configured': bool(config.paypal_client_id) if config else False,
        'client_id_length': len(config.paypal_client_id) if config and config.paypal_client_id else 0,
        'client_secret_configured': bool(config.paypal_client_secret) if config else False,
    }
    
    context = {
        'debug_info': debug_info,
        'config': config,
        'page_title': 'Debug PayPal'
    }
    
    return render(request, 'tickets/paypal_debug.html', context)


# Vista pública - sin login requerido
def paypal_payment_page(request, token):
    """Página pública de pago (reutilizable - cada compra crea una orden individual)"""
    from .models import PayPalPaymentLink, SystemConfiguration
    
    link = get_object_or_404(PayPalPaymentLink, public_token=token)
    
    # Verificar si está activo (expiración)
    if not link.is_active():
        context = {
            'error': 'Este enlace de pago ya no está disponible',
            'link': link,
            'page_title': 'Enlace No Disponible'
        }
        return render(request, 'tickets/paypal_payment_page.html', context)
    
    # Ya NO verificamos si está pagado - los enlaces son reutilizables
    # Cada compra crea una orden individual (PayPalOrder)
    
    # Obtener configuración de PayPal
    try:
        config = SystemConfiguration.objects.first()
        if not config or not config.paypal_enabled:
            context = {
                'error': 'El sistema de pagos no está disponible en este momento',
                'page_title': 'Sistema No Disponible'
            }
            return render(request, 'tickets/paypal_payment_page.html', context)
        
        paypal_client_id = config.paypal_client_id
        paypal_mode = config.paypal_mode  # 'sandbox' o 'live'
        
    except Exception as e:
        context = {
            'error': 'Error al cargar la configuración de pago',
            'page_title': 'Error'
        }
        return render(request, 'tickets/paypal_payment_page.html', context)
    
    context = {
        'link': link,
        'paypal_client_id': paypal_client_id,
        'paypal_mode': paypal_mode,
        'page_title': link.product_name
    }
    return render(request, 'tickets/paypal_payment_page.html', context)


@csrf_exempt  # PayPal webhook
def paypal_webhook(request):
    """Webhook para recibir notificaciones de PayPal"""
    import json
    from .models import PayPalPaymentLink, SystemConfiguration
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        payload = json.loads(request.body)
        event_type = payload.get('event_type')
        
        # Manejar evento de pago completado
        if event_type == 'CHECKOUT.ORDER.APPROVED' or event_type == 'PAYMENT.CAPTURE.COMPLETED':
            resource = payload.get('resource', {})
            order_id = resource.get('id')
            
            # Buscar el enlace por order_id
            link = PayPalPaymentLink.objects.filter(paypal_order_id=order_id).first()
            if link:
                # Obtener información del pagador
                payer_info = resource.get('payer', {})
                link.mark_as_paid(order_id, payer_info)
                
                return JsonResponse({'status': 'success', 'message': 'Payment processed'})
        
        return JsonResponse({'status': 'ignored', 'message': 'Event not processed'})
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=400)


@csrf_exempt  # API endpoint para crear orden
def paypal_create_order(request):
    """API para crear orden de PayPal usando el SDK"""
    import json
    import logging
    from .models import PayPalPaymentLink, PayPalOrder, SystemConfiguration
    
    logger = logging.getLogger(__name__)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        link_id = data.get('link_id')
        
        logger.info(f"Creating PayPal order for link_id: {link_id}")
        
        link = get_object_or_404(PayPalPaymentLink, pk=link_id)
        
        # Verificar que está activo (el enlace puede ser reutilizado)
        if not link.is_active():
            logger.warning(f"Link {link_id} is not active")
            return JsonResponse({'error': 'Link not active'}, status=400)
        
        # Crear una nueva orden para esta compra
        new_order = PayPalOrder.objects.create(
            payment_link=link,
            product_name=link.product_name,
            description=link.description,
            amount=link.amount,
            paypal_order_id='',  # Se actualizará después
            status='pending'
        )
        
        logger.info(f"Created new PayPalOrder: {new_order.id}")
        
        # Obtener configuración
        config = SystemConfiguration.objects.first()
        if not config or not config.paypal_enabled:
            logger.error("PayPal not enabled in configuration")
            return JsonResponse({'error': 'PayPal not enabled'}, status=400)
        
        # Verificar credenciales
        if not config.paypal_client_id or not config.paypal_client_secret:
            logger.error("PayPal credentials not configured")
            return JsonResponse({'error': 'PayPal credentials not configured'}, status=400)
        
        # Usar PayPal SDK para crear orden
        import requests
        import base64
        
        # Obtener token de acceso
        auth_string = f"{config.paypal_client_id}:{config.paypal_client_secret}"
        auth_bytes = auth_string.encode('utf-8')
        auth_base64 = base64.b64encode(auth_bytes).decode('utf-8')
        
        # Determinar URL según el modo
        if config.paypal_mode == 'sandbox':
            base_url = 'https://api-m.sandbox.paypal.com'
        else:
            base_url = 'https://api-m.paypal.com'
        
        # Obtener access token
        token_response = requests.post(
            f'{base_url}/v1/oauth2/token',
            headers={
                'Authorization': f'Basic {auth_base64}',
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            data={'grant_type': 'client_credentials'}
        )
        
        if token_response.status_code != 200:
            logger.error(f"Failed to get PayPal access token: {token_response.text}")
            return JsonResponse({'error': 'Failed to authenticate with PayPal'}, status=500)
        
        access_token = token_response.json()['access_token']
        
        # Crear orden en PayPal
        order_payload = {
            'intent': 'CAPTURE',
            'purchase_units': [{
                'description': link.product_name,
                'amount': {
                    'currency_code': 'EUR',
                    'value': str(link.amount)
                },
                'reference_id': str(new_order.id),  # Usar ID de la orden nueva
                'custom_id': str(new_order.order_token)  # Token de la orden para identificación
            }],
            'application_context': {
                'brand_name': config.site_name,
                'landing_page': 'BILLING',
                'user_action': 'PAY_NOW',
                'return_url': request.build_absolute_uri(f'/paypal-payment/{link.public_token}/'),
                'cancel_url': request.build_absolute_uri(f'/paypal-payment/{link.public_token}/')
            }
        }
        
        order_response = requests.post(
            f'{base_url}/v2/checkout/orders',
            headers={
                'Authorization': f'Bearer {access_token}',
                'Content-Type': 'application/json'
            },
            json=order_payload
        )
        
        if order_response.status_code not in [200, 201]:
            logger.error(f"Failed to create PayPal order: {order_response.text}")
            # Marcar orden como fallida
            new_order.status = 'failed'
            new_order.save()
            return JsonResponse({'error': 'Failed to create PayPal order'}, status=500)
        
        order_data = order_response.json()
        paypal_order_id = order_data.get('id')
        logger.info(f"PayPal order created successfully: {paypal_order_id}")
        
        # Actualizar la orden con el ID de PayPal
        new_order.paypal_order_id = paypal_order_id
        new_order.save()
        
        # Agregar el order_token a la respuesta para usarlo en el capture
        order_data['internal_order_token'] = str(new_order.order_token)
        order_data['internal_order_id'] = new_order.id
        
        return JsonResponse(order_data)
        
    except Exception as e:
        logger.exception(f"Exception creating PayPal order: {str(e)}")
        return JsonResponse({'error': str(e)}, status=400)


@csrf_exempt  # API endpoint para capturar pago
def paypal_capture_order(request):
    """API para capturar orden de PayPal usando el SDK"""
    import json
    import logging
    from .models import PayPalOrder, SystemConfiguration
    
    logger = logging.getLogger(__name__)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        order_id = data.get('order_id')  # PayPal Order ID
        internal_order_id = data.get('internal_order_id')  # Nuestro ID interno
        
        logger.info(f"Capturing PayPal order {order_id}, internal order: {internal_order_id}")
        
        # Buscar la orden por nuestro ID interno
        order = get_object_or_404(PayPalOrder, pk=internal_order_id)
        
        # Obtener configuración
        config = SystemConfiguration.objects.first()
        if not config or not config.paypal_enabled:
            logger.error("PayPal not enabled in configuration")
            return JsonResponse({'error': 'PayPal not enabled'}, status=400)
        
        # Verificar credenciales
        if not config.paypal_client_id or not config.paypal_client_secret:
            logger.error("PayPal credentials not configured")
            return JsonResponse({'error': 'PayPal credentials not configured'}, status=400)
        
        # Usar PayPal SDK para capturar orden
        import requests
        import base64
        
        # Obtener token de acceso
        auth_string = f"{config.paypal_client_id}:{config.paypal_client_secret}"
        auth_bytes = auth_string.encode('utf-8')
        auth_base64 = base64.b64encode(auth_bytes).decode('utf-8')
        
        # Determinar URL según el modo
        if config.paypal_mode == 'sandbox':
            base_url = 'https://api-m.sandbox.paypal.com'
        else:
            base_url = 'https://api-m.paypal.com'
        
        # Obtener access token
        token_response = requests.post(
            f'{base_url}/v1/oauth2/token',
            headers={
                'Authorization': f'Basic {auth_base64}',
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            data={'grant_type': 'client_credentials'}
        )
        
        if token_response.status_code != 200:
            logger.error(f"Failed to get PayPal access token: {token_response.text}")
            return JsonResponse({'error': 'Failed to authenticate with PayPal'}, status=500)
        
        access_token = token_response.json()['access_token']
        
        # Capturar orden
        capture_response = requests.post(
            f'{base_url}/v2/checkout/orders/{order_id}/capture',
            headers={
                'Authorization': f'Bearer {access_token}',
                'Content-Type': 'application/json'
            }
        )
        
        if capture_response.status_code not in [200, 201]:
            logger.error(f"Failed to capture PayPal order: {capture_response.text}")
            return JsonResponse({'error': 'Failed to capture payment'}, status=500)
        
        capture_data = capture_response.json()
        logger.info(f"PayPal order captured successfully: {order_id}")
        
        # Extraer información del pagador
        payer_info = capture_data.get('payer', {})
        
        # Marcar la orden como pagada
        order.mark_as_paid(payer_info)
        
        # Generar URL del resumen de orden (usar el token de la orden específica)
        from django.urls import reverse
        order_summary_url = request.build_absolute_uri(
            reverse('paypal_order_detail', kwargs={'token': order.order_token})
        )
        
        return JsonResponse({
            'status': 'success',
            'message': 'Payment captured successfully',
            'order_summary_url': order_summary_url,
            'capture_id': capture_data.get('id'),
            'payer_email': payer_info.get('email_address', ''),
            'order_token': str(order.order_token)
        })
        
    except Exception as e:
        logger.exception(f"Exception capturing PayPal order: {str(e)}")
        return JsonResponse({'error': str(e)}, status=400)


# Vista pública - detalle de orden individual
def paypal_order_detail(request, token):
    """Página de detalle de una orden específica"""
    from .models import PayPalOrder, SystemConfiguration
    
    order = get_object_or_404(PayPalOrder, order_token=token)
    
    # Obtener configuración para mostrar nombre del sitio
    config = SystemConfiguration.objects.first()
    
    context = {
        'order': order,
        'link': order.payment_link,  # Para compatibilidad con el template
        'config': config,
        'page_title': f'Orden #{order.id:05d} - {order.product_name}',
        'hours_remaining': order.get_hours_until_download_expires(),
        'download_url_valid': order.is_download_token_valid(),
    }
    
    return render(request, 'tickets/paypal_order_detail.html', context)


# Vista legacy - resumen de orden (mantener compatibilidad)
def paypal_link_orders(request, token):
    """Mostrar todas las órdenes de un payment link (solo para el dueño)"""
    from .models import PayPalPaymentLink, PayPalOrder
    from django.contrib.auth.decorators import login_required
    
    link = get_object_or_404(PayPalPaymentLink, public_token=token)
    
    # Solo el dueño puede ver las órdenes
    if request.user != link.user:
        messages.error(request, 'No tienes permiso para ver estas órdenes')
        return redirect('dashboard')
    
    # Obtener todas las órdenes
    orders = PayPalOrder.objects.filter(payment_link=link).order_by('-created_at')
    
    # Calcular estadísticas
    total_orders = orders.count()
    paid_orders = orders.filter(status='completed').count()
    total_revenue = sum(order.amount for order in orders.filter(status='completed'))
    
    context = {
        'link': link,
        'orders': orders,
        'total_orders': total_orders,
        'paid_orders': paid_orders,
        'total_revenue': total_revenue,
    }
    
    return render(request, 'tickets/paypal_link_orders.html', context)


def paypal_order_summary(request, token):
    """Legacy - Redirige a la lista de órdenes del enlace"""
    return redirect('paypal_link_orders', token=token)


# Vista pública - descargar archivo con token de orden
def paypal_order_download(request, token):
    """Descargar archivo usando token de orden (válido 72 horas)"""
    from .models import PayPalOrder
    import os
    
    order = get_object_or_404(PayPalOrder, download_token=token)
    
    # Verificar que está pagado
    if not order.is_paid():
        messages.error(request, 'Esta orden no ha sido completada')
        return redirect('paypal_order_detail', token=order.order_token)
    
    # Verificar que el token no ha expirado (72 horas)
    if not order.is_download_token_valid():
        context = {
            'order': order,
            'link': order.payment_link,
            'error': 'El enlace de descarga ha expirado',
            'error_detail': 'Los enlaces de descarga son válidos por 72 horas después del pago. Por favor, contacta con el vendedor para obtener un nuevo enlace.',
            'page_title': 'Enlace Expirado'
        }
        return render(request, 'tickets/paypal_download_expired.html', context)
    
    # Verificar que tiene archivo
    if not order.payment_link.attachment:
        messages.error(request, 'Este producto no tiene archivo adjunto')
        return redirect('paypal_order_detail', token=order.order_token)
    
    # Incrementar contador de descargas
    order.increment_download()
    print(f"DEBUG: Descarga #{order.download_count} de la orden #{order.id}")
    
    # Preparar descarga
    file_path = order.payment_link.attachment.path
    if os.path.exists(file_path):
        with open(file_path, 'rb') as fh:
            response = HttpResponse(fh.read(), content_type="application/octet-stream")
            response['Content-Disposition'] = f'attachment; filename="{order.payment_link.attachment_name or os.path.basename(file_path)}"'
            return response
    
    messages.error(request, 'Archivo no encontrado en el servidor')
    return redirect('paypal_order_detail', token=order.order_token)


# Vista legacy - mantener compatibilidad (redirige al resumen de orden)
def paypal_file_download(request, token):
    """Redirige a la página de resumen de orden (compatibilidad)"""
    from .models import PayPalPaymentLink
    
    link = get_object_or_404(PayPalPaymentLink, public_token=token)
    
    # Si está pagado, redirigir al resumen
    if link.is_paid():
        return redirect('paypal_order_summary', token=token)
    
    # Si no está pagado, redirigir a la página de pago
    messages.warning(request, 'Debes completar el pago antes de acceder a tu orden')
    return redirect('paypal_payment_page', token=token)


# ============================================
# VISTAS PARA TODO LIST EN TICKETS
# ============================================

@login_required
def ticket_todo_add(request, pk):
    """Agregar un item TODO al ticket"""
    from .models import TodoItem
    
    ticket = get_object_or_404(Ticket, pk=pk)
    
    # Verificar permisos de acceso al ticket
    if not is_agent(request.user):
        user_projects = request.user.assigned_projects.all()
        user_company = getattr(request.user, 'profile', None) and request.user.profile.company
        
        query_conditions = Q(created_by=request.user)
        if user_projects.exists():
            query_conditions |= Q(project__in=user_projects)
        if user_company:
            query_conditions |= Q(company=user_company)
        
        if not Ticket.objects.filter(pk=pk).filter(query_conditions).exists():
            return JsonResponse({'success': False, 'error': 'No tienes permisos'}, status=403)
    
    if request.method == 'POST':
        text = request.POST.get('text', '').strip()
        
        if not text:
            return JsonResponse({'success': False, 'error': 'El texto no puede estar vacío'})
        
        if len(text) > 500:
            return JsonResponse({'success': False, 'error': 'El texto no puede exceder 500 caracteres'})
        
        # Calcular el siguiente orden
        max_order = ticket.todo_items.aggregate(models.Max('order'))['order__max'] or 0
        
        # Crear el item
        todo_item = TodoItem.objects.create(
            ticket=ticket,
            text=text,
            created_by=request.user,
            order=max_order + 1
        )
        
        return JsonResponse({
            'success': True,
            'item': {
                'id': todo_item.id,
                'text': todo_item.text,
                'is_completed': todo_item.is_completed,
                'created_at': todo_item.created_at.strftime('%d/%m/%Y %H:%M'),
                'created_by': todo_item.created_by.get_full_name() or todo_item.created_by.username
            }
        })
    
    return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)


@login_required
def ticket_todo_toggle(request, pk, item_id):
    """Marcar/desmarcar un item TODO como completado"""
    from .models import TodoItem
    
    ticket = get_object_or_404(Ticket, pk=pk)
    todo_item = get_object_or_404(TodoItem, pk=item_id, ticket=ticket)
    
    # Verificar permisos de acceso al ticket
    if not is_agent(request.user):
        user_projects = request.user.assigned_projects.all()
        user_company = getattr(request.user, 'profile', None) and request.user.profile.company
        
        query_conditions = Q(created_by=request.user)
        if user_projects.exists():
            query_conditions |= Q(project__in=user_projects)
        if user_company:
            query_conditions |= Q(company=user_company)
        
        if not Ticket.objects.filter(pk=pk).filter(query_conditions).exists():
            return JsonResponse({'success': False, 'error': 'No tienes permisos'}, status=403)
    
    if request.method == 'POST':
        todo_item.toggle_completed()
        
        return JsonResponse({
            'success': True,
            'is_completed': todo_item.is_completed,
            'completed_at': todo_item.completed_at.strftime('%d/%m/%Y %H:%M') if todo_item.completed_at else None
        })
    
    return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)


@login_required
def ticket_todo_delete(request, pk, item_id):
    """Eliminar un item TODO"""
    from .models import TodoItem
    
    ticket = get_object_or_404(Ticket, pk=pk)
    todo_item = get_object_or_404(TodoItem, pk=item_id, ticket=ticket)
    
    # Verificar permisos de acceso al ticket
    if not is_agent(request.user):
        user_projects = request.user.assigned_projects.all()
        user_company = getattr(request.user, 'profile', None) and request.user.profile.company
        
        query_conditions = Q(created_by=request.user)
        if user_projects.exists():
            query_conditions |= Q(project__in=user_projects)
        if user_company:
            query_conditions |= Q(company=user_company)
        
        if not Ticket.objects.filter(pk=pk).filter(query_conditions).exists():
            return JsonResponse({'success': False, 'error': 'No tienes permisos'}, status=403)
    
    if request.method == 'POST':
        todo_item.delete()
        return JsonResponse({'success': True})
    
    return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)


@login_required
def ticket_todo_generate_ai(request, pk):
    """Generar checklist automáticamente usando IA basado en la descripción del ticket"""
    from .models import TodoItem
    
    ticket = get_object_or_404(Ticket, pk=pk)
    
    # Verificar permisos de acceso al ticket
    if not is_agent(request.user):
        user_projects = request.user.assigned_projects.all()
        user_company = getattr(request.user, 'profile', None) and request.user.profile.company
        
        query_conditions = Q(created_by=request.user)
        if user_projects.exists():
            query_conditions |= Q(project__in=user_projects)
        if user_company:
            query_conditions |= Q(company=user_company)
        
        if not Ticket.objects.filter(pk=pk).filter(query_conditions).exists():
            return JsonResponse({'success': False, 'error': 'No tienes permisos'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    # Verificar que OpenAI esté disponible
    if not OPENAI_AVAILABLE:
        return JsonResponse({
            'success': False, 
            'error': 'OpenAI no está disponible. Por favor, instala la librería.'
        })
    
    # Obtener configuración de OpenAI
    try:
        config = SystemConfiguration.objects.first()
        if not config or not config.openai_api_key:
            return JsonResponse({
                'success': False,
                'error': 'API Key de OpenAI no configurada en el sistema.'
            })
        
        client = OpenAI(api_key=config.openai_api_key)
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': f'Error al conectar con OpenAI: {str(e)}'
        })
    
    try:
        # Construir el prompt para la IA
        prompt = f"""Analiza el siguiente ticket de soporte/desarrollo y genera una lista de tareas (checklist) específicas y accionables para completarlo.

TÍTULO DEL TICKET:
{ticket.title}

DESCRIPCIÓN DEL TICKET:
{ticket.description}

TIPO: {ticket.get_ticket_type_display()}
PRIORIDAD: {ticket.get_priority_display()}
CATEGORÍA: {ticket.category.name if ticket.category else 'Sin categoría'}

INSTRUCCIONES:
1. Genera entre 3 y 8 tareas concretas y accionables
2. Cada tarea debe ser clara, específica y verificable
3. Ordena las tareas de forma lógica (primero lo primero)
4. Usa lenguaje profesional pero conciso
5. Máximo 100 caracteres por tarea
6. NO uses numeración, solo describe la tarea
7. Enfócate en acciones técnicas y específicas del ticket

Responde SOLO con las tareas, una por línea, sin numeración, sin explicaciones adicionales."""

        # Llamar a la API de OpenAI
        response = client.chat.completions.create(
            model=config.openai_model or "gpt-4o-mini",
            messages=[
                {
                    "role": "system",
                    "content": "Eres un asistente experto en gestión de proyectos y desarrollo de software que ayuda a crear checklists detallados y accionables."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            temperature=0.7,
            max_tokens=500
        )
        
        # Procesar la respuesta
        ai_response = response.choices[0].message.content.strip()
        
        # Dividir en líneas y limpiar
        tasks = [line.strip() for line in ai_response.split('\n') if line.strip()]
        
        # Filtrar líneas vacías o muy cortas
        tasks = [task for task in tasks if len(task) > 5]
        
        # Limpiar numeración si existe (1., -, *, etc.)
        import re
        tasks = [re.sub(r'^[\d\.\-\*\•]+\s*', '', task) for task in tasks]
        
        # Limitar a 500 caracteres cada tarea
        tasks = [task[:500] for task in tasks]
        
        # Obtener el máximo orden actual
        max_order = ticket.todo_items.aggregate(models.Max('order'))['order__max'] or 0
        
        # Crear los items TODO
        created_items = []
        for i, task_text in enumerate(tasks, start=1):
            todo_item = TodoItem.objects.create(
                ticket=ticket,
                text=task_text,
                created_by=request.user,
                order=max_order + i,
                is_completed=False
            )
            created_items.append({
                'id': todo_item.id,
                'text': todo_item.text,
                'is_completed': False,
                'created_at': todo_item.created_at.strftime('%d/%m/%Y %H:%M'),
                'created_by': request.user.get_full_name() or request.user.username
            })
        
        return JsonResponse({
            'success': True,
            'items': created_items,
            'count': len(created_items),
            'message': f'Se generaron {len(created_items)} tareas con IA'
        })
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': f'Error al generar checklist: {str(e)}'
        })


# ============================================
# VISTAS PARA GENERADOR DE LIBROS CON IA
# ============================================

@login_required
@user_passes_test(is_agent)
def ai_book_list(request):
    """Lista de libros generados con IA"""
    from .models import AIBook, AIBookChapter
    from django.db.models import Count, Sum, Q, Avg
    
    books = AIBook.objects.all().select_related('created_by', 'company').prefetch_related('chapters')
    
    # Filtros
    status_filter = request.GET.get('status')
    if status_filter:
        books = books.filter(status=status_filter)
    
    # Calcular estadísticas generales
    stats = AIBookChapter.objects.all().aggregate(
        total_chapters=Count('id'),
        completed_chapters=Count('id', filter=Q(status__in=['content_generated', 'completed'])),
        total_words=Sum('word_count'),
        avg_words=Avg('word_count', filter=Q(status__in=['content_generated', 'completed']))
    )
    
    total_chapters = stats['total_chapters'] or 0
    completed_chapters = stats['completed_chapters'] or 0
    total_words = (stats['total_words'] or 0) / 1000  # Convertir a miles
    avg_words_per_chapter = stats['avg_words'] or 0
    
    completion_percentage = int((completed_chapters / total_chapters * 100)) if total_chapters > 0 else 0
    
    # Paginación
    paginator = Paginator(books, 20)
    page_number = request.GET.get('page')
    books_page = paginator.get_page(page_number)
    
    context = {
        'books': books_page,
        'status_filter': status_filter,
        'total_books': books.count(),
        'total_chapters': total_chapters,
        'completed_chapters': completed_chapters,
        'completion_percentage': completion_percentage,
        'total_words': total_words,
        'avg_words_per_chapter': avg_words_per_chapter,
    }
    return render(request, 'tickets/ai_book_list.html', context)


@login_required
@user_passes_test(is_agent)
def ai_book_create(request):
    """Crear nuevo libro con IA - Paso 1: Título y tema"""
    from .models import AIBook
    
    if request.method == 'POST':
        title = request.POST.get('title', '').strip()
        author = request.POST.get('author', '').strip()
        topic = request.POST.get('topic', '').strip()
        company_id = request.POST.get('company')
        
        if not title or not topic:
            messages.error(request, 'El título y el tema son obligatorios')
            return redirect('ai_book_create')
        
        # Crear el libro
        book = AIBook.objects.create(
            title=title,
            author=author,
            topic=topic,
            created_by=request.user,
            company_id=company_id if company_id else None,
            status='draft'
        )
        
        messages.success(request, f'Libro "{book.title}" creado exitosamente')
        return redirect('ai_book_propose_chapters', pk=book.pk)
    
    companies = Company.objects.filter(is_active=True)
    context = {
        'companies': companies,
    }
    return render(request, 'tickets/ai_book_create.html', context)


@login_required
@user_passes_test(is_agent)
def ai_book_propose_chapters(request, pk):
    """Paso 2: Proponer capítulos con IA"""
    from .models import AIBook
    
    book = get_object_or_404(AIBook, pk=pk)
    
    context = {
        'book': book,
    }
    return render(request, 'tickets/ai_book_propose_chapters.html', context)


@login_required
@user_passes_test(is_agent)
def ai_book_generate_chapters_ai(request, pk):
    """AJAX: Generar propuesta de capítulos con IA"""
    from .models import AIBook, AIBookChapter
    
    book = get_object_or_404(AIBook, pk=pk)
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    # Verificar que OpenAI esté disponible
    if not OPENAI_AVAILABLE:
        return JsonResponse({
            'success': False,
            'error': 'OpenAI no está disponible'
        })
    
    try:
        config = SystemConfiguration.objects.first()
        if not config or not config.openai_api_key:
            return JsonResponse({
                'success': False,
                'error': 'API Key de OpenAI no configurada'
            })
        
        client = OpenAI(api_key=config.openai_api_key)
        
        # Prompt para generar capítulos
        prompt = f"""Eres un experto en estructura de libros y contenido editorial.

Genera una estructura de capítulos para un libro con las siguientes características:

TÍTULO: {book.title}
TEMA/DESCRIPCIÓN: {book.topic}

INSTRUCCIONES:
1. Genera entre 8 y 15 capítulos lógicamente estructurados
2. Cada título de capítulo debe ser claro, específico y atractivo
3. Los capítulos deben seguir una progresión lógica del conocimiento
4. Usa títulos profesionales y descriptivos
5. Máximo 100 caracteres por título
6. NO uses numeración, solo los títulos
7. Cubre todos los aspectos importantes del tema

Responde SOLO con los títulos de los capítulos, uno por línea, sin numeración, sin explicaciones adicionales."""

        response = client.chat.completions.create(
            model=config.openai_model or "gpt-4o-mini",
            messages=[
                {
                    "role": "system",
                    "content": "Eres un experto editor y estructurador de libros que crea índices de contenido profesionales y bien organizados."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            temperature=0.8,
            max_tokens=1000
        )
        
        ai_response = response.choices[0].message.content.strip()
        
        # Procesar capítulos
        chapter_titles = [line.strip() for line in ai_response.split('\n') if line.strip()]
        chapter_titles = [title for title in chapter_titles if len(title) > 5]
        
        # Limpiar numeración
        import re
        chapter_titles = [re.sub(r'^[\d\.\-\*\•\)]+\s*', '', title) for title in chapter_titles]
        chapter_titles = [title[:100] for title in chapter_titles]
        
        # Crear capítulos
        chapters_data = []
        for i, title in enumerate(chapter_titles, start=1):
            chapter = AIBookChapter.objects.create(
                book=book,
                title=title,
                order=i,
                status='proposed'
            )
            chapters_data.append({
                'id': chapter.id,
                'order': chapter.order,
                'title': chapter.title,
                'status': chapter.status
            })
        
        # Actualizar estado del libro
        book.status = 'chapters_proposed'
        book.save()
        
        return JsonResponse({
            'success': True,
            'chapters': chapters_data,
            'count': len(chapters_data),
            'message': f'Se generaron {len(chapters_data)} capítulos'
        })
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': f'Error: {str(e)}'
        })


@login_required
@user_passes_test(is_agent)
def ai_book_chapter_edit_title(request, pk, chapter_id):
    """AJAX: Editar título de capítulo"""
    from .models import AIBook, AIBookChapter
    
    book = get_object_or_404(AIBook, pk=pk)
    chapter = get_object_or_404(AIBookChapter, pk=chapter_id, book=book)
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    new_title = request.POST.get('title', '').strip()
    
    if not new_title:
        return JsonResponse({'success': False, 'error': 'El título no puede estar vacío'})
    
    if len(new_title) > 100:
        return JsonResponse({'success': False, 'error': 'El título no puede exceder 100 caracteres'})
    
    chapter.title = new_title
    chapter.save()
    
    return JsonResponse({
        'success': True,
        'title': chapter.title
    })


@login_required
@user_passes_test(is_agent)
def ai_book_chapter_delete(request, pk, chapter_id):
    """AJAX: Eliminar capítulo"""
    from .models import AIBook, AIBookChapter
    
    book = get_object_or_404(AIBook, pk=pk)
    chapter = get_object_or_404(AIBookChapter, pk=chapter_id, book=book)
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    chapter.delete()
    
    # Reordenar capítulos restantes
    remaining_chapters = book.chapters.order_by('order')
    for i, ch in enumerate(remaining_chapters, start=1):
        if ch.order != i:
            ch.order = i
            ch.save()
    
    return JsonResponse({'success': True})


@login_required
@user_passes_test(is_agent)
def ai_book_detail(request, pk):
    """Vista detallada del libro con todos sus capítulos"""
    from .models import AIBook
    
    book = get_object_or_404(AIBook, pk=pk)
    chapters = book.chapters.all().order_by('order')
    
    context = {
        'book': book,
        'chapters': chapters,
    }
    return render(request, 'tickets/ai_book_detail.html', context)


@login_required
@user_passes_test(is_agent)
def ai_book_edit(request, pk):
    """Editar información del libro"""
    from .models import AIBook, Company
    
    book = get_object_or_404(AIBook, pk=pk)
    
    if request.method == 'POST':
        title = request.POST.get('title', '').strip()
        author = request.POST.get('author', '').strip()
        topic = request.POST.get('topic', '').strip()
        company_id = request.POST.get('company', None)
        
        if not title:
            messages.error(request, 'El título es obligatorio')
        elif not topic:
            messages.error(request, 'El tema/descripción es obligatorio')
        else:
            book.title = title
            book.author = author
            book.topic = topic
            
            if company_id:
                try:
                    book.company = Company.objects.get(pk=company_id)
                except Company.DoesNotExist:
                    book.company = None
            else:
                book.company = None
            
            book.save()
            messages.success(request, f'Libro "{book.title}" actualizado exitosamente')
            return redirect('ai_book_detail', pk=book.pk)
    
    companies = Company.objects.all().order_by('name')
    
    context = {
        'book': book,
        'companies': companies,
    }
    return render(request, 'tickets/ai_book_edit.html', context)


@login_required
@user_passes_test(is_agent)
def ai_book_chapter_detail(request, pk, chapter_id):
    """Vista detallada de un capítulo - Editar resumen y generar contenido"""
    from .models import AIBook, AIBookChapter
    
    book = get_object_or_404(AIBook, pk=pk)
    chapter = get_object_or_404(AIBookChapter, pk=chapter_id, book=book)
    
    if request.method == 'POST':
        # Guardar resumen editado
        summary = request.POST.get('summary', '').strip()
        chapter.summary = summary
        if summary:
            chapter.status = 'summary_created'
        chapter.save()
        messages.success(request, 'Resumen guardado exitosamente')
        return redirect('ai_book_chapter_detail', pk=pk, chapter_id=chapter_id)
    
    context = {
        'book': book,
        'chapter': chapter,
    }
    return render(request, 'tickets/ai_book_chapter_detail.html', context)


@login_required
@user_passes_test(is_agent)
def ai_book_chapter_generate_summary(request, pk, chapter_id):
    """AJAX: Generar resumen del capítulo con IA"""
    from .models import AIBook, AIBookChapter
    
    book = get_object_or_404(AIBook, pk=pk)
    chapter = get_object_or_404(AIBookChapter, pk=chapter_id, book=book)
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    if not OPENAI_AVAILABLE:
        return JsonResponse({'success': False, 'error': 'OpenAI no está disponible'})
    
    try:
        config = SystemConfiguration.objects.first()
        if not config or not config.openai_api_key:
            return JsonResponse({'success': False, 'error': 'API Key no configurada'})
        
        client = OpenAI(api_key=config.openai_api_key)
        
        # Obtener contexto de otros capítulos
        all_chapters = book.chapters.order_by('order')
        chapters_context = "\n".join([f"{ch.order}. {ch.title}" for ch in all_chapters])
        
        prompt = f"""Genera un resumen detallado para el siguiente capítulo de un libro.

LIBRO: {book.title}
TEMA DEL LIBRO: {book.topic}

ESTRUCTURA COMPLETA DEL LIBRO:
{chapters_context}

CAPÍTULO A RESUMIR: Capítulo {chapter.order} - {chapter.title}

INSTRUCCIONES:
1. Genera un resumen de 200-300 palabras describiendo lo que tratará este capítulo
2. El resumen debe ser detallado y específico
3. Debe conectar con el flujo lógico del libro
4. Menciona los subtemas principales que se cubrirán
5. Usa un tono profesional pero accesible
6. Enfócate en el valor y aprendizaje que aportará el capítulo

Responde SOLO con el resumen, sin títulos ni encabezados adicionales."""

        response = client.chat.completions.create(
            model=config.openai_model or "gpt-4o-mini",
            messages=[
                {
                    "role": "system",
                    "content": "Eres un experto escritor y editor de libros que crea resúmenes de capítulos detallados y bien estructurados."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            temperature=0.7,
            max_tokens=500
        )
        
        summary = response.choices[0].message.content.strip()
        
        chapter.summary = summary
        chapter.status = 'summary_created'
        chapter.save()
        
        return JsonResponse({
            'success': True,
            'summary': summary
        })
        
    except Exception as e:
        return JsonResponse({'success': False, 'error': f'Error: {str(e)}'})


@login_required
@user_passes_test(is_agent)
def ai_book_chapter_generate_content(request, pk, chapter_id):
    """AJAX: Generar contenido completo del capítulo basado en el resumen"""
    from .models import AIBook, AIBookChapter
    
    book = get_object_or_404(AIBook, pk=pk)
    chapter = get_object_or_404(AIBookChapter, pk=chapter_id, book=book)
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    if not chapter.summary:
        return JsonResponse({'success': False, 'error': 'Primero debes crear un resumen'})
    
    if not OPENAI_AVAILABLE:
        return JsonResponse({'success': False, 'error': 'OpenAI no está disponible'})
    
    try:
        config = SystemConfiguration.objects.first()
        if not config or not config.openai_api_key:
            return JsonResponse({'success': False, 'error': 'API Key no configurada'})
        
        client = OpenAI(api_key=config.openai_api_key)
        
        # Obtener contexto
        all_chapters = book.chapters.order_by('order')
        chapters_context = "\n".join([f"{ch.order}. {ch.title}" for ch in all_chapters])
        
        prompt = f"""Escribe el contenido completo y detallado para el siguiente capítulo de un libro.

LIBRO: {book.title}
TEMA DEL LIBRO: {book.topic}

ESTRUCTURA DEL LIBRO:
{chapters_context}

CAPÍTULO ACTUAL: Capítulo {chapter.order} - {chapter.title}

RESUMEN DEL CAPÍTULO:
{chapter.summary}

INSTRUCCIONES:
1. Escribe un capítulo completo y bien estructurado de aproximadamente 1500-2500 palabras
2. Incluye una introducción atractiva que enganche al lector
3. Desarrolla el contenido en secciones lógicas con subtítulos claros
4. Incluye ejemplos prácticos, casos de uso o analogías cuando sea apropiado
5. Mantén un tono profesional pero accesible y claro
6. Incluye una conclusión que resuma los puntos clave
7. USA TEXTO PLANO sin formato Markdown (sin **, ##, -, etc.)
8. Separa párrafos con doble salto de línea
9. Los subtítulos deben ir en MAYÚSCULAS en su propia línea
10. Asegúrate de que el contenido fluya naturalmente y sea educativo

Responde SOLO con el contenido del capítulo en texto plano."""

        response = client.chat.completions.create(
            model=config.openai_model or "gpt-4o-mini",
            messages=[
                {
                    "role": "system",
                    "content": "Eres un escritor profesional experto en crear contenido educativo de alta calidad, bien estructurado y fácil de entender."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            temperature=0.7,
            max_tokens=4000
        )
        
        content = response.choices[0].message.content.strip()
        
        chapter.content = content
        chapter.status = 'content_generated'
        chapter.save()  # Esto actualizará automáticamente el word_count
        
        # Actualizar el estado del libro si hay capítulos completados
        if book.get_completed_chapters() > 0 and book.status == 'chapters_proposed':
            book.status = 'in_progress'
            book.save()
        
        return JsonResponse({
            'success': True,
            'content': content,
            'word_count': chapter.word_count
        })
        
    except Exception as e:
        return JsonResponse({'success': False, 'error': f'Error: {str(e)}'})


@login_required
@user_passes_test(is_agent)
def ai_book_chapter_save_content(request, pk, chapter_id):
    """AJAX: Guardar contenido editado del capítulo"""
    import json
    from .models import AIBook, AIBookChapter
    
    book = get_object_or_404(AIBook, pk=pk)
    chapter = get_object_or_404(AIBookChapter, pk=chapter_id, book=book)
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        content = data.get('content', '').strip()
        
        if not content:
            return JsonResponse({'success': False, 'error': 'El contenido no puede estar vacío'})
        
        chapter.content = content
        if chapter.status == 'proposed':
            chapter.status = 'content_generated'
        chapter.save()  # Esto actualizará automáticamente el word_count
        
        return JsonResponse({
            'success': True,
            'word_count': chapter.word_count,
            'message': 'Contenido guardado exitosamente'
        })
        
    except json.JSONDecodeError:
        return JsonResponse({'success': False, 'error': 'Datos JSON inválidos'})
    except Exception as e:
        return JsonResponse({'success': False, 'error': f'Error: {str(e)}'})


@login_required
@user_passes_test(is_agent)
def ai_book_chapter_save_summary(request, pk, chapter_id):
    """AJAX: Guardar resumen editado del capítulo"""
    import json
    from .models import AIBook, AIBookChapter
    
    book = get_object_or_404(AIBook, pk=pk)
    chapter = get_object_or_404(AIBookChapter, pk=chapter_id, book=book)
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        summary = data.get('summary', '').strip()
        
        if not summary:
            return JsonResponse({'success': False, 'error': 'El resumen no puede estar vacío'})
        
        chapter.summary = summary
        if chapter.status == 'proposed':
            chapter.status = 'summary_created'
        chapter.save()
        
        return JsonResponse({
            'success': True,
            'message': 'Resumen guardado exitosamente'
        })
        
    except json.JSONDecodeError:
        return JsonResponse({'success': False, 'error': 'Datos JSON inválidos'})
    except Exception as e:
        return JsonResponse({'success': False, 'error': f'Error: {str(e)}'})


@login_required
@user_passes_test(is_agent)
def ai_book_export(request, pk):
    """Exportar libro completo en formato Markdown, DOCX o PDF"""
    from .models import AIBook
    from docx import Document
    from docx.shared import Pt, Inches, RGBColor
    from docx.enum.text import WD_ALIGN_PARAGRAPH
    from docx.oxml.ns import qn
    from docx.oxml import OxmlElement
    from reportlab.lib.pagesizes import letter
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak, Table, TableStyle
    from reportlab.lib.enums import TA_CENTER, TA_JUSTIFY, TA_LEFT
    from reportlab.lib import colors
    from io import BytesIO
    
    book = get_object_or_404(AIBook, pk=pk)
    chapters = book.chapters.filter(status__in=['content_generated', 'completed']).order_by('order')
    
    if not chapters.exists():
        messages.error(request, 'No hay capítulos con contenido generado para exportar')
        return redirect('ai_book_detail', pk=pk)
    
    # Formato para exportar
    export_format = request.GET.get('format', 'docx')
    
    if export_format == 'docx':
        # Crear documento Word
        doc = Document()
        
        # Configurar márgenes
        sections = doc.sections
        for section in sections:
            section.top_margin = Inches(1)
            section.bottom_margin = Inches(1)
            section.left_margin = Inches(1.25)
            section.right_margin = Inches(1.25)
        
        # Portada
        title = doc.add_heading(book.title, 0)
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER
        for run in title.runs:
            run.font.size = Pt(28)
            run.font.color.rgb = RGBColor(44, 62, 80)
        
        doc.add_paragraph()  # Espacio
        
        # Autor (si existe)
        if book.author:
            author_para = doc.add_paragraph(book.author)
            author_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
            author_format = author_para.runs[0].font
            author_format.size = Pt(16)
            author_format.bold = True
            author_format.color.rgb = RGBColor(52, 73, 94)
            doc.add_paragraph()
        
        subtitle = doc.add_paragraph(book.topic)
        subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
        subtitle_format = subtitle.runs[0].font
        subtitle_format.italic = True
        subtitle_format.size = Pt(12)
        subtitle_format.color.rgb = RGBColor(127, 140, 141)
        
        doc.add_page_break()
        
        # Índice
        toc_title = doc.add_heading('Índice', 1)
        for run in toc_title.runs:
            run.font.color.rgb = RGBColor(41, 128, 185)
        
        # Crear tabla para el índice con números de página
        toc_table_data = []
        page_num = 3  # Empieza después de portada e índice
        
        for chapter in chapters:
            toc_table_data.append([
                f'Capítulo {chapter.order}',
                chapter.title,
                str(page_num)
            ])
            # Estimar páginas por capítulo (aprox. 500 palabras por página)
            words_in_chapter = len(chapter.content.split()) if chapter.content else 0
            pages_in_chapter = max(1, words_in_chapter // 500)
            page_num += pages_in_chapter
        
        # Agregar tabla al documento
        table = doc.add_table(rows=len(toc_table_data), cols=3)
        table.style = 'Light Grid Accent 1'
        
        for i, (num, title, page) in enumerate(toc_table_data):
            row = table.rows[i]
            row.cells[0].text = num
            row.cells[1].text = title
            row.cells[2].text = page
            
            # Formatear celdas
            for cell in row.cells:
                for paragraph in cell.paragraphs:
                    for run in paragraph.runs:
                        run.font.size = Pt(11)
        
        doc.add_page_break()
        
        # Contenido de capítulos
        for chapter in chapters:
            # Título del capítulo
            chapter_heading = doc.add_heading(f'Capítulo {chapter.order}', 1)
            for run in chapter_heading.runs:
                run.font.color.rgb = RGBColor(41, 128, 185)
            
            chapter_title = doc.add_heading(chapter.title, 2)
            for run in chapter_title.runs:
                run.font.color.rgb = RGBColor(52, 73, 94)
            
            if chapter.content:
                # Dividir contenido en párrafos
                paragraphs = chapter.content.split('\n\n')
                for para in paragraphs:
                    if para.strip():
                        # Detectar si es un subtítulo (texto en mayúsculas)
                        if para.strip().isupper() and len(para.strip()) < 100:
                            subtitle = doc.add_heading(para.strip(), 3)
                            for run in subtitle.runs:
                                run.font.color.rgb = RGBColor(52, 152, 219)
                        else:
                            p = doc.add_paragraph(para.strip())
                            p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
                            for run in p.runs:
                                run.font.size = Pt(11)
            
            doc.add_page_break()
        
        # Agregar números de página
        for section in doc.sections:
            footer = section.footer
            footer_para = footer.paragraphs[0]
            footer_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
            run = footer_para.add_run()
            fldChar1 = OxmlElement('w:fldChar')
            fldChar1.set(qn('w:fldCharType'), 'begin')
            
            instrText = OxmlElement('w:instrText')
            instrText.set(qn('xml:space'), 'preserve')
            instrText.text = "PAGE"
            
            fldChar2 = OxmlElement('w:fldChar')
            fldChar2.set(qn('w:fldCharType'), 'end')
            
            run._r.append(fldChar1)
            run._r.append(instrText)
            run._r.append(fldChar2)
        
        # Guardar en memoria
        buffer = BytesIO()
        doc.save(buffer)
        buffer.seek(0)
        
        response = HttpResponse(
            buffer.getvalue(),
            content_type='application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        )
        response['Content-Disposition'] = f'attachment; filename="{book.title}.docx"'
        return response
    
    elif export_format == 'pdf':
        # Crear PDF con numeración de páginas
        from reportlab.pdfgen import canvas
        from reportlab.lib.utils import simpleSplit
        
        buffer = BytesIO()
        
        # Función para agregar números de página
        def add_page_number(canvas_obj, doc_obj):
            canvas_obj.saveState()
            canvas_obj.setFont('Helvetica', 9)
            page_num = canvas_obj.getPageNumber()
            text = f"Página {page_num}"
            canvas_obj.drawCentredString(letter[0]/2, 0.5*inch, text)
            canvas_obj.restoreState()
        
        doc = SimpleDocTemplate(
            buffer,
            pagesize=letter,
            rightMargin=72,
            leftMargin=72,
            topMargin=72,
            bottomMargin=50,
        )
        
        # Estilos
        styles = getSampleStyleSheet()
        
        # Estilo personalizado para título
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=28,
            textColor=colors.HexColor('#2c3e50'),
            spaceAfter=30,
            alignment=TA_CENTER,
            fontName='Helvetica-Bold',
        )
        
        # Estilo para subtítulo
        subtitle_style = ParagraphStyle(
            'CustomSubtitle',
            parent=styles['Normal'],
            fontSize=12,
            textColor=colors.HexColor('#7f8c8d'),
            spaceAfter=30,
            alignment=TA_CENTER,
            fontName='Helvetica-Oblique',
        )
        
        # Estilo para títulos de capítulos
        chapter_style = ParagraphStyle(
            'ChapterTitle',
            parent=styles['Heading1'],
            fontSize=20,
            textColor=colors.HexColor('#2980b9'),
            spaceAfter=20,
            spaceBefore=20,
            fontName='Helvetica-Bold',
        )
        
        # Estilo para subtítulos de capítulos
        chapter_subtitle_style = ParagraphStyle(
            'ChapterSubtitle',
            parent=styles['Heading2'],
            fontSize=16,
            textColor=colors.HexColor('#34495e'),
            spaceAfter=15,
            fontName='Helvetica-Bold',
        )
        
        # Estilo para secciones
        section_style = ParagraphStyle(
            'SectionTitle',
            parent=styles['Heading2'],
            fontSize=14,
            textColor=colors.HexColor('#3498db'),
            spaceAfter=12,
            spaceBefore=12,
            fontName='Helvetica-Bold',
        )
        
        # Estilo para autor
        author_style = ParagraphStyle(
            'AuthorStyle',
            parent=styles['Normal'],
            fontSize=16,
            textColor=colors.HexColor('#34495e'),
            spaceAfter=20,
            alignment=TA_CENTER,
            fontName='Helvetica-Bold',
        )
        
        # Estilo para texto normal
        normal_style = ParagraphStyle(
            'CustomNormal',
            parent=styles['Normal'],
            fontSize=11,
            alignment=TA_JUSTIFY,
            spaceAfter=12,
            leading=14,
        )
        
        # Estilo para índice
        toc_style = ParagraphStyle(
            'TOCStyle',
            parent=styles['Normal'],
            fontSize=11,
            spaceAfter=8,
            leftIndent=0,
        )
        
        toc_title_style = ParagraphStyle(
            'TOCTitle',
            parent=styles['Heading1'],
            fontSize=22,
            textColor=colors.HexColor('#2980b9'),
            spaceAfter=20,
            fontName='Helvetica-Bold',
        )
        
        # Contenido del PDF
        story = []
        
        # Portada
        story.append(Spacer(1, 2.5*inch))
        story.append(Paragraph(book.title, title_style))
        story.append(Spacer(1, 0.3*inch))
        
        # Autor (si existe)
        if book.author:
            story.append(Paragraph(book.author, author_style))
            story.append(Spacer(1, 0.3*inch))
        
        story.append(Paragraph(book.topic, subtitle_style))
        story.append(PageBreak())
        
        # Índice con números de página
        story.append(Paragraph('Índice', toc_title_style))
        story.append(Spacer(1, 0.3*inch))
        
        # Crear tabla para índice con dots leaders
        toc_data = []
        for chapter in chapters:
            chapter_text = f'Capítulo {chapter.order}: {chapter.title}'
            toc_data.append([chapter_text, ''])
        
        if toc_data:
            toc_table = Table(toc_data, colWidths=[5*inch, 0.5*inch])
            toc_table.setStyle(TableStyle([
                ('FONT', (0, 0), (-1, -1), 'Helvetica', 11),
                ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#34495e')),
                ('ALIGN', (0, 0), (0, -1), 'LEFT'),
                ('ALIGN', (1, 0), (1, -1), 'RIGHT'),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                ('TOPPADDING', (0, 0), (-1, -1), 4),
            ]))
            story.append(toc_table)
        
        story.append(PageBreak())
        
        # Contenido de capítulos
        for chapter in chapters:
            # Título del capítulo
            story.append(Paragraph(f'Capítulo {chapter.order}', chapter_style))
            story.append(Spacer(1, 0.1*inch))
            story.append(Paragraph(chapter.title, chapter_subtitle_style))
            story.append(Spacer(1, 0.2*inch))
            
            if chapter.content:
                # Dividir contenido en párrafos
                paragraphs = chapter.content.split('\n\n')
                for para in paragraphs:
                    if para.strip():
                        # Detectar si es un subtítulo (texto en mayúsculas)
                        if para.strip().isupper() and len(para.strip()) < 100:
                            story.append(Paragraph(para.strip(), section_style))
                        else:
                            # Escapar caracteres especiales para XML
                            safe_para = para.strip().replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                            story.append(Paragraph(safe_para, normal_style))
            
            story.append(PageBreak())
        
        # Generar PDF con numeración de páginas
        doc.build(story, onFirstPage=add_page_number, onLaterPages=add_page_number)
        buffer.seek(0)
        
        response = HttpResponse(buffer.getvalue(), content_type='application/pdf')
        response['Content-Disposition'] = f'attachment; filename="{book.title}.pdf"'
        return response
    
    elif export_format == 'html':
        # Convertir a HTML (mantenemos esta opción)
        content = f"<h1>{book.title}</h1>\n"
        if book.author:
            content += f"<p class='author'><strong>{book.author}</strong></p>\n"
        content += f"<p><em>{book.topic}</em></p>\n"
        content += "<hr>\n"
        content += "<h2>Índice</h2>\n<ul>\n"
        
        for chapter in chapters:
            content += f'<li><a href="#chapter-{chapter.order}">Capítulo {chapter.order}: {chapter.title}</a></li>\n'
        
        content += "</ul>\n<hr>\n"
        
        for chapter in chapters:
            content += f'<h2 id="chapter-{chapter.order}">Capítulo {chapter.order}: {chapter.title}</h2>\n'
            if chapter.content:
                # Convertir párrafos a HTML
                paragraphs = chapter.content.split('\n\n')
                for para in paragraphs:
                    if para.strip():
                        if para.strip().isupper() and len(para.strip()) < 100:
                            content += f"<h3>{para.strip()}</h3>\n"
                        else:
                            content += f"<p>{para.strip()}</p>\n"
                content += "<hr>\n"
        
        # Crear HTML completo
        html = f"""<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{book.title}</title>
    <style>
        body {{
            font-family: Georgia, serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }}
        h1 {{ color: #2c3e50; text-align: center; }}
        .author {{ color: #34495e; text-align: center; font-size: 1.2em; margin: 10px 0; }}
        h2 {{ color: #34495e; margin-top: 40px; }}
        h3 {{ color: #34495e; margin-top: 20px; }}
        p {{ text-align: justify; }}
        hr {{ margin: 40px 0; border: none; border-top: 2px solid #ecf0f1; }}
        a {{ color: #3498db; text-decoration: none; }}
        a:hover {{ text-decoration: underline; }}
    </style>
</head>
<body>
    {content}
</body>
</html>"""
        
        response = HttpResponse(html, content_type='text/html')
        response['Content-Disposition'] = f'attachment; filename="{book.title}.html"'
        return response
    
    messages.error(request, 'Formato de exportación no válido')
    return redirect('ai_book_detail', pk=pk)


@login_required
@user_passes_test(is_agent)
def ai_book_delete(request, pk):
    """Eliminar libro"""
    from .models import AIBook
    
    book = get_object_or_404(AIBook, pk=pk)
    
    if request.method == 'POST':
        book.delete()
        messages.success(request, f'Libro "{book.title}" eliminado exitosamente')
        return redirect('ai_book_list')
    
    context = {
        'book': book,
    }
    return render(request, 'tickets/ai_book_delete.html', context)


# ============================================
# GENERACIÓN DE ARTÍCULOS CON IA
# ============================================

@login_required
@user_passes_test(is_agent)
def ai_article_project_list(request):
    """Lista de proyectos de artículos con IA"""
    from .models import AIArticleProject, AIArticle
    from django.db.models import Count, Sum, Q, Avg
    
    projects = AIArticleProject.objects.filter(
        created_by=request.user
    ).select_related('company', 'created_by').prefetch_related('articles')
    
    # Calcular estadísticas generales
    stats = AIArticle.objects.filter(project__created_by=request.user).aggregate(
        total_articles=Count('id'),
        generated_articles=Count('id', filter=Q(status__in=['content_generated', 'completed'])),
        total_words=Sum('word_count'),
        avg_words=Avg('word_count', filter=Q(status__in=['content_generated', 'completed']))
    )
    
    total_articles = stats['total_articles'] or 0
    generated_articles = stats['generated_articles'] or 0
    total_words = (stats['total_words'] or 0) / 1000  # Convertir a miles
    avg_words_per_article = stats['avg_words'] or 0
    
    generation_percentage = int((generated_articles / total_articles * 100)) if total_articles > 0 else 0
    
    context = {
        'projects': projects,
        'total_articles': total_articles,
        'generated_articles': generated_articles,
        'generation_percentage': generation_percentage,
        'total_words': total_words,
        'avg_words_per_article': avg_words_per_article,
    }
    return render(request, 'tickets/ai_article_project_list.html', context)


@login_required
@user_passes_test(is_agent)
def ai_article_project_create(request):
    """Crear nuevo proyecto de artículos (Paso 1)"""
    from .models import AIArticleProject, Company
    
    if request.method == 'POST':
        title = request.POST.get('title')
        main_topic = request.POST.get('main_topic')
        content_format = request.POST.get('content_format', 'plain')
        company_id = request.POST.get('company')
        
        if not title or not main_topic:
            messages.error(request, 'El título y el tema principal son obligatorios.')
            return redirect('ai_article_project_create')
        
        project = AIArticleProject.objects.create(
            title=title,
            main_topic=main_topic,
            content_format=content_format,
            created_by=request.user,
            company_id=company_id if company_id else None,
            status='draft'
        )
        
        messages.success(request, f'Proyecto "{project.title}" creado exitosamente.')
        return redirect('ai_article_project_proposals', pk=project.pk)
    
    companies = Company.objects.filter(is_active=True).order_by('name')
    
    context = {
        'companies': companies,
    }
    return render(request, 'tickets/ai_article_project_create.html', context)


@login_required
@user_passes_test(is_agent)
def ai_article_project_proposals(request, pk):
    """Ver propuestas de artículos y generar más (Paso 2)"""
    from .models import AIArticleProject
    
    project = get_object_or_404(AIArticleProject, pk=pk)
    articles = project.articles.all().order_by('order')
    
    context = {
        'project': project,
        'articles': articles,
    }
    return render(request, 'tickets/ai_article_project_proposals.html', context)


@login_required
@user_passes_test(is_agent)
def ai_article_generate_proposals(request, pk):
    """AJAX: Generar 10 propuestas de artículos con IA"""
    import json
    import traceback
    from .models import AIArticleProject, AIArticle, SystemConfiguration
    
    project = get_object_or_404(AIArticleProject, pk=pk)
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        config = SystemConfiguration.get_config()
        
        if not config.openai_api_key:
            return JsonResponse({'success': False, 'error': 'No se ha configurado la API Key de OpenAI'})
        
        # Obtener el número actual de artículos para continuar la numeración
        current_count = project.articles.count()
        
        prompt = f"""Basándote en el siguiente tema principal, propón 10 títulos de artículos interesantes y relevantes.
        
Tema principal: {project.main_topic}

Para cada artículo, proporciona:
1. Un título atractivo y específico
2. 3-5 palabras clave relevantes (separadas por comas)

Formato de respuesta (JSON):
[
  {{"title": "Título del artículo", "keywords": "palabra1, palabra2, palabra3"}},
  ...
]

Responde SOLO con el JSON, sin texto adicional."""
        
        from openai import OpenAI
        client = OpenAI(api_key=config.openai_api_key)
        
        response = client.chat.completions.create(
            model=config.openai_model or "gpt-4o-mini",
            messages=[
                {
                    "role": "system",
                    "content": "Eres un experto en marketing de contenidos y generación de ideas para artículos."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            temperature=0.8,
            max_tokens=2000
        )
        
        response_text = response.choices[0].message.content.strip()
        
        # Limpiar respuesta si viene con markdown
        if response_text.startswith('```'):
            lines = response_text.split('\n')
            # Eliminar primera línea con ```json y última con ```
            response_text = '\n'.join(lines[1:-1]).strip()
        
        proposals = json.loads(response_text)
        
        # Crear los artículos propuestos
        created_articles = []
        for i, proposal in enumerate(proposals[:10]):  # Limitar a 10
            article = AIArticle.objects.create(
                project=project,
                title=proposal.get('title', ''),
                keywords=proposal.get('keywords', ''),
                order=current_count + i + 1,
                status='proposed'
            )
            created_articles.append({
                'id': article.id,
                'title': article.title,
                'keywords': article.keywords,
                'order': article.order
            })
        
        # Actualizar estado del proyecto
        if project.status == 'draft':
            project.status = 'articles_proposed'
            project.save()
        
        return JsonResponse({
            'success': True,
            'articles': created_articles,
            'total_articles': project.articles.count()
        })
        
    except json.JSONDecodeError as e:
        return JsonResponse({'success': False, 'error': f'Error al procesar JSON de la IA: {str(e)}'})
    except Exception as e:
        error_trace = traceback.format_exc()
        print(f"Error en ai_article_generate_proposals: {error_trace}")
        return JsonResponse({'success': False, 'error': f'Error: {str(e)}'})


@login_required
@user_passes_test(is_agent)
def ai_article_edit_keywords(request, pk, article_id):
    """AJAX: Editar palabras clave de un artículo"""
    import json
    from .models import AIArticleProject, AIArticle
    
    project = get_object_or_404(AIArticleProject, pk=pk)
    article = get_object_or_404(AIArticle, pk=article_id, project=project)
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        keywords = data.get('keywords', '').strip()
        
        article.keywords = keywords
        article.save()
        
        return JsonResponse({
            'success': True,
            'keywords': article.keywords
        })
        
    except Exception as e:
        return JsonResponse({'success': False, 'error': f'Error: {str(e)}'})


@login_required
@user_passes_test(is_agent)
def ai_article_generate_content(request, pk, article_id):
    """AJAX: Generar contenido del artículo con IA"""
    import json
    import traceback
    from .models import AIArticleProject, AIArticle, SystemConfiguration
    
    project = get_object_or_404(AIArticleProject, pk=pk)
    article = get_object_or_404(AIArticle, pk=article_id, project=project)
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        config = SystemConfiguration.get_config()
        
        if not config.openai_api_key:
            return JsonResponse({'success': False, 'error': 'No se ha configurado la API Key de OpenAI'})
        
        keywords_text = f"\nPalabras clave a incluir: {article.keywords}" if article.keywords else ""
        
        # Ajustar el prompt según el formato del proyecto
        if project.content_format == 'markdown':
            format_instructions = """1. Usa formato Markdown para estructurar el contenido
2. Usa # para el título principal, ## para subtítulos, ### para sub-secciones
3. Usa **texto** para negritas y *texto* para cursivas
4. Usa listas numeradas o con viñetas donde sea apropiado
5. Usa bloques de código ```código``` si es necesario"""
        else:  # plain text
            format_instructions = """1. Escribe en texto plano (NO uses formato Markdown)
2. Los subtítulos deben estar EN MAYÚSCULAS
3. Usa párrafos bien estructurados
4. No uses símbolos especiales de formato (*, #, etc.)"""
        
        prompt = f"""Escribe un artículo completo y detallado sobre el siguiente tema:

Título: {article.title}
Contexto general: {project.main_topic}{keywords_text}

REQUISITOS IMPORTANTES DE FORMATO:
{format_instructions}

REQUISITOS DE CONTENIDO:
- Incluye introduccción, desarrollo y conclusión
- Longitud: Entre 800-1500 palabras
- Tono profesional pero accesible
- Incluye ejemplos prácticos cuando sea posible

El artículo debe ser informativo, bien investigado y de alta calidad."""
        
        from openai import OpenAI
        client = OpenAI(api_key=config.openai_api_key)
        
        response = client.chat.completions.create(
            model=config.openai_model or "gpt-4o-mini",
            messages=[
                {
                    "role": "system",
                    "content": "Eres un redactor profesional experto en crear artículos de alta calidad, bien estructurados y optimizados para SEO."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            temperature=0.7,
            max_tokens=4000
        )
        
        content = response.choices[0].message.content.strip()
        
        article.content = content
        article.status = 'content_generated'
        article.save()  # Esto actualizará automáticamente el word_count
        
        # Actualizar progreso del proyecto
        if project.get_completed_articles() > 0 and project.status == 'articles_proposed':
            project.status = 'in_progress'
            project.save()
        
        return JsonResponse({
            'success': True,
            'content': content,
            'word_count': article.word_count
        })
        
    except Exception as e:
        error_trace = traceback.format_exc()
        print(f"Error en ai_article_generate_content: {error_trace}")
        return JsonResponse({'success': False, 'error': f'Error: {str(e)}'})


@login_required
@user_passes_test(is_agent)
def ai_article_detail(request, pk, article_id):
    """Ver detalle de un artículo"""
    from .models import AIArticleProject, AIArticle
    
    project = get_object_or_404(AIArticleProject, pk=pk)
    article = get_object_or_404(AIArticle, pk=article_id, project=project)
    
    context = {
        'project': project,
        'article': article,
    }
    return render(request, 'tickets/ai_article_detail.html', context)


@login_required
@user_passes_test(is_agent)
def ai_article_delete(request, pk, article_id):
    """Eliminar un artículo propuesto"""
    from .models import AIArticleProject, AIArticle
    
    project = get_object_or_404(AIArticleProject, pk=pk)
    article = get_object_or_404(AIArticle, pk=article_id, project=project)
    
    if request.method == 'POST':
        article.delete()
        messages.success(request, 'Artículo eliminado exitosamente.')
        return redirect('ai_article_project_proposals', pk=project.pk)
    
    context = {
        'project': project,
        'article': article,
    }
    return render(request, 'tickets/ai_article_delete.html', context)


@login_required
@user_passes_test(is_agent)
def ai_article_project_edit(request, pk):
    """Editar un proyecto de artículos"""
    from .models import AIArticleProject, Company
    
    project = get_object_or_404(AIArticleProject, pk=pk)
    
    if request.method == 'POST':
        project.title = request.POST.get('title')
        project.main_topic = request.POST.get('main_topic')
        project.content_format = request.POST.get('content_format', 'plain')
        company_id = request.POST.get('company')
        project.company_id = company_id if company_id else None
        project.save()
        
        messages.success(request, f'Proyecto "{project.title}" actualizado exitosamente.')
        return redirect('ai_article_project_proposals', pk=project.pk)
    
    companies = Company.objects.filter(is_active=True).order_by('name')
    
    context = {
        'project': project,
        'companies': companies,
    }
    return render(request, 'tickets/ai_article_project_edit.html', context)


@login_required
@user_passes_test(is_agent)
def ai_article_project_delete(request, pk):
    """Eliminar un proyecto completo"""
    from .models import AIArticleProject
    
    project = get_object_or_404(AIArticleProject, pk=pk)
    
    if request.method == 'POST':
        title = project.title
        project.delete()
        messages.success(request, f'Proyecto "{title}" eliminado exitosamente.')
        return redirect('ai_article_project_list')
    
    context = {
        'project': project,
    }
    return render(request, 'tickets/ai_article_project_delete.html', context)


@csrf_exempt
@require_http_methods(["POST"])
def landing_page_meeting_click(request, slug):
    """
    Incrementa el contador de clics del botón "Planificar Reunión"
    """
    try:
        from django.db import transaction
        
        # Buscar la landing page por slug
        landing_page = get_object_or_404(LandingPage, slug=slug, is_active=True)
        
        # Incrementar el contador de clics de reunión de forma atómica
        with transaction.atomic():
            landing_page.meeting_button_clicks += 1
            landing_page.save(update_fields=['meeting_button_clicks'])
        
        return JsonResponse({
            'success': True,
            'meeting_clicks': landing_page.meeting_button_clicks
        })
        
    except Exception as e:
        return JsonResponse({
            'error': f'Error al incrementar contador: {str(e)}'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def landing_page_contact_click(request, slug):
    """
    Incrementa el contador de clics del botón "Contactar"
    """
    try:
        from django.db import transaction
        
        # Buscar la landing page por slug
        landing_page = get_object_or_404(LandingPage, slug=slug, is_active=True)
        
        # Incrementar el contador de clics de contacto de forma atómica
        with transaction.atomic():
            landing_page.contact_button_clicks += 1
            landing_page.save(update_fields=['contact_button_clicks'])
        
        return JsonResponse({
            'success': True,
            'contact_clicks': landing_page.contact_button_clicks
        })
        
    except Exception as e:
        return JsonResponse({
            'error': f'Error al incrementar contador: {str(e)}'
        }, status=500)


# ============================================
# VISTAS DE SOLICITUDES DE EMPLEADOS
# ============================================

@login_required
def employee_request_list(request):
    """Vista para listar las solicitudes de empleados"""
    from .models import EmployeeRequest
    from django.db import models
    
    # Filtros básicos
    status_filter = request.GET.get('status', '')
    search = request.GET.get('search', '')
    
    # Query base
    requests = EmployeeRequest.objects.all()
    
    # Si no es agente/admin, solo puede ver sus propias solicitudes
    if not (request.user.is_staff or request.user.groups.filter(name='Agentes').exists()):
        requests = requests.filter(created_by=request.user)
    
    # Aplicar filtros
    if status_filter:
        requests = requests.filter(status=status_filter)
    
    if search:
        requests = requests.filter(
            models.Q(title__icontains=search) | 
            models.Q(text__icontains=search) |
            models.Q(sequence__icontains=search)
        )
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(requests, 15)
    page = request.GET.get('page')
    requests = paginator.get_page(page)
    
    context = {
        'requests': requests,
        'status_filter': status_filter,
        'search': search,
        'status_choices': EmployeeRequest.STATUS_CHOICES,
    }
    
    return render(request, 'tickets/employee_request_list.html', context)


@login_required
def employee_request_create(request):
    """Vista para crear una nueva solicitud de empleado"""
    from .forms import EmployeeRequestForm
    
    if request.method == 'POST':
        form = EmployeeRequestForm(request.POST, user=request.user)
        if form.is_valid():
            request_instance = form.save(commit=False)
            request_instance.created_by = request.user
            request_instance.save()
            messages.success(request, f'Solicitud #{request_instance.sequence} creada correctamente.')
            return redirect('employee_request_detail', pk=request_instance.pk)
    else:
        form = EmployeeRequestForm(user=request.user)
    
    context = {
        'form': form,
        'page_title': 'Nueva Solicitud de Empleado',
        'is_create': True,
    }
    
    return render(request, 'tickets/employee_request_form.html', context)


@login_required
def employee_request_detail(request, pk):
    """Vista para ver el detalle de una solicitud de empleado"""
    from .models import EmployeeRequest
    
    employee_request = get_object_or_404(EmployeeRequest, pk=pk)
    
    # Verificar permisos
    if not (request.user.is_staff or 
            request.user.groups.filter(name='Agentes').exists() or 
            employee_request.created_by == request.user):
        messages.error(request, 'No tienes permisos para ver esta solicitud.')
        return redirect('employee_request_list')
    
    context = {
        'request_instance': employee_request,
        'page_title': f'Solicitud #{employee_request.sequence}',
    }
    
    return render(request, 'tickets/employee_request_detail.html', context)


@login_required
def employee_request_edit(request, pk):
    """Vista para editar una solicitud de empleado"""
    from .models import EmployeeRequest
    from .forms import EmployeeRequestForm
    
    employee_request = get_object_or_404(EmployeeRequest, pk=pk)
    
    # Verificar permisos de edición
    can_edit = (
        request.user.is_staff or 
        request.user.groups.filter(name='Agentes').exists() or 
        (employee_request.created_by == request.user and employee_request.status == 'draft')
    )
    
    if not can_edit:
        messages.error(request, 'No tienes permisos para editar esta solicitud.')
        return redirect('employee_request_detail', pk=pk)
    
    if request.method == 'POST':
        form = EmployeeRequestForm(request.POST, instance=employee_request, user=request.user)
        if form.is_valid():
            form.save()
            messages.success(request, f'Solicitud #{employee_request.sequence} actualizada correctamente.')
            return redirect('employee_request_detail', pk=pk)
    else:
        form = EmployeeRequestForm(instance=employee_request, user=request.user)
    
    context = {
        'form': form,
        'request_instance': employee_request,
        'page_title': f'Editar Solicitud #{employee_request.sequence}',
        'is_create': False,
    }
    
    return render(request, 'tickets/employee_request_form.html', context)


@login_required
def employee_request_delete(request, pk):
    """Vista para eliminar una solicitud de empleado"""
    from .models import EmployeeRequest
    
    employee_request = get_object_or_404(EmployeeRequest, pk=pk)
    
    # Solo el creador o agentes/admin pueden eliminar
    can_delete = (
        request.user.is_staff or 
        request.user.groups.filter(name='Agentes').exists() or 
        (employee_request.created_by == request.user and employee_request.status == 'draft')
    )
    
    if not can_delete:
        messages.error(request, 'No tienes permisos para eliminar esta solicitud.')
        return redirect('employee_request_detail', pk=pk)
    
    if request.method == 'POST':
        sequence = employee_request.sequence
        employee_request.delete()
        messages.success(request, f'Solicitud #{sequence} eliminada correctamente.')
        return redirect('employee_request_list')
    
    context = {
        'request_instance': employee_request,
        'page_title': f'Eliminar Solicitud #{employee_request.sequence}',
    }
    
    return render(request, 'tickets/employee_request_delete.html', context)


@login_required
def employee_dashboard(request):
    """Vista del dashboard para empleados con métricas de productividad"""
    from django.db.models import Count, Sum, Q
    from datetime import datetime, timedelta
    from django.utils import timezone
    from .utils import is_agent
    
    # Verificar si el usuario puede ver el dashboard de otros empleados
    can_view_others = (
        request.user.is_staff or 
        request.user.is_superuser or 
        is_agent(request.user)
    )
    
    # Obtener el empleado seleccionado
    selected_employee_id = request.GET.get('employee_id')
    selected_employee = request.user  # Por defecto, el usuario actual
    
    if selected_employee_id and can_view_others:
        try:
            selected_employee = User.objects.get(id=selected_employee_id)
        except User.DoesNotExist:
            messages.warning(request, 'El empleado seleccionado no existe.')
            selected_employee = request.user
    elif selected_employee_id and not can_view_others:
        messages.warning(request, 'No tienes permisos para ver el dashboard de otros empleados.')
    
    # Obtener lista de empleados para el selector (solo si puede ver otros)
    available_employees = []
    if can_view_others:
        # Obtener usuarios que son empleados (tienen registros de tiempo o están en grupo de agentes)
        employee_users = User.objects.filter(
            Q(time_entries__isnull=False) | 
            Q(groups__name='Agentes') |
            Q(is_staff=True)
        ).distinct().order_by('first_name', 'last_name', 'username')
        
        available_employees = employee_users
    
    # Obtener fechas para los períodos
    now = timezone.now()
    today = now.date()
    week_start = today - timedelta(days=today.weekday())  # Lunes de esta semana
    month_start = today.replace(day=1)  # Primer día del mes actual
    
    # Métricas de horas trabajadas
    # Horas del día actual
    today_entries = TimeEntry.objects.filter(
        user=selected_employee,
        fecha_entrada__date=today,
        fecha_salida__isnull=False
    )
    
    hours_today = 0
    for entry in today_entries:
        if entry.fecha_salida:
            duration = entry.fecha_salida - entry.fecha_entrada
            hours_today += duration.total_seconds() / 3600
    
    # Horas de la semana actual
    week_entries = TimeEntry.objects.filter(
        user=selected_employee,
        fecha_entrada__date__gte=week_start,
        fecha_entrada__date__lte=today,
        fecha_salida__isnull=False
    )
    
    hours_week = 0
    for entry in week_entries:
        if entry.fecha_salida:
            duration = entry.fecha_salida - entry.fecha_entrada
            hours_week += duration.total_seconds() / 3600
    
    # Horas del mes actual
    month_entries = TimeEntry.objects.filter(
        user=selected_employee,
        fecha_entrada__date__gte=month_start,
        fecha_entrada__date__lte=today,
        fecha_salida__isnull=False
    )
    
    hours_month = 0
    for entry in month_entries:
        if entry.fecha_salida:
            duration = entry.fecha_salida - entry.fecha_entrada
            hours_month += duration.total_seconds() / 3600
    
    # Contactos creados en el mes
    contacts_month = Contact.objects.filter(
        created_by=selected_employee,
        created_at__date__gte=month_start
    ).count()
    
    # Oportunidades creadas en el mes
    opportunities_month = Opportunity.objects.filter(
        assigned_to=selected_employee,
        created_at__date__gte=month_start
    ).count()
    
    # Tickets creados en el mes
    tickets_month = Ticket.objects.filter(
        Q(created_by=selected_employee) | Q(assigned_to=selected_employee),
        created_at__date__gte=month_start
    ).count()
    
    # Reuniones con Gerente IA en el mes
    ai_meetings_month = AIManagerMeeting.objects.filter(
        user=selected_employee,
        created_at__date__gte=month_start
    ).count()
    
    # KPIs de Ausencias
    from .models import EmployeeAbsence
    
    # Ausencias de la semana en horas
    week_absences = EmployeeAbsence.objects.filter(
        employee=selected_employee,
        start_date__gte=week_start,
        start_date__lte=today,
        status='approved'
    )
    
    absence_hours_week = 0
    for absence in week_absences:
        # Calcular días de ausencia que caen en esta semana
        absence_start = max(absence.start_date, week_start)
        absence_end = min(absence.end_date, today)
        if absence_start <= absence_end:
            absence_days = (absence_end - absence_start).days + 1
            absence_hours_week += absence_days * 8  # Asumiendo 8 horas por día
    
    # Ausencias del mes en horas
    month_absences = EmployeeAbsence.objects.filter(
        employee=selected_employee,
        start_date__gte=month_start,
        start_date__lte=today,
        status='approved'
    )
    
    absence_hours_month = 0
    for absence in month_absences:
        # Calcular días de ausencia que caen en este mes
        absence_start = max(absence.start_date, month_start)
        absence_end = min(absence.end_date, today)
        if absence_start <= absence_end:
            absence_days = (absence_end - absence_start).days + 1
            absence_hours_month += absence_days * 8  # Asumiendo 8 horas por día
    
    # Ausencias totales en horas (todas las ausencias aprobadas)
    total_absences = EmployeeAbsence.objects.filter(
        employee=selected_employee,
        status='approved'
    )
    
    absence_hours_total = 0
    for absence in total_absences:
        absence_days = (absence.end_date - absence.start_date).days + 1
        absence_hours_total += absence_days * 8  # Asumiendo 8 horas por día
    
    # Datos para gráficos (últimos 7 días)
    chart_data = []
    for i in range(7):
        day = today - timedelta(days=i)
        day_entries = TimeEntry.objects.filter(
            user=selected_employee,
            fecha_entrada__date=day,
            fecha_salida__isnull=False
        )
        
        day_hours = 0
        for entry in day_entries:
            if entry.fecha_salida:
                duration = entry.fecha_salida - entry.fecha_entrada
                day_hours += duration.total_seconds() / 3600
        
        chart_data.append({
            'date': day.strftime('%d/%m'),
            'hours': round(day_hours, 2)
        })
    
    chart_data.reverse()  # Para mostrar de más antiguo a más reciente
    
    # Obtener información del clima
    weather_info = None
    try:
        # Obtener la ubicación del empleado seleccionado
        profile = getattr(selected_employee, 'profile', None)
        if profile:
            city = profile.city or 'Valencia'
            country_code = profile.country_code or 'ES'
        else:
            city = 'Valencia'
            country_code = 'ES'
        
        from .utils import get_weather_info
        weather_info = get_weather_info(city, country_code)
    except Exception as e:
        # Si hay error, usar valores por defecto
        weather_info = {
            'city': 'Valencia',
            'temperature': '--',
            'description': 'No disponible',
            'icon': 'bi-exclamation-triangle',
            'success': False
        }
    
    context = {
        'page_title': f'Dashboard de Empleado - {selected_employee.get_full_name() or selected_employee.username}',
        'hours_today': round(hours_today, 2),
        'hours_week': round(hours_week, 2),
        'hours_month': round(hours_month, 2),
        'absence_hours_week': round(absence_hours_week, 2),
        'absence_hours_month': round(absence_hours_month, 2),
        'absence_hours_total': round(absence_hours_total, 2),
        'contacts_month': contacts_month,
        'opportunities_month': opportunities_month,
        'tickets_month': tickets_month,
        'ai_meetings_month': ai_meetings_month,
        'chart_data': chart_data,
        'current_user': request.user,
        'selected_employee': selected_employee,
        'available_employees': available_employees,
        'can_view_others': can_view_others,
        'today': today,
        'week_start': week_start,
        'month_start': month_start,
        'weather_info': weather_info,
    }
    
    return render(request, 'tickets/employee_dashboard.html', context)


# ===================================================
# VISTAS PARA ACUERDOS INTERNOS
# ===================================================

@login_required
def internal_agreement_list(request):
    """Vista para listar los acuerdos internos"""
    from .models import InternalAgreement
    from django.db import models
    from .utils import is_agent
    
    # Solo agentes y administradores pueden acceder
    if not (is_agent(request.user) or request.user.is_staff):
        messages.error(request, 'No tienes permisos para acceder a esta sección.')
        return redirect('dashboard')
    
    # Filtros básicos
    status_filter = request.GET.get('status', '')
    type_filter = request.GET.get('type', '')
    priority_filter = request.GET.get('priority', '')
    search = request.GET.get('search', '')
    
    # Query base
    agreements = InternalAgreement.objects.all()
    
    # Aplicar filtros
    if status_filter:
        agreements = agreements.filter(status=status_filter)
    
    if type_filter:
        agreements = agreements.filter(agreement_type=type_filter)
    
    if priority_filter:
        agreements = agreements.filter(priority=priority_filter)
    
    if search:
        agreements = agreements.filter(
            models.Q(title__icontains=search) | 
            models.Q(description__icontains=search) |
            models.Q(content__icontains=search) |
            models.Q(tags__icontains=search) |
            models.Q(sequence__icontains=search)
        )
    
    # Optimizar consultas
    agreements = agreements.select_related('created_by', 'approved_by')
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(agreements, 15)
    page = request.GET.get('page')
    agreements_page = paginator.get_page(page)
    
    # Agregar información de permisos a cada acuerdo
    for agreement in agreements_page:
        agreement.user_can_edit = agreement.can_edit(request.user)
        agreement.user_can_delete = agreement.can_delete(request.user)
    
    context = {
        'agreements': agreements_page,
        'status_filter': status_filter,
        'type_filter': type_filter,
        'priority_filter': priority_filter,
        'search': search,
        'status_choices': InternalAgreement.STATUS_CHOICES,
        'type_choices': InternalAgreement.TYPE_CHOICES,
        'priority_choices': InternalAgreement.PRIORITY_CHOICES,
    }
    
    return render(request, 'tickets/internal_agreement_list.html', context)


@login_required
def internal_agreement_create(request):
    """Vista para crear un nuevo acuerdo interno"""
    from .forms import InternalAgreementForm
    from .utils import is_agent
    
    # Solo agentes y administradores pueden crear
    if not (is_agent(request.user) or request.user.is_staff):
        messages.error(request, 'No tienes permisos para crear acuerdos internos.')
        return redirect('internal_agreement_list')
    
    if request.method == 'POST':
        form = InternalAgreementForm(request.POST, user=request.user)
        if form.is_valid():
            agreement = form.save(commit=False)
            agreement.created_by = request.user
            agreement.save()
            messages.success(request, f'Acuerdo Interno #{agreement.sequence} creado correctamente.')
            return redirect('internal_agreement_detail', pk=agreement.pk)
    else:
        form = InternalAgreementForm(user=request.user)
    
    context = {
        'form': form,
        'page_title': 'Nuevo Acuerdo Interno',
        'is_create': True,
    }
    
    return render(request, 'tickets/internal_agreement_form.html', context)


@login_required
def internal_agreement_detail(request, pk):
    """Vista para ver el detalle de un acuerdo interno"""
    from .models import InternalAgreement
    from .utils import is_agent
    
    # Solo agentes y administradores pueden ver
    if not (is_agent(request.user) or request.user.is_staff):
        messages.error(request, 'No tienes permisos para ver los acuerdos internos.')
        return redirect('dashboard')
    
    agreement = get_object_or_404(InternalAgreement, pk=pk)
    
    # Procesar etiquetas
    tags_list = []
    if agreement.tags:
        tags_list = [tag.strip() for tag in agreement.tags.split(',') if tag.strip()]
    
    context = {
        'agreement': agreement,
        'tags_list': tags_list,
        'page_title': f'Acuerdo #{agreement.sequence}',
        'can_edit': agreement.can_edit(request.user),
        'can_delete': agreement.can_delete(request.user),
        'can_sign_user': (agreement.signer_1 == request.user and not agreement.signer_1_date) or 
                        (agreement.signer_2 == request.user and not agreement.signer_2_date),
    }
    
    return render(request, 'tickets/internal_agreement_detail.html', context)


@login_required
def internal_agreement_edit(request, pk):
    """Vista para editar un acuerdo interno"""
    from .models import InternalAgreement
    from .forms import InternalAgreementForm
    from .utils import is_agent
    
    agreement = get_object_or_404(InternalAgreement, pk=pk)
    
    # Verificar permisos de edición
    if not agreement.can_edit(request.user):
        messages.error(request, 'No tienes permisos para editar este acuerdo.')
        return redirect('internal_agreement_detail', pk=pk)
    
    if request.method == 'POST':
        form = InternalAgreementForm(request.POST, instance=agreement, user=request.user)
        if form.is_valid():
            # Verificar si se está cambiando el estado que requiere aprobación/rechazo
            old_status = agreement.status
            agreement = form.save()
            
            # Si cambió a activo, aprobado y no tenía aprobación, registrar aprobación
            if (old_status not in ['active', 'approved'] and agreement.status in ['active', 'approved'] and 
                not agreement.approved_by):
                agreement.approved_by = request.user
                from django.utils import timezone
                agreement.approved_date = timezone.now()
                agreement.save()
                
            # Si se rechazó, limpiar datos de aprobación
            elif agreement.status == 'rejected':
                agreement.approved_by = None
                agreement.approved_date = None
                agreement.save()
            
            messages.success(request, f'Acuerdo #{agreement.sequence} actualizado correctamente.')
            return redirect('internal_agreement_detail', pk=pk)
    else:
        form = InternalAgreementForm(instance=agreement, user=request.user)
    
    context = {
        'form': form,
        'agreement': agreement,
        'page_title': f'Editar Acuerdo #{agreement.sequence}',
        'is_create': False,
    }
    
    return render(request, 'tickets/internal_agreement_form.html', context)


@login_required
def internal_agreement_delete(request, pk):
    """Vista para eliminar un acuerdo interno"""
    from .models import InternalAgreement
    
    agreement = get_object_or_404(InternalAgreement, pk=pk)
    
    # Verificar permisos de eliminación
    if not agreement.can_delete(request.user):
        messages.error(request, 'No tienes permisos para eliminar este acuerdo.')
        return redirect('internal_agreement_detail', pk=pk)
    
    if request.method == 'POST':
        sequence = agreement.sequence
        agreement.delete()
        messages.success(request, f'Acuerdo #{sequence} eliminado correctamente.')
        return redirect('internal_agreement_list')
    
    context = {
        'agreement': agreement,
        'page_title': f'Eliminar Acuerdo #{agreement.sequence}',
    }
    
    return render(request, 'tickets/internal_agreement_confirm_delete.html', context)


@login_required
def internal_agreement_sign(request, pk):
    """Vista para firmar un acuerdo interno"""
    from .models import InternalAgreement
    from .utils import is_agent
    from django.utils import timezone
    
    # Solo agentes y administradores pueden firmar
    if not (is_agent(request.user) or request.user.is_staff):
        messages.error(request, 'No tienes permisos para firmar acuerdos internos.')
        return redirect('dashboard')
    
    agreement = get_object_or_404(InternalAgreement, pk=pk)
    
    if request.method == 'POST':
        signer_number = request.POST.get('signer_number')
        
        try:
            signer_number = int(signer_number)
            if signer_number not in [1, 2]:
                raise ValueError("Número de firmante inválido")
        except (ValueError, TypeError):
            messages.error(request, 'Número de firmante inválido.')
            return redirect('internal_agreement_detail', pk=pk)
        
        # Verificar si el usuario puede firmar
        if not agreement.can_sign(request.user, signer_number):
            messages.error(request, 'No tienes permisos para firmar como este firmante o ya has firmado.')
            return redirect('internal_agreement_detail', pk=pk)
        
        # Firmar el acuerdo
        success = agreement.sign_agreement(request.user, signer_number)
        
        if success:
            # Obtener la fecha/hora de la firma
            if signer_number == 1:
                signature_date = agreement.signer_1_date
            else:
                signature_date = agreement.signer_2_date
            
            # Mensaje de éxito con fecha y hora
            formatted_date = signature_date.strftime("%d/%m/%Y a las %H:%M")
            signer_role = "primer" if signer_number == 1 else "segundo"
            
            messages.success(
                request, 
                f'¡Firma registrada exitosamente! Has firmado el acuerdo como {signer_role} firmante '
                f'el {formatted_date}.'
            )
            
            # Verificar si el acuerdo está completamente firmado
            if agreement.is_fully_signed():
                messages.info(
                    request,
                    f'🎉 ¡El acuerdo está completamente firmado! Todos los firmantes requeridos han confirmado su firma.'
                )
        else:
            messages.error(request, 'No se pudo completar la firma. Verifica que tengas permisos.')
        
        return redirect('internal_agreement_detail', pk=pk)
    
    # Si no es POST, redirigir al detalle
    return redirect('internal_agreement_detail', pk=pk)


@login_required
def ticket_print_preview(request, ticket_id):
    """Vista para obtener vista previa de ticket para impresión"""
    from django.http import JsonResponse
    from .models import Ticket
    
    try:
        ticket = get_object_or_404(Ticket, id=ticket_id)
        
        # Verificar permisos - solo puede ver tickets asignados a él o que ha creado
        if not (ticket.assigned_to == request.user or ticket.created_by == request.user or request.user.is_staff):
            return JsonResponse({
                'success': False,
                'message': 'No tienes permisos para ver este ticket'
            })
        
        # Preparar datos del ticket
        ticket_data = {
            'title': ticket.title,
            'created_at': ticket.created_at.strftime('%d/%m/%Y %H:%M'),
            'created_by': ticket.created_by.get_full_name() or ticket.created_by.username,
            'status': ticket.get_status_display(),
            'category': ticket.category.name if ticket.category else 'Sin categoría',
        }
        
        return JsonResponse({
            'success': True,
            'ticket': ticket_data
        })
        
    except Ticket.DoesNotExist:
        return JsonResponse({
            'success': False,
            'message': 'Ticket no encontrado'
        })
    except Exception as e:
        return JsonResponse({
            'success': False,
            'message': 'Error al cargar el ticket'
        })


@login_required
def ticket_print(request, ticket_id):
    """Vista para imprimir ticket con campos específicos"""
    from .models import Ticket
    
    try:
        ticket = get_object_or_404(Ticket, id=ticket_id)
        
        # Verificar permisos - solo puede imprimir tickets asignados a él o que ha creado
        if not (ticket.assigned_to == request.user or ticket.created_by == request.user or request.user.is_staff):
            messages.error(request, 'No tienes permisos para imprimir este ticket.')
            return redirect('employee_dashboard')
        
        context = {
            'ticket': ticket,
        }
        
        return render(request, 'tickets/ticket_print.html', context)
        
    except Ticket.DoesNotExist:
        messages.error(request, 'Ticket no encontrado.')
        return redirect('employee_dashboard')
    except Exception as e:
        messages.error(request, 'Error al cargar el ticket para impresión.')
        return redirect('employee_dashboard')


@login_required
def ticket_print_pdf(request, pk):
    """Vista para generar PDF del ticket"""
    from django.http import HttpResponse
    from reportlab.lib.pagesizes import A4
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.lib.colors import Color, black, white, blue
    from reportlab.lib import colors
    from io import BytesIO
    from .models import Ticket
    import datetime
    
    try:
        ticket = get_object_or_404(Ticket, pk=pk)
        
        # Verificar permisos - solo puede generar PDF de tickets asignados a él o que ha creado
        if not (ticket.assigned_to == request.user or ticket.created_by == request.user or request.user.is_staff):
            messages.error(request, 'No tienes permisos para generar PDF de este ticket.')
            return redirect('ticket_detail', pk=pk)
        
        # Crear el objeto HttpResponse con el tipo de contenido PDF
        response = HttpResponse(content_type='application/pdf')
        response['Content-Disposition'] = f'attachment; filename="ticket_{ticket.id}.pdf"'
        
        # Crear el buffer
        buffer = BytesIO()
        
        # Crear el documento PDF
        doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=72, leftMargin=72, 
                              topMargin=72, bottomMargin=72)
        
        # Contenedor para los elementos del PDF
        story = []
        
        # Obtener estilos
        styles = getSampleStyleSheet()
        
        # Crear estilos personalizados
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=24,
            spaceAfter=30,
            textColor=colors.black,
            alignment=1  # Centrado
        )
        
        header_style = ParagraphStyle(
            'CustomHeader',
            parent=styles['Heading2'],
            fontSize=14,
            spaceBefore=20,
            spaceAfter=10,
            textColor=colors.black
        )
        
        normal_style = ParagraphStyle(
            'CustomNormal',
            parent=styles['Normal'],
            fontSize=11,
            spaceAfter=10
        )
        
        # Título del documento
        story.append(Paragraph(f"TICKET #{ticket.id}", title_style))
        story.append(Spacer(1, 20))
        
        # Información básica del ticket en tabla
        data = [
            ['Campo', 'Información'],
            ['Título', ticket.title],
            ['Fecha de Creación', ticket.created_at.strftime('%d/%m/%Y %H:%M')],
            ['Creado por', ticket.created_by.get_full_name() or ticket.created_by.username],
            ['Estado', ticket.get_status_display()],
            ['Categoría', ticket.category.name if ticket.category else 'Sin categoría'],
            ['Asignado a', ticket.assigned_to.get_full_name() if ticket.assigned_to else 'Sin asignar'],
            ['Prioridad', ticket.get_priority_display()],
            ['Tipo', 'Error' if ticket.ticket_type == 'error' else 'Desarrollo']
        ]
        
        # Crear la tabla
        table = Table(data, colWidths=[2*inch, 4*inch])
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (1, 0), colors.black),
            ('TEXTCOLOR', (0, 0), (1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 12),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('FONTNAME', (0, 1), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 1), (-1, -1), 10),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
        ]))
        
        story.append(table)
        story.append(Spacer(1, 30))
        
        # Descripción del ticket
        story.append(Paragraph("Descripción del Ticket", header_style))
        description_text = ticket.description if ticket.description else "Sin descripción disponible."
        # Convertir saltos de línea a <br/> para que Paragraph los respete
        # Paragraph entiende etiquetas HTML limitadas, incluyendo <br/>
        description_html = (description_text.replace('\r\n', '\n')
                                             .replace('\r', '\n')
                                             .replace('\n', '<br/>'))
        story.append(Paragraph(description_html, normal_style))
        story.append(Spacer(1, 20))
        
        # Información adicional si existe
        if hasattr(ticket, 'contact') and ticket.contact:
            story.append(Paragraph("Contacto Relacionado", header_style))
            story.append(Paragraph(f"{ticket.contact.name} - {ticket.contact.email}", normal_style))
            story.append(Spacer(1, 20))
        
        # Pie de página
        story.append(Spacer(1, 30))
        footer_style = ParagraphStyle(
            'Footer',
            parent=styles['Normal'],
            fontSize=9,
            textColor=colors.grey,
            alignment=1  # Centrado
        )
        
        now = datetime.datetime.now()
        footer_text = f"Documento generado el {now.strftime('%d/%m/%Y')} a las {now.strftime('%H:%M')} | Usuario: {request.user.get_full_name() or request.user.username} | Sistema TicketPro"
        story.append(Paragraph(footer_text, footer_style))
        
        # Construir el PDF
        doc.build(story)
        
        # Obtener el valor del buffer y enviarlo en la respuesta
        pdf = buffer.getvalue()
        buffer.close()
        response.write(pdf)
        
        return response
        
    except Ticket.DoesNotExist:
        messages.error(request, 'Ticket no encontrado.')
        return redirect('ticket_list')
    except Exception as e:
        messages.error(request, f'Error al generar el PDF: {str(e)}')
        return redirect('ticket_detail', pk=pk)


@login_required
def tickets_export_pdf(request):
    """Vista para exportar múltiples tickets a PDF"""
    if request.method != 'POST':
        messages.error(request, 'Método no permitido.')
        return redirect('ticket_list')
    
    from django.http import HttpResponse
    from reportlab.lib.pagesizes import A4
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.lib.colors import Color, black, white
    from reportlab.lib import colors
    from io import BytesIO
    from .models import Ticket
    import datetime
    
    try:
        ticket_ids = request.POST.getlist('ticket_ids')
        
        if not ticket_ids:
            messages.error(request, 'No se seleccionaron tickets para exportar.')
            return redirect('ticket_list')
        
        # Obtener los tickets con verificación de permisos
        tickets = []
        for ticket_id in ticket_ids:
            try:
                ticket = Ticket.objects.get(pk=ticket_id)
                # Verificar permisos - solo puede exportar tickets asignados a él o que ha creado
                if (ticket.assigned_to == request.user or ticket.created_by == request.user or request.user.is_staff):
                    tickets.append(ticket)
            except Ticket.DoesNotExist:
                continue
        
        if not tickets:
            messages.error(request, 'No tienes permisos para exportar ninguno de los tickets seleccionados.')
            return redirect('ticket_list')
        
        # Crear el objeto HttpResponse con el tipo de contenido PDF
        response = HttpResponse(content_type='application/pdf')
        response['Content-Disposition'] = f'attachment; filename="tickets_export_{datetime.datetime.now().strftime("%Y%m%d_%H%M")}.pdf"'
        
        # Crear el buffer
        buffer = BytesIO()
        
        # Crear el documento PDF
        doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=72, leftMargin=72, 
                              topMargin=72, bottomMargin=72)
        
        # Contenedor para los elementos del PDF
        story = []
        
        # Obtener estilos
        styles = getSampleStyleSheet()
        
        # Crear estilos personalizados
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=20,
            spaceAfter=30,
            textColor=colors.black,
            alignment=1  # Centrado
        )
        
        ticket_title_style = ParagraphStyle(
            'TicketTitle',
            parent=styles['Heading1'],
            fontSize=16,
            spaceAfter=20,
            textColor=colors.black,
            alignment=1  # Centrado
        )
        
        header_style = ParagraphStyle(
            'CustomHeader',
            parent=styles['Heading2'],
            fontSize=12,
            spaceBefore=15,
            spaceAfter=8,
            textColor=colors.black
        )
        
        normal_style = ParagraphStyle(
            'CustomNormal',
            parent=styles['Normal'],
            fontSize=10,
            spaceAfter=8
        )
        
        # Título principal del documento
        story.append(Paragraph(f"EXPORTACIÓN DE TICKETS", title_style))
        story.append(Paragraph(f"Total de tickets: {len(tickets)}", normal_style))
        story.append(Spacer(1, 20))
        
        # Procesar cada ticket
        for i, ticket in enumerate(tickets):
            # Título del ticket
            story.append(Paragraph(f"TICKET #{ticket.id}", ticket_title_style))
            story.append(Spacer(1, 10))
            
            # Información básica del ticket en tabla
            data = [
                ['Campo', 'Información'],
                ['Título', ticket.title],
                ['Fecha de Creación', ticket.created_at.strftime('%d/%m/%Y %H:%M')],
                ['Creado por', ticket.created_by.get_full_name() or ticket.created_by.username],
                ['Estado', ticket.get_status_display()],
                ['Categoría', ticket.category.name if ticket.category else 'Sin categoría'],
                ['Asignado a', ticket.assigned_to.get_full_name() if ticket.assigned_to else 'Sin asignar'],
                ['Prioridad', ticket.get_priority_display()],
                ['Tipo', 'Error' if ticket.ticket_type == 'error' else 'Desarrollo']
            ]
            
            # Crear la tabla
            table = Table(data, colWidths=[1.5*inch, 4.5*inch])
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (1, 0), colors.black),
                ('TEXTCOLOR', (0, 0), (1, 0), colors.white),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 10),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 8),
                ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('FONTNAME', (0, 1), (0, -1), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 1), (-1, -1), 9),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ]))
            
            story.append(table)
            story.append(Spacer(1, 15))
            
            # Descripción del ticket
            story.append(Paragraph("Descripción del Ticket", header_style))
            description_text = ticket.description if ticket.description else "Sin descripción disponible."
            # Convertir saltos de línea a <br/> para que Paragraph los respete
            description_html = (description_text.replace('\r\n', '\n')
                                                 .replace('\r', '\n')
                                                 .replace('\n', '<br/>'))
            story.append(Paragraph(description_html, normal_style))
            
            # Agregar separador entre tickets (excepto el último)
            if i < len(tickets) - 1:
                story.append(PageBreak())
        
        # Pie de página
        story.append(Spacer(1, 30))
        footer_style = ParagraphStyle(
            'Footer',
            parent=styles['Normal'],
            fontSize=8,
            textColor=colors.grey,
            alignment=1  # Centrado
        )
        
        now = datetime.datetime.now()
        footer_text = f"Documento generado el {now.strftime('%d/%m/%Y')} a las {now.strftime('%H:%M')} | Usuario: {request.user.get_full_name() or request.user.username} | Sistema TicketPro"
        story.append(Paragraph(footer_text, footer_style))
        
        # Construir el PDF
        doc.build(story)
        
        # Obtener el valor del buffer y enviarlo en la respuesta
        pdf = buffer.getvalue()
        buffer.close()
        response.write(pdf)
        
        return response
        
    except Exception as e:
        messages.error(request, f'Error al generar el PDF: {str(e)}')
        return redirect('ticket_list')


@login_required
def get_filtered_ticket_ids(request):
    """Vista AJAX para obtener todos los IDs de tickets que coinciden con el filtro actual"""
    from django.http import JsonResponse
    from django.db import models
    from django.contrib.auth.models import User
    from .models import Ticket
    
    try:
        # Obtener los mismos filtros que usa ticket_list_view
        search = request.GET.get('search', '')
        status_filter = request.GET.get('status', '')
        priority_filter = request.GET.get('priority', '')
        assigned_filter = request.GET.get('assigned_to', '')
        company_filter = request.GET.get('company', '')
        
        # Aplicar los mismos filtros de la vista principal
        if request.user.groups.filter(name='Agentes').exists():
            # Los agentes ven todos los tickets
            tickets = Ticket.objects.all()
        else:
            # Los usuarios normales ven solo sus tickets y los de su empresa
            tickets = Ticket.objects.filter(
                models.Q(created_by=request.user) | 
                models.Q(assigned_to=request.user) |
                (models.Q(company=request.user.profile.company) if hasattr(request.user, 'profile') and request.user.profile.company else models.Q(pk__in=[]))
            )
        
        # Aplicar filtros de búsqueda
        if search:
            tickets = tickets.filter(
                models.Q(title__icontains=search) |
                models.Q(description__icontains=search) |
                models.Q(ticket_number__icontains=search)
            )
        
        if status_filter:
            tickets = tickets.filter(status=status_filter)
        
        if priority_filter:
            tickets = tickets.filter(priority=priority_filter)
        
        if company_filter:
            try:
                from .models import Company
                company = Company.objects.get(pk=company_filter)
                tickets = tickets.filter(company=company)
            except (Company.DoesNotExist, ValueError):
                pass
        
        if assigned_filter:
            if assigned_filter == 'unassigned':
                tickets = tickets.filter(assigned_to__isnull=True)
            elif assigned_filter == 'me':
                tickets = tickets.filter(assigned_to=request.user)
            else:
                try:
                    assigned_user = User.objects.get(pk=assigned_filter)
                    tickets = tickets.filter(assigned_to=assigned_user)
                except (User.DoesNotExist, ValueError):
                    pass
        
        # Obtener solo los IDs, ordenados igual que en la vista principal
        ticket_ids = list(tickets.order_by('-created_at').values_list('pk', flat=True))
        
        # Aplicar validación de permisos (solo tickets que puede exportar)
        allowed_ticket_ids = []
        for ticket_id in ticket_ids:
            try:
                ticket = Ticket.objects.get(pk=ticket_id)
                if (ticket.assigned_to == request.user or ticket.created_by == request.user or request.user.is_staff):
                    allowed_ticket_ids.append(ticket_id)
            except Ticket.DoesNotExist:
                continue
        
        return JsonResponse({
            'success': True,
            'ticket_ids': allowed_ticket_ids,
            'total_count': len(allowed_ticket_ids)
        })
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'message': f'Error al obtener tickets: {str(e)}'
        })


# ===== VISTAS DE CAPACITACIÓN =====

@login_required
def training_plan_list(request):
    """Vista para listar todos los planes de capacitación"""
    from .models import TrainingPlan, EmployeeTrainingProgress, EmployeeLinkProgress
    
    plans = TrainingPlan.objects.filter(is_active=True).prefetch_related('links')
    
    # Agregar progreso del usuario actual para cada plan
    for plan in plans:
        # Calcular progreso de forma directa (mismo método que en detail)
        total_links = plan.get_total_links()
        completed_links_count = EmployeeLinkProgress.objects.filter(
            employee=request.user, 
            link__plan=plan
        ).count()
        
        if total_links > 0:
            plan.user_progress = (completed_links_count / total_links) * 100
        else:
            plan.user_progress = 0
            
        plan.is_completed = plan.is_completed_by_user(request.user)
    
    context = {
        'plans': plans,
        'page_title': 'Planes de Capacitación',
    }
    
    return render(request, 'tickets/training_plan_list.html', context)


@login_required
def training_plan_detail(request, pk):
    """Vista para ver el detalle de un plan de capacitación"""
    from .models import TrainingPlan, TrainingLink, EmployeeLinkProgress, EmployeeTrainingProgress
    
    plan = get_object_or_404(TrainingPlan, pk=pk, is_active=True)
    links = plan.links.all()
    
    # Obtener o crear progreso del plan para el usuario
    training_progress, created = EmployeeTrainingProgress.objects.get_or_create(
        employee=request.user,
        plan=plan
    )
    
    # Obtener progreso del usuario para cada enlace
    for link in links:
        link.is_completed = EmployeeLinkProgress.objects.filter(
            employee=request.user, 
            link=link
        ).exists()
    
    # Estadísticas del plan
    total_links = plan.get_total_links()
    
    # Calcular progreso de forma directa
    completed_links_count = EmployeeLinkProgress.objects.filter(
        employee=request.user, 
        link__plan=plan
    ).count()
    
    if total_links > 0:
        user_progress_percent = (completed_links_count / total_links) * 100
    else:
        user_progress_percent = 0
    
    is_completed = plan.is_completed_by_user(request.user)
    
    context = {
        'plan': plan,
        'links': links,
        'total_links': total_links,
        'user_progress_percent': user_progress_percent,
        'is_completed': is_completed,
        'page_title': f'Plan de Capacitación #{plan.sequence}',
        'debug_completed_count': completed_links_count,  # Para debug
    }
    
    return render(request, 'tickets/training_plan_detail.html', context)


@login_required
def training_link_complete(request, pk):
    """Vista para marcar un enlace como completado"""
    from .models import TrainingLink, EmployeeLinkProgress, EmployeeTrainingProgress
    
    if request.method == 'POST':
        link = get_object_or_404(TrainingLink, pk=pk)
        notes = request.POST.get('notes', '').strip()
        
        # Obtener o crear progreso del plan
        training_progress, created = EmployeeTrainingProgress.objects.get_or_create(
            employee=request.user,
            plan=link.plan
        )
        
        # Crear progreso del enlace si no existe
        link_progress, created = EmployeeLinkProgress.objects.get_or_create(
            employee=request.user,
            link=link,
            training_progress=training_progress,
            defaults={'notes': notes}
        )
        
        if not created and notes:
            link_progress.notes = notes
        
        messages.success(request, f'Enlace "{link.title}" marcado como completado.')
        return redirect('training_plan_detail', pk=link.plan.pk)
    
    return redirect('training_plan_list')


@login_required
def training_link_uncomplete(request, pk):
    """Vista para marcar un enlace como no completado"""
    from .models import TrainingLink, EmployeeLinkProgress
    
    if request.method == 'POST':
        link = get_object_or_404(TrainingLink, pk=pk)
        
        try:
            progress = EmployeeLinkProgress.objects.get(employee=request.user, link=link)
            progress.delete()
            messages.info(request, f'Marcado como pendiente: {link.title}')
        except EmployeeLinkProgress.DoesNotExist:
            pass
        
        return redirect('training_plan_detail', pk=link.plan.pk)
    
    return redirect('training_plan_list')


@login_required
def my_training_progress(request):
    """Vista para ver el progreso personal de capacitación"""
    from .models import TrainingPlan, EmployeeTrainingProgress, EmployeeLinkProgress
    
    # Obtener todos los planes activos
    plans = TrainingPlan.objects.filter(is_active=True).prefetch_related('links')
    
    progress_data = []
    for plan in plans:
        total_links = plan.get_total_links()
        completed_links = EmployeeLinkProgress.objects.filter(
            employee=request.user,
            link__plan=plan
        ).count()
        
        progress_percent = (completed_links / total_links * 100) if total_links > 0 else 0
        
        # Obtener o crear progreso del entrenamiento
        training_progress, created = EmployeeTrainingProgress.objects.get_or_create(
            employee=request.user,
            plan=plan
        )
        
        progress_data.append({
            'plan': plan,
            'total_links': total_links,
            'completed_links': completed_links,
            'pending_links': total_links - completed_links,
            'progress_percent': progress_percent,
            'is_completed': progress_percent == 100,
            'training_progress': training_progress,
        })
    
    # Calcular estadísticas generales
    total_plans = len(progress_data)
    completed_plans = sum(1 for data in progress_data if data['is_completed'])
    in_progress_plans = sum(1 for data in progress_data if 0 < data['progress_percent'] < 100)
    completion_rate = (completed_plans / total_plans * 100) if total_plans > 0 else 0
    
    context = {
        'progress_data': progress_data,
        'page_title': 'Mi Progreso de Capacitación',
        'total_plans': total_plans,
        'completed_plans': completed_plans,
        'in_progress_plans': in_progress_plans,
        'completion_rate': completion_rate,
    }
    
    return render(request, 'tickets/my_training_progress.html', context)


# Vistas administrativas (solo para Agentes)
@login_required
def training_plan_create(request):
    """Vista para crear un nuevo plan de capacitación"""
    from .models import TrainingPlan
    
    # Verificar permisos
    if not (request.user.is_staff or (hasattr(request.user, 'groups') and 
            request.user.groups.filter(name='Agentes').exists())):
        messages.error(request, 'No tienes permisos para crear planes de capacitación.')
        return redirect('training_plan_list')
    
    if request.method == 'POST':
        title = request.POST.get('title', '').strip()
        description = request.POST.get('description', '').strip()
        
        if title and description:
            plan = TrainingPlan.objects.create(
                title=title,
                description=description,
                created_by=request.user
            )
            messages.success(request, f'Plan de capacitación #{plan.sequence} creado exitosamente.')
            return redirect('training_plan_detail', pk=plan.pk)
        else:
            messages.error(request, 'Título y descripción son requeridos.')
    
    context = {
        'page_title': 'Crear Plan de Capacitación',
    }
    
    return render(request, 'tickets/training_plan_form.html', context)


@login_required
def training_plan_edit(request, pk):
    """Vista para editar un plan de capacitación"""
    from .models import TrainingPlan
    
    # Verificar permisos
    if not (request.user.is_staff or (hasattr(request.user, 'groups') and 
            request.user.groups.filter(name='Agentes').exists())):
        messages.error(request, 'No tienes permisos para editar planes de capacitación.')
        return redirect('training_plan_list')
    
    plan = get_object_or_404(TrainingPlan, pk=pk)
    
    if request.method == 'POST':
        title = request.POST.get('title', '').strip()
        description = request.POST.get('description', '').strip()
        is_active = request.POST.get('is_active') == 'on'
        
        if title and description:
            plan.title = title
            plan.description = description
            plan.is_active = is_active
            plan.save()
            messages.success(request, f'Plan de capacitación #{plan.sequence} actualizado exitosamente.')
            return redirect('training_plan_detail', pk=plan.pk)
        else:
            messages.error(request, 'Título y descripción son requeridos.')
    
    context = {
        'plan': plan,
        'page_title': f'Editar Plan #{plan.sequence}',
    }
    
    return render(request, 'tickets/training_plan_form.html', context)


@login_required
def training_link_create(request, plan_pk):
    """Vista para agregar un enlace a un plan de capacitación"""
    from .models import TrainingPlan, TrainingLink
    
    # Verificar permisos
    if not (request.user.is_staff or (hasattr(request.user, 'groups') and 
            request.user.groups.filter(name='Agentes').exists())):
        messages.error(request, 'No tienes permisos para gestionar enlaces de capacitación.')
        return redirect('training_plan_list')
    
    plan = get_object_or_404(TrainingPlan, pk=plan_pk)
    
    if request.method == 'POST':
        title = request.POST.get('title', '').strip()
        url = request.POST.get('url', '').strip()
        description = request.POST.get('description', '').strip()
        is_required = request.POST.get('is_required') == 'on'
        order = request.POST.get('order', 0)
        estimated_hours = request.POST.get('estimated_hours', 1)
        
        try:
            order = int(order)
        except (ValueError, TypeError):
            order = 0
        
        try:
            estimated_hours = int(estimated_hours)
        except (ValueError, TypeError):
            estimated_hours = 1
        
        if title and url:
            training_link = TrainingLink.objects.create(
                plan=plan,
                title=title,
                url=url,
                description=description,
                is_required=is_required,
                order=order,
                estimated_hours=estimated_hours
            )
            messages.success(request, f'Enlace "{title}" agregado al plan exitosamente.')
            return redirect('training_plan_detail', pk=plan.pk)
        else:
            messages.error(request, 'Título y URL son requeridos.')
    
    context = {
        'plan': plan,
        'page_title': f'Agregar URL al Plan #{plan.sequence}',
    }
    
    return render(request, 'tickets/training_url_form.html', context)


@login_required
def training_link_edit(request, pk):
    """Vista para editar un enlace de capacitación"""
    from .models import TrainingLink
    
    # Verificar permisos
    if not (request.user.is_staff or (hasattr(request.user, 'groups') and 
            request.user.groups.filter(name='Agentes').exists())):
        messages.error(request, 'No tienes permisos para editar enlaces de capacitación.')
        return redirect('training_plan_list')
    
    training_link = get_object_or_404(TrainingLink, pk=pk)
    
    if request.method == 'POST':
        title = request.POST.get('title', '').strip()
        url = request.POST.get('url', '').strip()
        description = request.POST.get('description', '').strip()
        is_required = request.POST.get('is_required') == 'on'
        order = request.POST.get('order', 0)
        estimated_hours = request.POST.get('estimated_hours', 1)
        
        try:
            order = int(order)
        except (ValueError, TypeError):
            order = training_link.order
        
        try:
            estimated_hours = int(estimated_hours)
        except (ValueError, TypeError):
            estimated_hours = training_link.estimated_hours
        
        if title and url:
            training_link.title = title
            training_link.url = url
            training_link.description = description
            training_link.is_required = is_required
            training_link.order = order
            training_link.estimated_hours = estimated_hours
            training_link.save()
            messages.success(request, f'Enlace "{title}" actualizado exitosamente.')
            return redirect('training_plan_detail', pk=training_link.plan.pk)
        else:
            messages.error(request, 'Título y URL son requeridos.')
    
    context = {
        'training_link': training_link,
        'plan': training_link.plan,
        'page_title': f'Editar Enlace: {training_link.title}',
    }
    
    return render(request, 'tickets/training_link_form.html', context)


@login_required
def training_link_delete(request, pk):
    """Vista para eliminar un enlace de capacitación"""
    from .models import TrainingLink
    
    # Verificar permisos
    if not (request.user.is_staff or (hasattr(request.user, 'groups') and 
            request.user.groups.filter(name='Agentes').exists())):
        messages.error(request, 'No tienes permisos para eliminar enlaces de capacitación.')
        return redirect('training_plan_list')
    
    training_link = get_object_or_404(TrainingLink, pk=pk)
    plan_pk = training_link.plan.pk
    
    if request.method == 'POST':
        title = training_link.title
        training_link.delete()
        messages.success(request, f'Enlace "{title}" eliminado exitosamente.')
        return redirect('training_plan_detail', pk=plan_pk)
    
    context = {
        'training_url': training_url,
        'page_title': f'Eliminar URL: {training_url.title}',
    }
    
    return render(request, 'tickets/training_url_delete.html', context)


# ========== VISTAS DE RECOMENDACIONES IA ==========

@login_required
def ai_recommendation_list(request):
    """Vista para listar todas las recomendaciones IA"""
    from .models import AIRecommendation
    
    recommendations = AIRecommendation.objects.filter(is_active=True).order_by('-created_at')
    
    context = {
        'recommendations': recommendations,
        'page_title': 'Recomendaciones IA',
    }
    
    return render(request, 'tickets/ai_recommendation_list.html', context)


@login_required
def ai_recommendation_create(request):
    """Vista para crear una nueva recomendación IA"""
    from .models import AIRecommendation
    
    if request.method == 'POST':
        title = request.POST.get('title')
        context_text = request.POST.get('context_text')
        
        if title and context_text:
            recommendation = AIRecommendation.objects.create(
                title=title,
                context_text=context_text,
                created_by=request.user
            )
            messages.success(request, f'Recomendación "{title}" creada exitosamente.')
            return redirect('ai_recommendation_list')
        else:
            messages.error(request, 'Por favor, completa todos los campos requeridos.')
    
    context = {
        'page_title': 'Crear Recomendación IA',
    }
    
    return render(request, 'tickets/ai_recommendation_form.html', context)


@login_required
def ai_recommendation_edit(request, pk):
    """Vista para editar una recomendación IA"""
    from .models import AIRecommendation
    
    try:
        recommendation = AIRecommendation.objects.get(pk=pk)
    except AIRecommendation.DoesNotExist:
        messages.error(request, 'La recomendación solicitada no existe.')
        return redirect('ai_recommendation_list')
    
    if request.method == 'POST':
        recommendation.title = request.POST.get('title', recommendation.title)
        recommendation.context_text = request.POST.get('context_text', recommendation.context_text)
        recommendation.save()
        
        messages.success(request, f'Recomendación "{recommendation.title}" actualizada exitosamente.')
        return redirect('ai_recommendation_list')
    
    context = {
        'recommendation': recommendation,
        'page_title': f'Editar Recomendación: {recommendation.title}',
    }
    
    return render(request, 'tickets/ai_recommendation_form.html', context)


@login_required
def ai_recommendation_detail(request, pk):
    """Vista para ver el detalle de una recomendación y usar la IA"""
    from .models import AIRecommendation, AIRecommendationUsage
    from .ai_utils import AIContentOptimizer
    
    try:
        recommendation = AIRecommendation.objects.get(pk=pk)
    except AIRecommendation.DoesNotExist:
        messages.error(request, 'La recomendación solicitada no existe.')
        return redirect('ai_recommendation_list')
    
    ai_response = None
    client_case = ""
    
    if request.method == 'POST':
        client_case = request.POST.get('client_case', '').strip()
        
        if client_case:
            # Crear instancia del optimizador de IA
            ai_optimizer = AIContentOptimizer()
            
            # Preparar el prompt para la IA
            messages_for_ai = [
                {
                    "role": "system",
                    "content": f"""Eres un asistente experto en comunicación empresarial y atención al cliente. 
                    
CONTEXTO BASE:
{recommendation.context_text}

Tu tarea es generar una respuesta profesional, políticamente correcta y empática para el caso del cliente que se te presente. 
La respuesta debe ser:
- Profesional y respetuosa
- Empática con la situación del cliente
- Clara y concisa
- Orientada a soluciones
- Políticamente correcta
- Apropiada para comunicación por email

Responde únicamente con la sugerencia de respuesta, sin explicaciones adicionales."""
                },
                {
                    "role": "user", 
                    "content": f"Caso del cliente: {client_case}"
                }
            ]
            
            # Hacer la petición a la IA
            result = ai_optimizer._make_ai_request(messages_for_ai, max_tokens=800, temperature=0.7)
            
            if 'error' not in result:
                try:
                    ai_response = result['choices'][0]['message']['content'].strip()
                    
                    # Guardar el uso de la recomendación
                    AIRecommendationUsage.objects.create(
                        recommendation=recommendation,
                        user=request.user,
                        client_case=client_case,
                        ai_response=ai_response
                    )
                    
                    messages.success(request, 'Respuesta generada exitosamente.')
                    
                except (KeyError, IndexError) as e:
                    messages.error(request, 'Error al procesar la respuesta de la IA.')
                    ai_response = "Error al generar la respuesta. Por favor, intenta nuevamente."
            else:
                messages.error(request, f'Error de IA: {result["error"]}')
                ai_response = "Error al conectar con el servicio de IA. Verifica la configuración."
        else:
            messages.error(request, 'Por favor, ingresa el caso del cliente.')
    
    # Obtener el historial de usos recientes
    recent_usage = AIRecommendationUsage.objects.filter(
        recommendation=recommendation
    ).order_by('-created_at')[:5]
    
    context = {
        'recommendation': recommendation,
        'ai_response': ai_response,
        'client_case': client_case,
        'recent_usage': recent_usage,
        'page_title': f'Asistente IA: {recommendation.title}',
    }
    
    return render(request, 'tickets/ai_recommendation_detail.html', context)


@login_required
def ai_recommendation_delete(request, pk):
    """Vista para eliminar una recomendación IA"""
    from .models import AIRecommendation
    
    try:
        recommendation = AIRecommendation.objects.get(pk=pk)
    except AIRecommendation.DoesNotExist:
        messages.error(request, 'La recomendación solicitada no existe.')
        return redirect('ai_recommendation_list')
    
    if request.method == 'POST':
        title = recommendation.title
        recommendation.delete()
        messages.success(request, f'Recomendación "{title}" eliminada exitosamente.')
        return redirect('ai_recommendation_list')
    
    context = {
        'recommendation': recommendation,
        'page_title': f'Eliminar Recomendación: {recommendation.title}',
    }
    
    return render(request, 'tickets/ai_recommendation_delete.html', context)


# ========== VISTAS DE AUSENCIAS DE EMPLEADOS ==========

@login_required
def employee_absence_list(request):
    """Vista para listar ausencias de empleados"""
    from .models import EmployeeAbsence, AbsenceType
    from django.db.models import Q
    from datetime import datetime, timedelta
    from django.utils import timezone
    
    # Filtros
    employee_filter = request.GET.get('employee', '')
    type_filter = request.GET.get('type', '')
    status_filter = request.GET.get('status', '')
    date_from = request.GET.get('date_from', '')
    date_to = request.GET.get('date_to', '')
    
    # Obtener todas las ausencias
    absences = EmployeeAbsence.objects.select_related('employee', 'absence_type', 'approved_by')
    
    # Aplicar filtros
    if employee_filter:
        absences = absences.filter(
            Q(employee__username__icontains=employee_filter) |
            Q(employee__first_name__icontains=employee_filter) |
            Q(employee__last_name__icontains=employee_filter)
        )
    
    if type_filter:
        absences = absences.filter(absence_type_id=type_filter)
    
    if status_filter:
        absences = absences.filter(status=status_filter)
    
    if date_from:
        try:
            date_from_obj = datetime.strptime(date_from, '%Y-%m-%d').date()
            absences = absences.filter(start_date__gte=date_from_obj)
        except ValueError:
            pass
    
    if date_to:
        try:
            date_to_obj = datetime.strptime(date_to, '%Y-%m-%d').date()
            absences = absences.filter(end_date__lte=date_to_obj)
        except ValueError:
            pass
    
    # Obtener tipos de ausencias para el filtro
    absence_types = AbsenceType.objects.filter(is_active=True)
    
    # Datos adicionales para reportes PDF
    from django.contrib.auth.models import User
    all_employees = User.objects.filter(is_active=True).order_by('first_name', 'last_name', 'username')
    
    current_year = timezone.now().year
    current_month = timezone.now().month
    years_range = range(current_year - 2, current_year + 1)  # Últimos 2 años y año actual
    
    # Estadísticas rápidas
    today = timezone.now().date()
    current_absences = EmployeeAbsence.objects.filter(
        start_date__lte=today,
        end_date__gte=today,
        status='approved'
    ).count()
    
    pending_approvals = EmployeeAbsence.objects.filter(status='pending').count()
    
    context = {
        'absences': absences,
        'absence_types': absence_types,
        'all_employees': all_employees,
        'current_year': current_year,
        'current_month': current_month,
        'years_range': years_range,
        'current_absences': current_absences,
        'pending_approvals': pending_approvals,
        'employee_filter': employee_filter,
        'type_filter': type_filter,
        'status_filter': status_filter,
        'date_from': date_from,
        'date_to': date_to,
        'page_title': 'Gestión de Ausencias',
    }
    
    return render(request, 'tickets/employee_absence_list.html', context)


@login_required
def employee_absence_create(request):
    """Vista para crear una nueva ausencia"""
    from .models import EmployeeAbsence, AbsenceType
    from django.contrib.auth.models import User
    
    if request.method == 'POST':
        employee_id = request.POST.get('employee')
        absence_type_id = request.POST.get('absence_type')
        start_date = request.POST.get('start_date')
        end_date = request.POST.get('end_date')
        reason = request.POST.get('reason')
        lost_hours = request.POST.get('lost_hours', 0)
        documentation_file = request.FILES.get('documentation_file')
        
        try:
            # Convertir horas perdidas
            try:
                lost_hours = float(lost_hours) if lost_hours else 0.0
            except ValueError:
                lost_hours = 0.0
            
            employee = User.objects.get(id=employee_id)
            absence_type = AbsenceType.objects.get(id=absence_type_id)
            
            absence = EmployeeAbsence.objects.create(
                employee=employee,
                absence_type=absence_type,
                start_date=start_date,
                end_date=end_date,
                reason=reason,
                lost_hours=lost_hours,
                documentation_file=documentation_file
            )
            
            messages.success(request, f'Ausencia registrada para {employee.get_full_name() or employee.username}.')
            return redirect('employee_absence_list')
            
        except (User.DoesNotExist, AbsenceType.DoesNotExist) as e:
            messages.error(request, 'Error en los datos seleccionados.')
        except Exception as e:
            messages.error(request, f'Error al crear la ausencia: {str(e)}')
    
    # Obtener empleados y tipos de ausencias
    employees = User.objects.filter(is_active=True).order_by('first_name', 'last_name', 'username')
    absence_types = AbsenceType.objects.filter(is_active=True)
    
    context = {
        'employees': employees,
        'absence_types': absence_types,
        'page_title': 'Registrar Nueva Ausencia',
    }
    
    return render(request, 'tickets/employee_absence_form.html', context)


@login_required
def employee_absence_detail(request, pk):
    """Vista para ver el detalle de una ausencia"""
    from .models import EmployeeAbsence
    
    try:
        absence = EmployeeAbsence.objects.select_related(
            'employee', 'absence_type', 'approved_by'
        ).get(pk=pk)
    except EmployeeAbsence.DoesNotExist:
        messages.error(request, 'La ausencia solicitada no existe.')
        return redirect('employee_absence_list')
    
    context = {
        'absence': absence,
        'page_title': f'Ausencia de {absence.employee.get_full_name() or absence.employee.username}',
    }
    
    return render(request, 'tickets/employee_absence_detail.html', context)


@login_required
def employee_absence_edit(request, pk):
    """Vista para editar una ausencia"""
    from .models import EmployeeAbsence, AbsenceType
    from django.contrib.auth.models import User
    
    try:
        absence = EmployeeAbsence.objects.get(pk=pk)
    except EmployeeAbsence.DoesNotExist:
        messages.error(request, 'La ausencia solicitada no existe.')
        return redirect('employee_absence_list')
    
    if request.method == 'POST':
        absence.employee_id = request.POST.get('employee')
        absence.absence_type_id = request.POST.get('absence_type')
        absence.start_date = request.POST.get('start_date')
        absence.end_date = request.POST.get('end_date')
        absence.reason = request.POST.get('reason')
        
        # Actualizar horas perdidas
        lost_hours = request.POST.get('lost_hours', 0)
        try:
            absence.lost_hours = float(lost_hours) if lost_hours else 0.0
        except ValueError:
            absence.lost_hours = 0.0
        
        if request.FILES.get('documentation_file'):
            absence.documentation_file = request.FILES.get('documentation_file')
        
        try:
            absence.save()
            messages.success(request, 'Ausencia actualizada exitosamente.')
            return redirect('employee_absence_detail', pk=absence.pk)
        except Exception as e:
            messages.error(request, f'Error al actualizar la ausencia: {str(e)}')
    
    # Obtener empleados y tipos de ausencias
    employees = User.objects.filter(is_active=True).order_by('first_name', 'last_name', 'username')
    absence_types = AbsenceType.objects.filter(is_active=True)
    
    context = {
        'absence': absence,
        'employees': employees,
        'absence_types': absence_types,
        'page_title': f'Editar Ausencia de {absence.employee.get_full_name() or absence.employee.username}',
    }
    
    return render(request, 'tickets/employee_absence_form.html', context)


@login_required
def employee_absence_approve(request, pk):
    """Vista para aprobar una ausencia"""
    from .models import EmployeeAbsence
    
    try:
        absence = EmployeeAbsence.objects.get(pk=pk)
    except EmployeeAbsence.DoesNotExist:
        messages.error(request, 'La ausencia solicitada no existe.')
        return redirect('employee_absence_list')
    
    if request.method == 'POST':
        action = request.POST.get('action')
        
        if action == 'approve':
            absence.approve(request.user)
            messages.success(request, f'Ausencia de {absence.employee.get_full_name() or absence.employee.username} aprobada.')
        
        elif action == 'reject':
            rejection_reason = request.POST.get('rejection_reason', '')
            if rejection_reason:
                absence.reject(rejection_reason, request.user)
                messages.success(request, f'Ausencia de {absence.employee.get_full_name() or absence.employee.username} rechazada.')
            else:
                messages.error(request, 'Debes proporcionar un motivo para el rechazo.')
                return redirect('employee_absence_detail', pk=pk)
        
        return redirect('employee_absence_detail', pk=pk)
    
    return redirect('employee_absence_detail', pk=pk)


@login_required
def employee_absence_delete(request, pk):
    """Vista para eliminar una ausencia"""
    from .models import EmployeeAbsence
    
    try:
        absence = EmployeeAbsence.objects.get(pk=pk)
    except EmployeeAbsence.DoesNotExist:
        messages.error(request, 'La ausencia solicitada no existe.')
        return redirect('employee_absence_list')
    
    if request.method == 'POST':
        employee_name = absence.employee.get_full_name() or absence.employee.username
        absence.delete()
        messages.success(request, f'Ausencia de {employee_name} eliminada exitosamente.')
        return redirect('employee_absence_list')
    
    context = {
        'absence': absence,
        'page_title': f'Eliminar Ausencia de {absence.employee.get_full_name() or absence.employee.username}',
    }
    
    return render(request, 'tickets/employee_absence_delete.html', context)


@login_required
def employee_absence_calendar(request):
    """Vista de calendario de ausencias"""
    from .models import EmployeeAbsence
    from datetime import datetime, timedelta
    from django.utils import timezone
    import calendar
    import json
    
    # Obtener mes y año de los parámetros o usar el mes actual
    now = timezone.now()
    year = int(request.GET.get('year', now.year))
    month = int(request.GET.get('month', now.month))
    
    # Crear objeto fecha para el mes solicitado
    try:
        current_date = datetime(year, month, 1).date()
    except ValueError:
        current_date = now.date().replace(day=1)
        year = current_date.year
        month = current_date.month
    
    # Calcular fechas de inicio y fin del mes
    first_day = current_date
    if month == 12:
        last_day = current_date.replace(year=year+1, month=1, day=1) - timedelta(days=1)
    else:
        last_day = current_date.replace(month=month+1, day=1) - timedelta(days=1)
    
    # Obtener ausencias del mes
    absences = EmployeeAbsence.objects.filter(
        start_date__lte=last_day,
        end_date__gte=first_day,
        status='approved'
    ).select_related('employee', 'absence_type')
    
    # Preparar datos para el calendario
    calendar_data = []
    for absence in absences:
        calendar_data.append({
            'id': absence.id,
            'title': f"{absence.employee.get_full_name() or absence.employee.username} - {absence.absence_type.name}",
            'start': absence.start_date.isoformat(),
            'end': (absence.end_date + timedelta(days=1)).isoformat(),  # FullCalendar usa fin exclusivo
            'color': absence.absence_type.color,
            'url': f"/employee-absences/{absence.id}/",
        })
    
    # Navegación del calendario
    prev_month = month - 1 if month > 1 else 12
    prev_year = year if month > 1 else year - 1
    next_month = month + 1 if month < 12 else 1
    next_year = year if month < 12 else year + 1
    
    context = {
        'calendar_data': json.dumps(calendar_data),
        'current_month': calendar.month_name[month],
        'current_year': year,
        'prev_month': prev_month,
        'prev_year': prev_year,
        'next_month': next_month,
        'next_year': next_year,
        'page_title': f'Calendario de Ausencias - {calendar.month_name[month]} {year}',
    }
    
    return render(request, 'tickets/employee_absence_calendar.html', context)


@login_required
def employee_absence_report_pdf(request):
    """Vista para generar reporte PDF de ausencias por empleado y mes"""
    from django.http import HttpResponse
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib import colors
    from reportlab.lib.units import inch
    from reportlab.graphics.shapes import Drawing, Line
    import io
    import calendar
    from datetime import datetime, timedelta
    from .models import EmployeeAbsence, AbsenceType
    from django.contrib.auth.models import User
    from django.utils import timezone
    
    # Obtener parámetros
    employee_id = request.GET.get('employee_id')
    year = int(request.GET.get('year', timezone.now().year))
    month = int(request.GET.get('month', timezone.now().month))
    
    # Validar empleado
    try:
        employee = User.objects.get(id=employee_id) if employee_id else None
    except User.DoesNotExist:
        employee = None
    
    if not employee:
        return HttpResponse('Empleado no encontrado', status=404)
    
    # Calcular fechas del mes
    try:
        first_day = datetime(year, month, 1).date()
        if month == 12:
            last_day = datetime(year + 1, 1, 1).date() - timedelta(days=1)
        else:
            last_day = datetime(year, month + 1, 1).date() - timedelta(days=1)
    except ValueError:
        first_day = timezone.now().date().replace(day=1)
        last_day = first_day.replace(day=calendar.monthrange(first_day.year, first_day.month)[1])
    
    # Obtener ausencias del empleado en el mes
    absences = EmployeeAbsence.objects.filter(
        employee=employee,
        start_date__lte=last_day,
        end_date__gte=first_day
    ).select_related('absence_type', 'approved_by').order_by('start_date')
    
    # Crear PDF
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=72, leftMargin=72, topMargin=72, bottomMargin=72)
    
    # Estilos
    styles = getSampleStyleSheet()
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=18,
        spaceAfter=20,
        alignment=1,  # Centrado
        textColor=colors.darkblue
    )
    
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=15,
        textColor=colors.darkblue
    )
    
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=6
    )
    
    # Contenido del PDF
    story = []
    
    # Título
    month_name = calendar.month_name[month]
    title = Paragraph(f"Reporte de Ausencias", title_style)
    subtitle = Paragraph(f"{employee.get_full_name() or employee.username}", subtitle_style)
    period = Paragraph(f"Período: {month_name} {year}", normal_style)
    
    story.append(title)
    story.append(subtitle)
    story.append(period)
    story.append(Spacer(1, 20))
    
    # Información del empleado
    employee_info = [
        ['Información del Empleado', ''],
        ['Nombre:', employee.get_full_name() or employee.username],
        ['Usuario:', employee.username],
        ['Email:', employee.email or 'No registrado'],
        ['Fecha del reporte:', timezone.now().strftime('%d/%m/%Y %H:%M')]
    ]
    
    employee_table = Table(employee_info, colWidths=[2*inch, 3*inch])
    employee_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (1, 0), colors.lightblue),
        ('TEXTCOLOR', (0, 0), (1, 0), colors.darkblue),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (1, 0), 12),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 1), (-1, -1), 10),
        ('BOTTOMPADING', (0, 0), (-1, 0), 12),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ]))
    
    story.append(employee_table)
    story.append(Spacer(1, 20))
    
    # Resumen estadístico
    total_days = sum(absence.get_duration_days() for absence in absences)
    total_hours = sum(float(absence.lost_hours) for absence in absences)
    approved_count = absences.filter(status='approved').count()
    pending_count = absences.filter(status='pending').count()
    rejected_count = absences.filter(status='rejected').count()
    
    summary_info = [
        ['Resumen del Mes', ''],
        ['Total de ausencias:', str(len(absences))],
        ['Días de ausencia:', str(total_days)],
        ['Horas perdidas:', f"{total_hours:.1f} horas"],
        ['Aprobadas:', str(approved_count)],
        ['Pendientes:', str(pending_count)],
        ['Rechazadas:', str(rejected_count)]
    ]
    
    summary_table = Table(summary_info, colWidths=[2*inch, 1.5*inch])
    summary_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (1, 0), colors.lightgreen),
        ('TEXTCOLOR', (0, 0), (1, 0), colors.darkgreen),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (1, 0), 12),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 1), (-1, -1), 10),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ]))
    
    story.append(summary_table)
    story.append(Spacer(1, 20))
    
    # Detalle de ausencias
    if absences.exists():
        story.append(Paragraph("Detalle de Ausencias", subtitle_style))
        story.append(Spacer(1, 10))
        
        # Crear tabla de ausencias
        absence_data = [['Tipo', 'Fechas', 'Días', 'Horas', 'Estado', 'Motivo']]
        
        for absence in absences:
            # Formatear fechas
            if absence.start_date == absence.end_date:
                dates = absence.start_date.strftime('%d/%m/%Y')
            else:
                dates = f"{absence.start_date.strftime('%d/%m/%Y')} - {absence.end_date.strftime('%d/%m/%Y')}"
            
            # Truncar motivo si es muy largo
            reason = absence.reason[:40] + '...' if len(absence.reason) > 40 else absence.reason
            
            absence_data.append([
                absence.absence_type.name,
                dates,
                str(absence.get_duration_days()),
                f"{absence.lost_hours} h",
                absence.get_status_display(),
                reason
            ])
        
        absence_table = Table(absence_data, colWidths=[1.3*inch, 1.6*inch, 0.6*inch, 0.7*inch, 0.9*inch, 1.9*inch])
        absence_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 9),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey]),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
        ]))
        
        story.append(absence_table)
        story.append(Spacer(1, 20))
        
        # Detalle completo de cada ausencia
        story.append(Paragraph("Información Detallada", subtitle_style))
        story.append(Spacer(1, 10))
        
        for i, absence in enumerate(absences):
            if i > 0:
                story.append(Spacer(1, 15))
            
            # Información detallada de la ausencia
            detail_info = [
                [f'Ausencia #{i+1}', ''],
                ['Tipo:', absence.absence_type.name],
                ['Inicio:', absence.start_date.strftime('%d/%m/%Y')],
                ['Fin:', absence.end_date.strftime('%d/%m/%Y')],
                ['Duración:', f'{absence.get_duration_days()} día{"s" if absence.get_duration_days() != 1 else ""}'],
                ['Horas perdidas:', f'{absence.lost_hours} horas'],
                ['Estado:', absence.get_status_display()],
                ['Solicitada:', absence.created_at.strftime('%d/%m/%Y %H:%M')],
            ]
            
            if absence.approved_by:
                detail_info.append(['Gestionada por:', absence.approved_by.get_full_name() or absence.approved_by.username])
                detail_info.append(['Fecha gestión:', absence.approved_at.strftime('%d/%m/%Y %H:%M')])
            
            detail_table = Table(detail_info, colWidths=[1.5*inch, 4*inch])
            detail_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (1, 0), colors.lightcyan),
                ('TEXTCOLOR', (0, 0), (1, 0), colors.darkblue),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (1, 0), 11),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 9),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ]))
            
            story.append(detail_table)
            
            # Motivo
            story.append(Spacer(1, 5))
            motivo_para = Paragraph(f"<b>Motivo:</b> {absence.reason}", normal_style)
            story.append(motivo_para)
            
            # Motivo de rechazo si aplica
            if absence.rejection_reason:
                rejection_para = Paragraph(f"<b>Motivo de rechazo:</b> {absence.rejection_reason}", normal_style)
                story.append(rejection_para)
            
            # Separador entre ausencias
            if i < len(absences) - 1:
                story.append(Spacer(1, 10))
                # Línea separadora
                drawing = Drawing(400, 1)
                drawing.add(Line(0, 0, 400, 0))
                story.append(drawing)
    
    else:
        story.append(Paragraph("No se registraron ausencias en este período", normal_style))
    
    # Pie de página
    story.append(Spacer(1, 30))
    footer = Paragraph(
        f"Reporte generado el {timezone.now().strftime('%d/%m/%Y a las %H:%M')} | Sistema de Gestión de Ausencias",
        ParagraphStyle(
            'Footer',
            parent=styles['Normal'],
            fontSize=8,
            textColor=colors.grey,
            alignment=1
        )
    )
    story.append(footer)
    
    # Construir PDF
    doc.build(story)
    
    # Preparar respuesta
    buffer.seek(0)
    response = HttpResponse(buffer.getvalue(), content_type='application/pdf')
    
    # Nombre del archivo
    employee_name = (employee.get_full_name() or employee.username).replace(' ', '_')
    filename = f"ausencias_{employee_name}_{month_name}_{year}.pdf"
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    
    return response


# ==================== VISTAS DE PROTOCOLOS DE EMPRESA ====================

@login_required
def company_protocol_list(request):
    """Vista para listar protocolos de empresa"""
    from .models import CompanyProtocol
    from django.db.models import Q
    
    # Filtros
    search = request.GET.get('search', '')
    active_filter = request.GET.get('active', 'all')
    
    # Obtener protocolos
    protocols = CompanyProtocol.objects.all()
    
    # Aplicar filtros
    if search:
        protocols = protocols.filter(
            Q(title__icontains=search) | Q(content__icontains=search)
        )
    
    if active_filter == 'active':
        protocols = protocols.filter(is_active=True)
    elif active_filter == 'inactive':
        protocols = protocols.filter(is_active=False)
    
    protocols = protocols.select_related('created_by').order_by('-created_at')
    
    context = {
        'protocols': protocols,
        'search': search,
        'active_filter': active_filter,
        'page_title': 'Protocolos de Empresa',
    }
    
    return render(request, 'tickets/company_protocol_list.html', context)


@login_required
def company_protocol_create(request):
    """Vista para crear un nuevo protocolo"""
    from .models import CompanyProtocol, Company
    
    if request.method == 'POST':
        title = request.POST.get('title')
        content = request.POST.get('content')
        company_id = request.POST.get('company')
        version = request.POST.get('version', '1.0')
        is_active = request.POST.get('is_active') == 'on'
        
        # Validaciones básicas
        if not all([title, content, company_id]):
            messages.error(request, 'El título, contenido y empresa son requeridos.')
        else:
            try:
                company = Company.objects.get(pk=company_id)
                protocol = CompanyProtocol.objects.create(
                    title=title,
                    content=content,
                    company=company,
                    version=version,
                    is_active=is_active,
                    created_by=request.user
                )
                
                messages.success(request, f'Protocolo "{protocol.title}" creado exitosamente.')
                return redirect('company_protocol_detail', pk=protocol.pk)
                
            except Company.DoesNotExist:
                messages.error(request, 'La empresa seleccionada no existe.')
            except Exception as e:
                messages.error(request, f'Error al crear el protocolo: {str(e)}')
    
    # Obtener todas las empresas para el formulario
    companies = Company.objects.all().order_by('name')
    
    context = {
        'page_title': 'Crear Protocolo de Empresa',
        'companies': companies,
    }
    
    return render(request, 'tickets/company_protocol_form.html', context)


@login_required
def company_protocol_detail(request, pk):
    """Vista para ver el detalle de un protocolo"""
    from .models import CompanyProtocol
    
    try:
        protocol = CompanyProtocol.objects.select_related('created_by').get(pk=pk)
    except CompanyProtocol.DoesNotExist:
        messages.error(request, 'El protocolo solicitado no existe.')
        return redirect('company_protocol_list')
    
    context = {
        'protocol': protocol,
        'page_title': f'Protocolo: {protocol.title}',
    }
    
    return render(request, 'tickets/company_protocol_detail.html', context)


@login_required
def company_protocol_edit(request, pk):
    """Vista para editar un protocolo"""
    from .models import CompanyProtocol, Company
    
    try:
        protocol = CompanyProtocol.objects.get(pk=pk)
    except CompanyProtocol.DoesNotExist:
        messages.error(request, 'El protocolo solicitado no existe.')
        return redirect('company_protocol_list')
    
    if request.method == 'POST':
        protocol.title = request.POST.get('title', protocol.title)
        protocol.content = request.POST.get('content', protocol.content)
        company_id = request.POST.get('company')
        protocol.version = request.POST.get('version', protocol.version)
        protocol.is_active = request.POST.get('is_active') == 'on'
        
        if company_id:
            try:
                protocol.company = Company.objects.get(pk=company_id)
            except Company.DoesNotExist:
                messages.error(request, 'La empresa seleccionada no existe.')
                return render(request, 'tickets/company_protocol_form.html', {
                    'protocol': protocol,
                    'companies': Company.objects.all().order_by('name'),
                    'page_title': f'Editar Protocolo: {protocol.title}',
                })
        
        try:
            protocol.save()
            messages.success(request, 'Protocolo actualizado exitosamente.')
            return redirect('company_protocol_detail', pk=protocol.pk)
        except Exception as e:
            messages.error(request, f'Error al actualizar el protocolo: {str(e)}')
    
    # Obtener todas las empresas para el formulario
    companies = Company.objects.all().order_by('name')
    
    context = {
        'protocol': protocol,
        'companies': companies,
        'page_title': f'Editar Protocolo: {protocol.title}',
    }
    
    return render(request, 'tickets/company_protocol_form.html', context)


@login_required
def company_protocol_delete(request, pk):
    """Vista para eliminar un protocolo"""
    from .models import CompanyProtocol
    
    try:
        protocol = CompanyProtocol.objects.get(pk=pk)
    except CompanyProtocol.DoesNotExist:
        messages.error(request, 'El protocolo solicitado no existe.')
        return redirect('company_protocol_list')
    
    if request.method == 'POST':
        protocol_title = protocol.title
        protocol.delete()
        messages.success(request, f'Protocolo "{protocol_title}" eliminado exitosamente.')
        return redirect('company_protocol_list')
    
    context = {
        'protocol': protocol,
        'page_title': f'Eliminar Protocolo: {protocol.title}',
    }
    
    return render(request, 'tickets/company_protocol_delete.html', context)


@login_required
def company_protocol_print_pdf(request, pk):
    """Vista para imprimir protocolo en PDF"""
    from django.http import HttpResponse
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib import colors
    from reportlab.lib.units import inch
    import io
    from .models import CompanyProtocol
    from django.utils import timezone
    
    try:
        protocol = CompanyProtocol.objects.select_related('created_by').get(pk=pk)
    except CompanyProtocol.DoesNotExist:
        return HttpResponse('Protocolo no encontrado', status=404)
    
    # Crear PDF
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=72, leftMargin=72, topMargin=72, bottomMargin=72)
    
    # Estilos
    styles = getSampleStyleSheet()
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=20,
        spaceAfter=30,
        alignment=1,  # Centrado
        textColor=colors.darkblue,
        fontName='Helvetica-Bold'
    )
    
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        textColor=colors.darkblue,
        fontName='Helvetica-Bold'
    )
    
    content_style = ParagraphStyle(
        'CustomContent',
        parent=styles['Normal'],
        fontSize=11,
        spaceAfter=12,
        alignment=0,  # Justificado
        fontName='Helvetica'
    )
    
    meta_style = ParagraphStyle(
        'MetaStyle',
        parent=styles['Normal'],
        fontSize=9,
        textColor=colors.grey,
        spaceAfter=6
    )
    
    # Contenido del PDF
    story = []
    
    # Encabezado de empresa
    company_header = Paragraph("PROTOCOLO DE EMPRESA", title_style)
    story.append(company_header)
    story.append(Spacer(1, 20))
    
    # Título del protocolo
    protocol_title = Paragraph(protocol.title, subtitle_style)
    story.append(protocol_title)
    story.append(Spacer(1, 15))
    
    # Información del protocolo
    meta_info = f"""
    <b>Empresa:</b> {protocol.company.name if protocol.company else 'No asignada'}<br/>
    <b>Versión:</b> {protocol.version}<br/>
    <b>Creado por:</b> {protocol.created_by.get_full_name() or protocol.created_by.username}<br/>
    <b>Fecha de creación:</b> {protocol.created_at.strftime('%d/%m/%Y %H:%M')}<br/>
    <b>Última actualización:</b> {protocol.updated_at.strftime('%d/%m/%Y %H:%M')}<br/>
    <b>Estado:</b> {'Activo' if protocol.is_active else 'Inactivo'}<br/>
    <b>Palabras:</b> {protocol.get_word_count()}
    """
    story.append(Paragraph(meta_info, meta_style))
    story.append(Spacer(1, 30))
    
    # Línea separadora
    from reportlab.graphics.shapes import Drawing, Line
    drawing = Drawing(400, 2)
    drawing.add(Line(0, 1, 400, 1, strokeColor=colors.darkblue, strokeWidth=2))
    story.append(drawing)
    story.append(Spacer(1, 20))
    
    # Contenido del protocolo
    # Dividir el contenido en párrafos
    content_paragraphs = protocol.content.split('\n')
    
    for paragraph_text in content_paragraphs:
        if paragraph_text.strip():  # Solo agregar párrafos no vacíos
            # Escapar caracteres especiales para ReportLab
            paragraph_text = paragraph_text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
            paragraph = Paragraph(paragraph_text, content_style)
            story.append(paragraph)
        else:
            # Agregar espacio para párrafos vacíos
            story.append(Spacer(1, 12))
    
    # Pie de página
    story.append(Spacer(1, 40))
    
    # Línea separadora final
    drawing_footer = Drawing(400, 2)
    drawing_footer.add(Line(0, 1, 400, 1, strokeColor=colors.lightgrey, strokeWidth=1))
    story.append(drawing_footer)
    story.append(Spacer(1, 10))
    
    footer_text = f"""
    <i>Documento generado el {timezone.now().strftime('%d/%m/%Y a las %H:%M')} | 
    Sistema de Gestión de Protocolos Empresariales</i>
    """
    footer = Paragraph(footer_text, ParagraphStyle(
        'Footer',
        parent=styles['Normal'],
        fontSize=8,
        textColor=colors.grey,
        alignment=1  # Centrado
    ))
    story.append(footer)
    
    # Construir PDF
    doc.build(story)
    
    # Preparar respuesta
    buffer.seek(0)
    response = HttpResponse(buffer.getvalue(), content_type='application/pdf')
    
    # Nombre del archivo
    protocol_name = protocol.title.replace(' ', '_').replace('/', '_')
    filename = f"protocolo_{protocol_name}_v{protocol.version}.pdf"
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    
    return response


# ================================
# VISTAS API DE IA PARA PROTOCOLOS
# ================================

@login_required
def company_protocol_ai_generate_content(request, pk):
    """API para generar contenido del protocolo con IA"""
    from django.http import JsonResponse
    from .models import CompanyProtocol
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'})
    
    try:
        protocol = CompanyProtocol.objects.get(pk=pk)
    except CompanyProtocol.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Protocolo no encontrado'})
    
    content_type = request.POST.get('content_type', 'comprehensive')
    result = protocol.generate_ai_content(content_type)
    
    return JsonResponse(result)


@login_required
def company_protocol_ai_analyze_readability(request, pk):
    """API para analizar legibilidad del protocolo"""
    from django.http import JsonResponse
    from .models import CompanyProtocol
    
    try:
        protocol = CompanyProtocol.objects.get(pk=pk)
    except CompanyProtocol.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Protocolo no encontrado'})
    
    result = protocol.analyze_readability()
    return JsonResponse(result)


@login_required
def company_protocol_ai_get_suggestions(request, pk):
    """API para obtener sugerencias de mejora con IA"""
    from django.http import JsonResponse
    from .models import CompanyProtocol
    
    try:
        protocol = CompanyProtocol.objects.get(pk=pk)
    except CompanyProtocol.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Protocolo no encontrado'})
    
    result = protocol.get_ai_suggestions()
    return JsonResponse(result)


@login_required
def company_protocol_ai_generate_summary(request, pk):
    """API para generar resumen ejecutivo con IA"""
    from django.http import JsonResponse
    from .models import CompanyProtocol
    
    try:
        protocol = CompanyProtocol.objects.get(pk=pk)
    except CompanyProtocol.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Protocolo no encontrado'})
    
    result = protocol.generate_executive_summary()
    return JsonResponse(result)


@login_required
def company_protocol_ai_improve_content(request, pk):
    """API para mejorar automáticamente el contenido con IA"""
    from django.http import JsonResponse
    from .models import CompanyProtocol, SystemConfiguration
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'})
    
    try:
        protocol = CompanyProtocol.objects.get(pk=pk)
    except CompanyProtocol.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Protocolo no encontrado'})
    
    try:
        config = SystemConfiguration.objects.first()
        if not config or not config.ai_chat_enabled or not config.openai_api_key:
            return JsonResponse({'success': False, 'error': 'OpenAI no está configurado en el sistema'})
        
        import openai
        client = openai.OpenAI(api_key=config.openai_api_key)
        
        improvement_type = request.POST.get('improvement_type', 'general')
        
        prompts = {
            'general': f"""
            Mejora el siguiente protocolo empresarial manteniendo todo el contenido importante pero haciéndolo más claro, profesional y fácil de seguir:
            
            TÍTULO: {protocol.title}
            CONTENIDO ACTUAL:
            {protocol.content}
            
            Mejora la estructura, claridad y profesionalismo sin cambiar el mensaje principal.
            NO uses formato Markdown (**, *, etc.). Usa texto plano con saltos de línea para separar secciones.
            """,
            'clarity': f"""
            Reescribe este protocolo para hacerlo más claro y fácil de entender, usando lenguaje simple pero profesional:
            
            {protocol.content}
            
            NO uses formato Markdown. Usa texto plano con saltos de línea.
            """,
            'structure': f"""
            Reorganiza y mejora la estructura de este protocolo usando encabezados, listas y párrafos bien organizados:
            
            {protocol.content}
            
            NO uses formato Markdown. Usa texto plano con numeración simple y saltos de línea.
            """,
            'professional': f"""
            Reescribe este protocolo con un tono más profesional y formal apropiado para un documento corporativo:
            
            {protocol.content}
            
            NO uses formato Markdown. Usa texto plano con saltos de línea.
            """
        }
        
        response = client.chat.completions.create(
            model=config.openai_model or "gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "Eres un experto editor de documentos corporativos especializado en mejorar protocolos empresariales. NO uses formato Markdown en tus respuestas, solo texto plano con saltos de línea."},
                {"role": "user", "content": prompts.get(improvement_type, prompts['general'])}
            ],
            max_tokens=2000,
            temperature=0.6
        )
        
        improved_content = response.choices[0].message.content.strip()
        
        # Limpiar cualquier formato Markdown y devolver texto plano
        import re
        def remove_markdown_formatting(text):
            """Elimina formato Markdown y devuelve texto plano"""
            # Eliminar negritas **texto** y dejar solo texto
            text = re.sub(r'\*\*(.*?)\*\*', r'\1', text)
            # Eliminar cursivas *texto* y dejar solo texto
            text = re.sub(r'\*(.*?)\*', r'\1', text)
            # Eliminar títulos ## y # y dejar solo el texto
            text = re.sub(r'^#{1,6}\s*(.*?)$', r'\1', text, flags=re.MULTILINE)
            return text
        
        improved_content = remove_markdown_formatting(improved_content)
        
        return JsonResponse({
            'success': True,
            'improved_content': improved_content,
            'improvement_type': improvement_type,
            'word_count': len(improved_content.split())
        })
        
    except Exception as e:
        return JsonResponse({'success': False, 'error': f'Error mejorando contenido: {str(e)}'})


# ================================
# VISTAS PÚBLICAS DE PROTOCOLOS
# ================================

@login_required
def company_protocol_toggle_public(request, pk):
    """Vista para activar/desactivar el compartir público de un protocolo"""
    from .models import CompanyProtocol
    
    try:
        protocol = CompanyProtocol.objects.get(pk=pk)
    except CompanyProtocol.DoesNotExist:
        messages.error(request, 'El protocolo solicitado no existe.')
        return redirect('company_protocol_list')
    
    if request.method == 'POST':
        action = request.POST.get('action')
        if action == 'make_public':
            protocol.make_public()
            messages.success(request, f'El protocolo "{protocol.title}" ahora es público.')
        elif action == 'make_private':
            protocol.make_private()
            messages.success(request, f'El protocolo "{protocol.title}" ahora es privado.')
        
        return redirect('company_protocol_detail', pk=pk)
    
    return redirect('company_protocol_detail', pk=pk)


def company_protocol_public_view(request, uuid):
    """Vista pública para ver un protocolo sin autenticación"""
    from .models import CompanyProtocol
    
    try:
        protocol = CompanyProtocol.objects.select_related('created_by', 'company').get(
            public_uuid=uuid, 
            is_public=True
        )
    except CompanyProtocol.DoesNotExist:
        from django.http import Http404
        raise Http404("El protocolo solicitado no existe o no está disponible públicamente.")
    
    # Incrementar contador de vistas públicas
    protocol.increment_public_views()
    
    context = {
        'protocol': protocol,
        'page_title': f'Protocolo: {protocol.title}',
        'is_public_view': True,
    }
    
    return render(request, 'tickets/company_protocol_public.html', context)


@login_required 
def company_protocol_stats_api(request):
    """API para obtener estadísticas de protocolos públicos"""
    from django.db.models import Sum, Count, Avg
    from .models import CompanyProtocol
    from django.http import JsonResponse
    
    # Estadísticas generales
    total_protocols = CompanyProtocol.objects.count()
    public_protocols = CompanyProtocol.objects.filter(is_public=True).count()
    total_public_views = CompanyProtocol.objects.filter(is_public=True).aggregate(
        total_views=Sum('public_views_count')
    )['total_views'] or 0
    
    # Protocolos más vistos
    top_viewed = CompanyProtocol.objects.filter(
        is_public=True, 
        public_views_count__gt=0
    ).order_by('-public_views_count')[:5].values(
        'id', 'title', 'public_views_count', 'created_at'
    )
    
    # Promedio de vistas por protocolo público
    avg_views = CompanyProtocol.objects.filter(is_public=True).aggregate(
        avg_views=Avg('public_views_count')
    )['avg_views'] or 0
    
    stats = {
        'total_protocols': total_protocols,
        'public_protocols': public_protocols,
        'private_protocols': total_protocols - public_protocols,
        'total_public_views': total_public_views,
        'average_views_per_protocol': round(avg_views, 2),
        'top_viewed_protocols': list(top_viewed),
        'public_percentage': round((public_protocols / total_protocols * 100) if total_protocols > 0 else 0, 1)
    }
    
    return JsonResponse(stats)


# ================================
# VISTAS DE QA - QUEJAS Y SUGERENCIAS
# ================================

@login_required
def qa_complaint_list(request):
    """Vista para listar quejas y sugerencias QA"""
    from django.db.models import Q, Count
    from .models import QAComplaint, Company
    
    # Filtros
    search_query = request.GET.get('search', '')
    company_filter = request.GET.get('company', '')
    type_filter = request.GET.get('type', '')
    status_filter = request.GET.get('status', '')
    priority_filter = request.GET.get('priority', '')
    assigned_filter = request.GET.get('assigned', '')
    
    # Query base
    complaints = QAComplaint.objects.select_related('company', 'reported_by', 'assigned_to')
    
    # Aplicar filtros
    if search_query:
        complaints = complaints.filter(
            Q(title__icontains=search_query) |
            Q(description__icontains=search_query) |
            Q(company__name__icontains=search_query)
        )
    
    if company_filter:
        complaints = complaints.filter(company_id=company_filter)
    
    if type_filter:
        complaints = complaints.filter(type=type_filter)
    
    if status_filter:
        complaints = complaints.filter(status=status_filter)
    
    if priority_filter:
        complaints = complaints.filter(priority=priority_filter)
    
    if assigned_filter:
        if assigned_filter == 'unassigned':
            complaints = complaints.filter(assigned_to__isnull=True)
        elif assigned_filter == 'me':
            complaints = complaints.filter(assigned_to=request.user)
        else:
            complaints = complaints.filter(assigned_to_id=assigned_filter)
    
    # Ordenar
    complaints = complaints.order_by('-created_at')
    
    # Estadísticas
    stats = QAComplaint.objects.aggregate(
        total=Count('id'),
        open_count=Count('id', filter=Q(status='open')),
        in_progress_count=Count('id', filter=Q(status='in_progress')),
        resolved_count=Count('id', filter=Q(status='resolved')),
        high_priority_count=Count('id', filter=Q(priority__in=['high', 'critical']))
    )
    
    # Datos para filtros
    companies = Company.objects.all().order_by('name')
    users = User.objects.filter(
        Q(is_staff=True) | Q(groups__name='Agentes')
    ).distinct().order_by('username')
    
    context = {
        'complaints': complaints,
        'companies': companies,
        'users': users,
        'stats': stats,
        'search_query': search_query,
        'company_filter': company_filter,
        'type_filter': type_filter,
        'status_filter': status_filter,
        'priority_filter': priority_filter,
        'assigned_filter': assigned_filter,
        'page_title': 'Gestión QA - Quejas y Sugerencias',
        'type_choices': QAComplaint.TYPE_CHOICES,
        'status_choices': QAComplaint.STATUS_CHOICES,
        'priority_choices': QAComplaint.PRIORITY_CHOICES,
    }
    
    return render(request, 'tickets/qa_complaint_list.html', context)


@login_required
def qa_complaint_create(request):
    """Vista para crear nueva queja o sugerencia QA"""
    from .models import QAComplaint, Company
    
    if request.method == 'POST':
        title = request.POST.get('title')
        description = request.POST.get('description')
        type = request.POST.get('type')
        priority = request.POST.get('priority')
        company_id = request.POST.get('company')
        contact_email = request.POST.get('contact_email')
        contact_phone = request.POST.get('contact_phone')
        attachment = request.FILES.get('attachment')
        
        # Validaciones
        if not all([title, description, type, company_id]):
            messages.error(request, 'Título, descripción, tipo y empresa son requeridos.')
        else:
            try:
                company = Company.objects.get(pk=company_id)
                complaint = QAComplaint.objects.create(
                    title=title,
                    description=description,
                    type=type,
                    priority=priority or 'medium',
                    company=company,
                    reported_by=request.user,
                    contact_email=contact_email,
                    contact_phone=contact_phone,
                    attachment=attachment
                )
                
                messages.success(request, f'Reporte QA "{complaint.title}" creado exitosamente.')
                return redirect('qa_complaint_detail', pk=complaint.pk)
                
            except Company.DoesNotExist:
                messages.error(request, 'La empresa seleccionada no existe.')
            except Exception as e:
                messages.error(request, f'Error al crear el reporte: {str(e)}')
    
    companies = Company.objects.all().order_by('name')
    
    context = {
        'companies': companies,
        'type_choices': QAComplaint.TYPE_CHOICES,
        'priority_choices': QAComplaint.PRIORITY_CHOICES,
        'page_title': 'Nuevo Reporte QA',
    }
    
    return render(request, 'tickets/qa_complaint_form.html', context)


@login_required
def qa_complaint_detail(request, pk):
    """Vista para ver detalle de queja o sugerencia QA"""
    from .models import QAComplaint, QAComplaintComment
    from django.db.models import Q
    
    try:
        complaint = QAComplaint.objects.select_related(
            'company', 'reported_by', 'assigned_to'
        ).prefetch_related(
            'comments__author'
        ).get(pk=pk)
    except QAComplaint.DoesNotExist:
        messages.error(request, 'El reporte QA solicitado no existe.')
        return redirect('qa_complaint_list')
    
    # Manejar comentarios
    if request.method == 'POST' and 'add_comment' in request.POST:
        content = request.POST.get('comment_content')
        is_internal = request.POST.get('is_internal') == 'on'
        
        if content:
            QAComplaintComment.objects.create(
                complaint=complaint,
                author=request.user,
                content=content,
                is_internal=is_internal
            )
            messages.success(request, 'Comentario agregado exitosamente.')
            return redirect('qa_complaint_detail', pk=pk)
    
    # Usuarios para asignación
    users = User.objects.filter(
        Q(is_staff=True) | Q(groups__name='Agentes')
    ).distinct().order_by('username')
    
    context = {
        'complaint': complaint,
        'users': users,
        'page_title': f'Reporte QA: {complaint.title}',
    }
    
    return render(request, 'tickets/qa_complaint_detail.html', context)


@login_required
def qa_complaint_edit(request, pk):
    """Vista para editar queja o sugerencia QA"""
    from .models import QAComplaint, Company
    
    try:
        complaint = QAComplaint.objects.get(pk=pk)
    except QAComplaint.DoesNotExist:
        messages.error(request, 'El reporte QA solicitado no existe.')
        return redirect('qa_complaint_list')
    
    # Verificar permisos
    if not complaint.can_edit(request.user):
        messages.error(request, 'No tienes permisos para editar este reporte.')
        return redirect('qa_complaint_detail', pk=pk)
    
    if request.method == 'POST':
        complaint.title = request.POST.get('title', complaint.title)
        complaint.description = request.POST.get('description', complaint.description)
        complaint.type = request.POST.get('type', complaint.type)
        complaint.priority = request.POST.get('priority', complaint.priority)
        complaint.status = request.POST.get('status', complaint.status)
        complaint.contact_email = request.POST.get('contact_email', complaint.contact_email)
        complaint.contact_phone = request.POST.get('contact_phone', complaint.contact_phone)
        
        company_id = request.POST.get('company')
        if company_id:
            try:
                complaint.company = Company.objects.get(pk=company_id)
            except Company.DoesNotExist:
                messages.error(request, 'La empresa seleccionada no existe.')
                return render(request, 'tickets/qa_complaint_form.html', {
                    'complaint': complaint,
                    'companies': Company.objects.all().order_by('name'),
                    'type_choices': QAComplaint.TYPE_CHOICES,
                    'priority_choices': QAComplaint.PRIORITY_CHOICES,
                    'status_choices': QAComplaint.STATUS_CHOICES,
                    'page_title': f'Editar Reporte QA: {complaint.title}',
                })
        
        # Asignación
        assigned_to_id = request.POST.get('assigned_to')
        if assigned_to_id:
            try:
                complaint.assigned_to = User.objects.get(pk=assigned_to_id)
            except User.DoesNotExist:
                pass
        elif assigned_to_id == '':
            complaint.assigned_to = None
        
        # Archivo adjunto
        if 'attachment' in request.FILES:
            complaint.attachment = request.FILES['attachment']
        
        try:
            complaint.save()
            messages.success(request, 'Reporte QA actualizado exitosamente.')
            return redirect('qa_complaint_detail', pk=complaint.pk)
        except Exception as e:
            messages.error(request, f'Error al actualizar el reporte: {str(e)}')
    
    companies = Company.objects.all().order_by('name')
    users = User.objects.filter(
        Q(is_staff=True) | Q(groups__name='Agentes')
    ).distinct().order_by('username')
    
    context = {
        'complaint': complaint,
        'companies': companies,
        'users': users,
        'type_choices': QAComplaint.TYPE_CHOICES,
        'priority_choices': QAComplaint.PRIORITY_CHOICES,
        'status_choices': QAComplaint.STATUS_CHOICES,
        'page_title': f'Editar Reporte QA: {complaint.title}',
    }
    
    return render(request, 'tickets/qa_complaint_form.html', context)


@login_required
def qa_complaint_delete(request, pk):
    """Vista para eliminar queja o sugerencia QA"""
    from .models import QAComplaint
    
    try:
        complaint = QAComplaint.objects.get(pk=pk)
    except QAComplaint.DoesNotExist:
        messages.error(request, 'El reporte QA solicitado no existe.')
        return redirect('qa_complaint_list')
    
    # Verificar permisos
    if not request.user.is_staff and not request.user.is_superuser:
        messages.error(request, 'No tienes permisos para eliminar este reporte.')
        return redirect('qa_complaint_detail', pk=pk)
    
    if request.method == 'POST':
        title = complaint.title
        complaint.delete()
        messages.success(request, f'Reporte QA "{title}" eliminado exitosamente.')
        return redirect('qa_complaint_list')
    
    context = {
        'complaint': complaint,
        'page_title': f'Eliminar Reporte QA: {complaint.title}',
    }
    
    return render(request, 'tickets/qa_complaint_delete.html', context)


@login_required
def qa_complaint_assign(request, pk):
    """Vista para asignar queja o sugerencia QA a un usuario"""
    from django.http import JsonResponse
    from .models import QAComplaint
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'})
    
    try:
        complaint = QAComplaint.objects.get(pk=pk)
    except QAComplaint.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Reporte no encontrado'})
    
    # Verificar permisos
    if not complaint.can_edit(request.user):
        return JsonResponse({'success': False, 'error': 'Sin permisos'})
    
    assigned_to_id = request.POST.get('assigned_to')
    
    try:
        if assigned_to_id:
            assigned_user = User.objects.get(pk=assigned_to_id)
            complaint.assign_to(assigned_user)
            message = f'Reporte asignado a {assigned_user.get_full_name() or assigned_user.username}'
        else:
            complaint.assigned_to = None
            complaint.save()
            message = 'Asignación removida del reporte'
        
        return JsonResponse({
            'success': True,
            'message': message,
            'status': complaint.get_status_display(),
            'assigned_to': complaint.assigned_to.get_full_name() if complaint.assigned_to else None
        })
        
    except User.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Usuario no encontrado'})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)})


@login_required
def qa_complaint_resolve(request, pk):
    """Vista para resolver queja o sugerencia QA"""
    from django.http import JsonResponse
    from .models import QAComplaint
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'})
    
    try:
        complaint = QAComplaint.objects.get(pk=pk)
    except QAComplaint.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Reporte no encontrado'})
    
    # Verificar permisos
    if not complaint.can_resolve(request.user):
        return JsonResponse({'success': False, 'error': 'Sin permisos para resolver'})
    
    resolution_text = request.POST.get('resolution')
    
    if not resolution_text:
        return JsonResponse({'success': False, 'error': 'La resolución es requerida'})
    
    try:
        complaint.resolve(resolution_text, request.user)
        
        return JsonResponse({
            'success': True,
            'message': 'Reporte marcado como resuelto',
            'status': complaint.get_status_display(),
            'resolution_date': complaint.resolution_date.strftime('%d/%m/%Y %H:%M') if complaint.resolution_date else None
        })
        
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)})


@login_required
def qa_dashboard(request):
    """Dashboard de QA con estadísticas y métricas"""
    from django.db.models import Count, Q, Avg
    from datetime import timedelta
    from .models import QAComplaint
    
    # Estadísticas generales
    total_complaints = QAComplaint.objects.count()
    open_complaints = QAComplaint.objects.filter(status='open').count()
    resolved_complaints = QAComplaint.objects.filter(status='resolved').count()
    overdue_complaints = QAComplaint.objects.filter(
        status__in=['open', 'in_progress'],
        created_at__lt=timezone.now() - timedelta(days=7)
    ).count()
    
    # Estadísticas por tipo
    type_stats = QAComplaint.objects.values('type').annotate(
        count=Count('id')
    ).order_by('-count')
    
    # Estadísticas por empresa
    company_stats = QAComplaint.objects.values(
        'company__name'
    ).annotate(
        count=Count('id')
    ).order_by('-count')[:10]
    
    # Estadísticas por prioridad
    priority_stats = QAComplaint.objects.values('priority').annotate(
        count=Count('id')
    ).order_by('-count')
    
    # Reportes recientes
    recent_complaints = QAComplaint.objects.select_related(
        'company', 'reported_by'
    ).order_by('-created_at')[:10]
    
    # Mis asignaciones
    my_assignments = QAComplaint.objects.filter(
        assigned_to=request.user
    ).exclude(status__in=['resolved', 'closed']).order_by('-priority', '-created_at')
    
    context = {
        'total_complaints': total_complaints,
        'open_complaints': open_complaints,
        'resolved_complaints': resolved_complaints,
        'overdue_complaints': overdue_complaints,
        'type_stats': type_stats,
        'company_stats': company_stats,
        'priority_stats': priority_stats,
        'recent_complaints': recent_complaints,
        'my_assignments': my_assignments,
        'page_title': 'Dashboard QA',
    }
    
    return render(request, 'tickets/qa_dashboard.html', context)


# ==================== VISTAS DE CONTROL DE ACTIVOS ====================

@login_required
def asset_list(request):
    """Lista todos los activos con filtros"""
    assets_list = Asset.objects.select_related('assigned_to', 'created_by').all()
    
    # Filtros
    status_filter = request.GET.get('status')
    assigned_filter = request.GET.get('assigned')
    search = request.GET.get('search')
    
    if status_filter:
        assets_list = assets_list.filter(status=status_filter)
    
    if assigned_filter == 'assigned':
        assets_list = assets_list.filter(assigned_to__isnull=False)
    elif assigned_filter == 'unassigned':
        assets_list = assets_list.filter(assigned_to__isnull=True)
    
    if search:
        assets_list = assets_list.filter(
            Q(name__icontains=search) |
            Q(manufacturer__icontains=search) |
            Q(serial_number__icontains=search) |
            Q(description__icontains=search)
        )
    
    # Paginación
    paginator = Paginator(assets_list, 20)
    page_number = request.GET.get('page')
    assets = paginator.get_page(page_number)
    
    # Estadísticas
    total_assets = Asset.objects.count()
    assigned_assets = Asset.objects.filter(assigned_to__isnull=False).count()
    available_assets = Asset.objects.filter(status='available').count()
    maintenance_assets = Asset.objects.filter(status='maintenance').count()
    
    context = {
        'assets': assets,
        'status_choices': Asset.STATUS_CHOICES,
        'status_filter': status_filter,
        'assigned_filter': assigned_filter,
        'search': search,
        'total_assets': total_assets,
        'assigned_assets': assigned_assets,
        'available_assets': available_assets,
        'maintenance_assets': maintenance_assets,
        'title': 'Control de Activos'
    }
    
    return render(request, 'tickets/asset_list.html', context)


@login_required
def asset_detail(request, pk):
    """Detalle de un activo"""
    asset = get_object_or_404(Asset, pk=pk)
    history = asset.history.select_related('previous_employee', 'new_employee', 'performed_by').all()[:10]
    
    context = {
        'asset': asset,
        'history': history,
        'title': f'Activo: {asset.name}'
    }
    
    return render(request, 'tickets/asset_detail.html', context)


@login_required
def asset_create(request):
    """Crear un nuevo activo"""
    if request.method == 'POST':
        form = AssetForm(request.POST)
        if form.is_valid():
            asset = form.save(commit=False)
            asset.created_by = request.user
            asset.save()
            
            # Crear registro en el historial
            AssetHistory.objects.create(
                asset=asset,
                action='created',
                new_status=asset.status,
                reason='Activo creado en el sistema',
                performed_by=request.user
            )
            
            messages.success(request, f'Activo "{asset.name}" creado exitosamente.')
            return redirect('asset_detail', pk=asset.pk)
    else:
        form = AssetForm()
    
    context = {
        'form': form,
        'title': 'Crear Nuevo Activo',
        'submit_text': 'Crear Activo'
    }
    
    return render(request, 'tickets/asset_form.html', context)


@login_required
def asset_edit(request, pk):
    """Editar un activo existente"""
    asset = get_object_or_404(Asset, pk=pk)
    original_status = asset.status
    original_assigned = asset.assigned_to
    
    if request.method == 'POST':
        form = AssetForm(request.POST, instance=asset)
        if form.is_valid():
            asset = form.save()
            
            # Registrar cambios en el historial
            changes = []
            
            if original_status != asset.status:
                AssetHistory.objects.create(
                    asset=asset,
                    action='status_changed',
                    previous_status=original_status,
                    new_status=asset.status,
                    reason=f'Estado cambiado de {original_status} a {asset.status}',
                    performed_by=request.user
                )
                changes.append('estado')
            
            if original_assigned != asset.assigned_to:
                action = 'assigned' if asset.assigned_to else 'unassigned'
                if original_assigned and asset.assigned_to:
                    action = 'transferred'
                
                AssetHistory.objects.create(
                    asset=asset,
                    action=action,
                    previous_employee=original_assigned,
                    new_employee=asset.assigned_to,
                    reason=f'Asignación actualizada',
                    performed_by=request.user
                )
                changes.append('asignación')
            
            if changes:
                messages.success(request, f'Activo actualizado exitosamente. Cambios: {", ".join(changes)}.')
            else:
                messages.success(request, 'Activo actualizado exitosamente.')
            
            return redirect('asset_detail', pk=asset.pk)
    else:
        form = AssetForm(instance=asset)
    
    context = {
        'form': form,
        'asset': asset,
        'title': f'Editar Activo: {asset.name}',
        'submit_text': 'Actualizar Activo'
    }
    
    return render(request, 'tickets/asset_form.html', context)


@login_required
def asset_delete(request, pk):
    """Eliminar un activo"""
    asset = get_object_or_404(Asset, pk=pk)
    
    if request.method == 'POST':
        asset_name = asset.name
        asset.delete()
        messages.success(request, f'Activo "{asset_name}" eliminado exitosamente.')
        return redirect('asset_list')
    
    context = {
        'asset': asset,
        'title': f'Eliminar Activo: {asset.name}'
    }
    
    return render(request, 'tickets/asset_delete.html', context)


@login_required
def asset_assign(request, pk):
    """Asignar o reasignar un activo a un empleado"""
    asset = get_object_or_404(Asset, pk=pk)
    previous_employee = asset.assigned_to
    
    if request.method == 'POST':
        form = AssetAssignForm(request.POST, instance=asset)
        if form.is_valid():
            asset = form.save()  # El método save() del modelo actualizará automáticamente el status
            new_employee = asset.assigned_to
            reason = form.cleaned_data.get('reason', '')
            
            # Determinar la acción
            if previous_employee and new_employee:
                action = 'transferred'
                message = f'Activo transferido de {previous_employee} a {new_employee}'
            elif new_employee:
                action = 'assigned'
                message = f'Activo asignado a {new_employee}'
            else:
                action = 'unassigned'
                message = f'Activo desasignado de {previous_employee}'
            
            # Registrar en el historial
            AssetHistory.objects.create(
                asset=asset,
                action=action,
                previous_employee=previous_employee,
                new_employee=new_employee,
                new_status=asset.status,
                reason=reason or message,
                performed_by=request.user
            )
            
            messages.success(request, message)
            return redirect('asset_detail', pk=asset.pk)
    else:
        form = AssetAssignForm(instance=asset)
    
    context = {
        'form': form,
        'asset': asset,
        'title': f'Asignar Activo: {asset.name}'
    }
    
    return render(request, 'tickets/asset_assign.html', context)


@login_required
def asset_history(request, pk):
    """Ver historial completo de un activo"""
    asset = get_object_or_404(Asset, pk=pk)
    history = asset.history.select_related('previous_employee', 'new_employee', 'performed_by').all()
    
    # Paginación
    paginator = Paginator(history, 20)
    page_number = request.GET.get('page')
    history_page = paginator.get_page(page_number)
    
    context = {
        'asset': asset,
        'history': history_page,
        'title': f'Historial: {asset.name}'
    }
    
    return render(request, 'tickets/asset_history.html', context)


@login_required
def asset_maintenance(request, pk):
    """Enviar activo a mantenimiento"""
    asset = get_object_or_404(Asset, pk=pk)
    
    if request.method == 'POST':
        reason = request.POST.get('reason', 'Enviado a mantenimiento')
        previous_status = asset.status
        previous_employee = asset.assigned_to
        
        # Cambiar estado y desasignar si es necesario
        asset.status = 'maintenance'
        asset.assigned_to = None
        asset.save()
        
        # Registrar en historial
        AssetHistory.objects.create(
            asset=asset,
            action='maintenance',
            previous_status=previous_status,
            new_status='maintenance',
            previous_employee=previous_employee,
            reason=reason,
            performed_by=request.user
        )
        
        messages.success(request, f'Activo "{asset.name}" enviado a mantenimiento.')
        return redirect('asset_detail', pk=asset.pk)
    
    context = {
        'asset': asset,
        'title': f'Enviar a Mantenimiento: {asset.name}'
    }
    
    return render(request, 'tickets/asset_maintenance.html', context)


# ==========================================
# VISTAS PARA TUTOR IA
# ==========================================

@login_required
def ai_tutor_list(request):
    """Lista de tutores IA"""
    # Filtros
    status_filter = request.GET.get('status')
    visibility_filter = request.GET.get('visibility')
    search = request.GET.get('search')
    
    # Query base
    tutors = AITutor.objects.all()
    
    # Aplicar filtros de visibilidad
    if visibility_filter == 'private':
        tutors = tutors.filter(created_by=request.user)
    elif visibility_filter == 'public':
        tutors = tutors.filter(is_private=False)
    else:
        # Mostrar solo tutores públicos o propios
        tutors = tutors.filter(
            Q(is_private=False) | Q(created_by=request.user)
        )
    
    # Aplicar otros filtros
    if status_filter:
        tutors = tutors.filter(status=status_filter)
    
    if search:
        tutors = tutors.filter(
            Q(title__icontains=search) |
            Q(objective__icontains=search)
        )
    
    # Seleccionar datos relacionados
    tutors = tutors.select_related('created_by').prefetch_related('progress_reports')
    
    # Estadísticas
    total_tutors = tutors.count()
    active_tutors = tutors.filter(status='active').count()
    completed_tutors = tutors.filter(status='completed').count()
    my_tutors = tutors.filter(created_by=request.user).count()
    
    # Paginación
    paginator = Paginator(tutors, 12)  # 12 tutores por página
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'tutors': page_obj,
        'total_tutors': total_tutors,
        'active_tutors': active_tutors,
        'completed_tutors': completed_tutors,
        'my_tutors': my_tutors,
        'status_choices': AITutor.STATUS_CHOICES,
        'status_filter': status_filter,
        'visibility_filter': visibility_filter,
        'search': search,
        'title': 'Tutor IA'
    }
    
    return render(request, 'tickets/ai_tutor_list.html', context)


@login_required
@login_required
def ai_tutor_create(request):
    """Crear un nuevo tutor IA"""
    if request.method == 'POST':
        form = AITutorForm(request.POST)
        print(f"DEBUG: POST data: {request.POST}")
        print(f"DEBUG: Form is_valid: {form.is_valid()}")
        if not form.is_valid():
            print(f"DEBUG: Form errors: {form.errors}")
        
        if form.is_valid():
            tutor = form.save(commit=False)
            tutor.created_by = request.user
            tutor.save()
            
            messages.success(request, f'Tutor IA "{tutor.title}" creado exitosamente.')
            print(f"DEBUG: Tutor created with ID: {tutor.pk}")
            return redirect('ai_tutor_detail', pk=tutor.pk)
    else:
        form = AITutorForm()
    
    context = {
        'form': form,
        'title': 'Crear Tutor IA'
    }
    
    return render(request, 'tickets/ai_tutor_form.html', context)


@login_required
def ai_tutor_detail(request, pk):
    """Ver detalles del tutor IA"""
    tutor = get_object_or_404(AITutor, pk=pk)
    
    # Verificar permisos
    if tutor.is_private and tutor.created_by != request.user:
        messages.error(request, 'No tienes permisos para ver este tutor.')
        return redirect('ai_tutor_list')
    
    # Obtener reportes de progreso
    progress_reports = tutor.progress_reports.select_related('created_by').prefetch_related('attachments')
    
    # Obtener adjuntos del tutor principal
    tutor_attachments = tutor.attachments.all()
    
    context = {
        'tutor': tutor,
        'progress_reports': progress_reports,
        'tutor_attachments': tutor_attachments,
        'title': f'Tutor IA: {tutor.title}'
    }
    
    return render(request, 'tickets/ai_tutor_detail.html', context)


@login_required
@login_required
def ai_tutor_edit(request, pk):
    """Editar tutor IA"""
    tutor = get_object_or_404(AITutor, pk=pk)
    
    # Verificar permisos
    if tutor.created_by != request.user:
        messages.error(request, 'Solo puedes editar tus propios tutores.')
        return redirect('ai_tutor_detail', pk=pk)
    
    if request.method == 'POST':
        form = AITutorForm(request.POST, instance=tutor)
        print(f"DEBUG EDIT: POST data: {request.POST}")
        print(f"DEBUG EDIT: Form is_valid: {form.is_valid()}")
        if not form.is_valid():
            print(f"DEBUG EDIT: Form errors: {form.errors}")
            
        if form.is_valid():
            form.save()
            messages.success(request, f'Tutor IA "{tutor.title}" actualizado exitosamente.')
            print(f"DEBUG EDIT: Tutor updated with ID: {tutor.pk}")
            return redirect('ai_tutor_detail', pk=tutor.pk)
    else:
        form = AITutorForm(instance=tutor)
    
    context = {
        'form': form,
        'tutor': tutor,
        'title': f'Editar Tutor: {tutor.title}'
    }
    
    return render(request, 'tickets/ai_tutor_form.html', context)


@login_required
def ai_tutor_delete(request, pk):
    """Eliminar tutor IA"""
    tutor = get_object_or_404(AITutor, pk=pk)
    
    # Verificar permisos
    if tutor.created_by != request.user:
        messages.error(request, 'Solo puedes eliminar tus propios tutores.')
        return redirect('ai_tutor_detail', pk=pk)
    
    if request.method == 'POST':
        tutor_title = tutor.title
        tutor.delete()
        messages.success(request, f'Tutor IA "{tutor_title}" eliminado exitosamente.')
        return redirect('ai_tutor_list')
    
    context = {
        'tutor': tutor,
        'title': f'Eliminar Tutor: {tutor.title}'
    }
    
    return render(request, 'tickets/ai_tutor_delete.html', context)


@login_required
def ai_tutor_progress_report(request, pk):
    """Crear reporte de progreso"""
    tutor = get_object_or_404(AITutor, pk=pk)
    
    # Verificar permisos
    if tutor.is_private and tutor.created_by != request.user:
        messages.error(request, 'No tienes permisos para reportar en este tutor.')
        return redirect('ai_tutor_list')
    
    if request.method == 'POST':
        form = AITutorProgressReportForm(request.POST)
        attachment_form = AITutorAttachmentForm(request.POST, request.FILES)
        
        if form.is_valid():
            progress_report = form.save(commit=False)
            progress_report.tutor = tutor
            progress_report.created_by = request.user
            
            # Aquí se podría integrar con OpenAI API para generar feedback
            progress_report.ai_feedback = generate_ai_feedback(progress_report)
            progress_report.ai_recommendations = generate_ai_recommendations(progress_report)
            
            progress_report.save()
            
            # Manejar adjunto si se subió
            if attachment_form.is_valid() and request.FILES.get('file'):
                attachment = attachment_form.save(commit=False)
                attachment.progress_report = progress_report
                attachment.uploaded_by = request.user
                attachment.save()
                
                # Generar análisis del archivo con IA
                attachment.ai_analysis = generate_file_analysis(attachment)
                attachment.save()
            
            messages.success(request, 'Reporte de progreso creado exitosamente.')
            return redirect('ai_tutor_detail', pk=tutor.pk)
    else:
        form = AITutorProgressReportForm()
        attachment_form = AITutorAttachmentForm()
    
    context = {
        'form': form,
        'attachment_form': attachment_form,
        'tutor': tutor,
        'title': f'Reportar Progreso: {tutor.title}'
    }
    
    return render(request, 'tickets/ai_tutor_progress_form.html', context)


@login_required
def ai_tutor_upload_attachment(request, pk):
    """Subir adjunto al tutor principal"""
    tutor = get_object_or_404(AITutor, pk=pk)
    
    # Verificar permisos
    if tutor.is_private and tutor.created_by != request.user:
        messages.error(request, 'No tienes permisos para subir archivos a este tutor.')
        return redirect('ai_tutor_list')
    
    if request.method == 'POST':
        form = AITutorAttachmentForm(request.POST, request.FILES)
        if form.is_valid():
            attachment = form.save(commit=False)
            attachment.tutor = tutor
            attachment.uploaded_by = request.user
            attachment.save()
            
            # Generar análisis del archivo con IA
            attachment.ai_analysis = generate_file_analysis(attachment)
            attachment.save()
            
            messages.success(request, 'Archivo subido exitosamente.')
            return redirect('ai_tutor_detail', pk=tutor.pk)
    else:
        form = AITutorAttachmentForm()
    
    context = {
        'form': form,
        'tutor': tutor,
        'title': f'Subir Archivo: {tutor.title}'
    }
    
    return render(request, 'tickets/ai_tutor_attachment_form.html', context)


@login_required
def ai_tutor_generate_feedback_ajax(request, pk):
    """Generar feedback IA via AJAX"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        progress_report = get_object_or_404(AITutorProgressReport, pk=pk)
        
        # Verificar permisos
        if progress_report.tutor.is_private and progress_report.tutor.created_by != request.user:
            return JsonResponse({'error': 'No tienes permisos'}, status=403)
        
        # Generar feedback y recomendaciones
        feedback = generate_ai_feedback(progress_report)
        recommendations = generate_ai_recommendations(progress_report)
        
        # Actualizar el reporte
        progress_report.ai_feedback = feedback
        progress_report.ai_recommendations = recommendations
        progress_report.save()
        
        return JsonResponse({
            'success': True,
            'feedback': feedback,
            'recommendations': recommendations
        })
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


# Funciones de utilidad para IA con integración a ChatGPT
def generate_ai_feedback(progress_report):
    """Generar feedback con IA basado en el reporte de progreso"""
    try:
        from openai import OpenAI
        from .models import SystemConfiguration
        
        # Obtener API key desde configuración del sistema
        config = SystemConfiguration.get_config()
        api_key = getattr(config, 'openai_api_key', None)
        
        if not api_key:
            return "Por favor configura tu API key de OpenAI en la configuración del sistema para recibir feedback personalizado."
        
        # Configurar cliente OpenAI
        client = OpenAI(api_key=api_key)
        
        # Crear el prompt para ChatGPT con rol de experimentado profesor
        system_prompt = """Eres un experimentado profesor y tutor especializado en guiar estudiantes hacia el éxito académico y profesional. 
        Tienes más de 15 años de experiencia enseñando y mentoreando a estudiantes de diversos niveles.
        
        Tu enfoque es:
        - Constructivo y motivador
        - Específico y actionable
        - Personalizado según el contexto del estudiante
        - Basado en metodologías pedagógicas comprobadas
        - Empático pero directo cuando es necesario
        
        IMPORTANTE: Siempre responde en texto plano, sin usar formato Markdown, asteriscos, guiones especiales o símbolos de formato. 
        Escribe como si estuvieras hablando directamente con el estudiante."""
        
        user_prompt = f"""
        INFORMACIÓN DEL ESTUDIANTE:
        - Objetivo que persigue: {progress_report.tutor.objective}
        - Estado inicial al comenzar: {progress_report.tutor.current_state}
        - Contexto personal/profesional: {progress_report.tutor.context}

        PROGRESO REPORTADO:
        {progress_report.progress_description}

        DESAFÍOS Y DIFICULTADES:
        {progress_report.challenges or 'No mencionó desafíos específicos'}

        Como experimentado profesor, analiza este progreso y proporciona:
        1. Feedback específico sobre lo logrado
        2. Puntos donde puede mejorar
        3. Motivación personalizada para continuar
        
        IMPORTANTE: Responde en texto plano, sin usar formato Markdown, asteriscos, guiones o símbolos especiales. 
        Escribe como si estuvieras hablando directamente con el estudiante en una conversación natural.
        Mantén un tono profesional pero cercano, como un mentor experimentado que realmente se preocupa por el éxito del estudiante.
        """
        
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            max_tokens=400,
            temperature=0.7
        )
        
        return response.choices[0].message.content.strip()
        
    except Exception as e:
        print(f"Error generando feedback con IA: {e}")
        return f"Excelente progreso en '{progress_report.tutor.title}'. Como tu tutor, veo que estás avanzando bien hacia tu objetivo. Continúa con el buen trabajo y no dudes en reportar tus próximos avances."
        
    except Exception as e:
        return f"Feedback automático: Excelente progreso en '{progress_report.tutor.title}'. Basado en tu reporte, pareces estar avanzando bien hacia tu objetivo. Continúa con el buen trabajo."


def generate_ai_recommendations(progress_report):
    """Generar recomendaciones con IA"""
    try:
        from openai import OpenAI
        from .models import SystemConfiguration
        
        # Obtener API key desde configuración del sistema
        config = SystemConfiguration.get_config()
        api_key = getattr(config, 'openai_api_key', None)
        
        if not api_key:
            return "1. Continúa practicando regularmente\n2. Documenta tu progreso\n3. Busca recursos adicionales cuando sea necesario\n4. Establece metas pequeñas y alcanzables\n5. Revisa y ajusta tu enfoque según sea necesario"
        
        # Configurar cliente OpenAI
        client = OpenAI(api_key=api_key)
        
        # Crear el prompt para recomendaciones como experimentado profesor
        system_prompt = """Eres un experimentado profesor con más de 15 años de experiencia en educación y mentoría. 
        Tu especialidad es crear planes de acción específicos y recomendaciones personalizadas que realmente funcionan.
        
        Generas recomendaciones que son:
        - Específicas y accionables
        - Adaptadas al nivel del estudiante
        - Progresivas y bien estructuradas
        - Basadas en metodologías pedagógicas comprobadas
        
        IMPORTANTE: Siempre responde en texto plano, sin usar formato Markdown, asteriscos, guiones especiales o símbolos de formato. 
        Usa solo numeración simple (1. 2. 3.) para las listas."""
        
        user_prompt = f"""
        PERFIL DEL ESTUDIANTE:
        - Objetivo principal: {progress_report.tutor.objective}
        - Punto de partida: {progress_report.tutor.current_state}
        - Contexto: {progress_report.tutor.context}

        ÚLTIMO REPORTE DE PROGRESO:
        {progress_report.progress_description}

        DESAFÍOS IDENTIFICADOS:
        {progress_report.challenges or 'No se mencionaron desafíos específicos'}

        Como experimentado profesor, genera 4-5 recomendaciones específicas y accionables para el siguiente período de estudio.
        
        FORMATO REQUERIDO - TEXTO PLANO:
        1. [Primera recomendación específica con acción clara]
        2. [Segunda recomendación específica con acción clara]
        3. [Tercera recomendación específica con acción clara]
        4. [Cuarta recomendación específica con acción clara]
        5. [Quinta recomendación específica con acción clara]
        
        IMPORTANTE: 
        - Usa SOLO texto plano, sin formato Markdown
        - No uses asteriscos, guiones largos, o símbolos especiales
        - Numera simplemente con 1. 2. 3. etc.
        - Escribe cada recomendación como una oración completa y clara
        - Cada recomendación debe ser específica, actionable y apropiada para el nivel del estudiante
        """
        
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            max_tokens=350,
            temperature=0.7
        )
        
        return response.choices[0].message.content.strip()
        
    except Exception as e:
        print(f"Error generando recomendaciones con IA: {e}")
        return "1. Continúa practicando regularmente con ejercicios específicos\n2. Documenta tu progreso y reflexiona sobre lo aprendido\n3. Busca recursos adicionales que complementen tu aprendizaje\n4. Establece metas pequeñas y medibles para la próxima semana\n5. Considera buscar feedback de otros expertos en el área"
        
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "Eres un tutor experto que da recomendaciones prácticas y específicas."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=250,
            temperature=0.7
        )
        
        return response.choices[0].message.content.strip()
        
    except Exception as e:
        return "1. Continúa con las estrategias que están funcionando.\n2. Considera documentar tus procesos para futuras referencias.\n3. Establece pequeños hitos para mantener la motivación."


def generate_file_analysis(attachment):
    """Analizar archivo con IA"""
    import openai
    import os
    
    try:
        # Configurar OpenAI API
        openai.api_key = os.getenv('OPENAI_API_KEY')
        
        if not openai.api_key:
            return f"Archivo '{attachment.original_filename}' recibido. Para análisis automático, configura tu API key de OpenAI."
        
        # Para archivos de texto, podríamos leer el contenido y analizarlo
        # Por ahora, haremos un análisis básico basado en el nombre y descripción
        prompt = f"""
        Eres {attachment.tutor.tutor_persona}.
        
        CONTEXTO DEL TUTOR:
        - Objetivo: {attachment.tutor.objective}
        
        ARCHIVO SUBIDO:
        - Nombre: {attachment.original_filename}
        - Descripción del usuario: {attachment.description}
        
        Proporciona un breve análisis de cómo este archivo puede ser útil para el objetivo de aprendizaje.
        """
        
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "Eres un tutor que analiza recursos de aprendizaje."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=150,
            temperature=0.7
        )
        
        return response.choices[0].message.content.strip()
        
    except Exception as e:
        return f"Archivo '{attachment.original_filename}' analizado. Contiene información relevante para tu objetivo de aprendizaje."


@login_required
def ai_tutor_optimize_config(request):
    """Optimizar configuración del tutor con IA"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        import json
        from openai import OpenAI
        from .models import SystemConfiguration
        
        # Obtener datos del formulario
        data = json.loads(request.body)
        title = data.get('title', '').strip()
        objective = data.get('objective', '').strip()
        current_state = data.get('current_state', '').strip()
        context = data.get('context', '').strip()
        
        # Validar que hay datos para optimizar
        if not title and not objective:
            return JsonResponse({'error': 'Se requiere al menos título y objetivo para optimizar'}, status=400)
        
        # Obtener API key desde configuración del sistema
        config = SystemConfiguration.get_config()
        api_key = getattr(config, 'openai_api_key', None)
        
        if not api_key:
            return JsonResponse({'error': 'API key de OpenAI no configurada en el sistema'}, status=500)
        
        # Configurar cliente OpenAI
        client = OpenAI(api_key=api_key)
        
        # Crear prompt para optimización
        system_prompt = """Eres un experimentado profesor con más de 15 años de experiencia en educación y diseño de planes de aprendizaje personalizados.
        
        Tu tarea es analizar y mejorar la configuración de un tutor IA para maximizar el éxito del estudiante.
        
        Principios que sigues:
        - Objetivos SMART (Específicos, Medibles, Alcanzables, Relevantes, Temporales)
        - Personalización basada en el contexto del estudiante
        - Claridad y precisión en la comunicación
        - Metodologías pedagógicas comprobadas
        
        IMPORTANTE: Responde en texto plano, sin formato Markdown, asteriscos o símbolos especiales."""
        
        user_prompt = f"""
        CONFIGURACIÓN ACTUAL DEL TUTOR:
        - Título: {title}
        - Objetivo: {objective}
        - Estado actual: {current_state}
        - Contexto: {context}
        
        Como experimentado profesor, analiza y mejora esta configuración:
        
        1. Revisa el título: ¿Es claro y descriptivo?
        2. Optimiza el objetivo: ¿Sigue principios SMART?
        3. Mejora la descripción del estado actual: ¿Es específica y útil?
        4. Enriquece el contexto: ¿Proporciona información relevante para personalizar el aprendizaje?
        
        Devuelve una respuesta en formato JSON con las siguientes claves:
        - "title": título mejorado (máximo 200 caracteres)
        - "objective": objetivo optimizado (máximo 1000 caracteres)
        - "current_state": estado actual mejorado (máximo 1000 caracteres)
        - "context": contexto enriquecido (máximo 1000 caracteres)
        
        Si algún campo original está vacío o es muy corto, créalo basándote en la información disponible.
        Mantén la esencia de lo que el usuario quiere lograr pero hazlo más claro, específico y educativamente sólido.
        """
        
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            max_tokens=800,
            temperature=0.7
        )
        
        ai_response = response.choices[0].message.content.strip()
        
        # Intentar parsear como JSON
        try:
            optimized_config = json.loads(ai_response)
        except json.JSONDecodeError:
            # Si no es JSON válido, extraer manualmente
            optimized_config = {
                'title': title or 'Objetivo de Aprendizaje Personalizado',
                'objective': objective or 'Objetivo de aprendizaje mejorado por IA',
                'current_state': current_state or 'Estado inicial analizado por IA',
                'context': context or 'Contexto enriquecido por IA'
            }
        
        return JsonResponse({
            'success': True,
            'optimized': optimized_config,
            'message': 'Configuración optimizada por tu profesor IA'
        })
        
    except Exception as e:
        print(f"Error optimizando configuración: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Error al optimizar la configuración'
        })


# ================================
# VISTAS PARA RENDICIÓN DE GASTOS
# ================================

@login_required
def expense_report_list(request):
    """Lista de rendiciones de gastos"""
    # Filtrar por rol de usuario
    if is_agent(request.user):
        # Los agentes ven todas las rendiciones
        queryset = ExpenseReport.objects.all()
    else:
        # Los empleados solo ven sus propias rendiciones
        queryset = ExpenseReport.objects.filter(employee=request.user)
    
    # Aplicar filtros
    form = ExpenseReportFilterForm(request.GET)
    if form.is_valid():
        if form.cleaned_data.get('status'):
            queryset = queryset.filter(status=form.cleaned_data['status'])
        if form.cleaned_data.get('employee') and is_agent(request.user):
            queryset = queryset.filter(employee=form.cleaned_data['employee'])
        if form.cleaned_data.get('start_date'):
            queryset = queryset.filter(created_at__gte=form.cleaned_data['start_date'])
        if form.cleaned_data.get('end_date'):
            queryset = queryset.filter(created_at__lte=form.cleaned_data['end_date'])
        if form.cleaned_data.get('search'):
            search = form.cleaned_data['search']
            queryset = queryset.filter(
                Q(title__icontains=search) | 
                Q(description__icontains=search)
            )
    
    queryset = queryset.select_related('employee', 'company', 'approved_by').order_by('-created_at')
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(queryset, 20)
    page_number = request.GET.get('page')
    expense_reports = paginator.get_page(page_number)
    
    context = {
        'expense_reports': expense_reports,
        'form': form,
        'title': 'Rendiciones de Gastos',
        'is_agent': is_agent(request.user),
    }
    
    return render(request, 'tickets/expense_report_list.html', context)


@login_required
def expense_report_create(request):
    """Crear nueva rendición de gastos"""
    if request.method == 'POST':
        form = ExpenseReportForm(request.POST)
        if form.is_valid():
            expense_report = form.save(commit=False)
            expense_report.employee = request.user
            # Asignar empresa del usuario si tiene
            try:
                expense_report.company = request.user.profile.company
            except:
                pass
            expense_report.save()
            messages.success(request, 'Rendición de gastos creada exitosamente.')
            return redirect('expense_report_detail', pk=expense_report.pk)
    else:
        form = ExpenseReportForm()
    
    context = {
        'form': form,
        'title': 'Nueva Rendición de Gastos',
        'action': 'Crear'
    }
    
    return render(request, 'tickets/expense_report_form.html', context)


@login_required
def expense_report_detail(request, pk):
    """Detalle de rendición de gastos"""
    expense_report = get_object_or_404(ExpenseReport, pk=pk)
    
    # Verificar permisos
    if not is_agent(request.user) and expense_report.employee != request.user:
        messages.error(request, 'No tienes permisos para ver esta rendición.')
        return redirect('expense_report_list')
    
    # Obtener items de gastos
    expense_items = expense_report.expense_items.all().order_by('-date', '-created_at')
    
    # Obtener comentarios
    comments = expense_report.comments.all().order_by('-created_at')
    if not is_agent(request.user):
        # Los empleados no ven comentarios internos
        comments = comments.filter(is_internal=False)
    
    # Formulario de comentarios
    comment_form = ExpenseCommentForm()
    
    context = {
        'expense_report': expense_report,
        'expense_items': expense_items,
        'comments': comments,
        'comment_form': comment_form,
        'title': f'Rendición: {expense_report.title}',
        'is_agent': is_agent(request.user),
        'can_edit': expense_report.can_edit() and (
            expense_report.employee == request.user or is_agent(request.user)
        ),
        'can_submit': expense_report.can_submit() and expense_report.employee == request.user,
        'can_approve': expense_report.can_approve() and is_agent(request.user),
    }
    
    return render(request, 'tickets/expense_report_detail.html', context)


@login_required
def expense_report_edit(request, pk):
    """Editar rendición de gastos"""
    expense_report = get_object_or_404(ExpenseReport, pk=pk)
    
    # Verificar permisos
    if not expense_report.can_edit():
        messages.error(request, 'Esta rendición no puede ser editada.')
        return redirect('expense_report_detail', pk=pk)
    
    if not is_agent(request.user) and expense_report.employee != request.user:
        messages.error(request, 'No tienes permisos para editar esta rendición.')
        return redirect('expense_report_detail', pk=pk)
    
    if request.method == 'POST':
        form = ExpenseReportForm(request.POST, instance=expense_report)
        if form.is_valid():
            form.save()
            messages.success(request, 'Rendición actualizada exitosamente.')
            return redirect('expense_report_detail', pk=pk)
    else:
        form = ExpenseReportForm(instance=expense_report)
    
    context = {
        'form': form,
        'expense_report': expense_report,
        'title': f'Editar: {expense_report.title}',
        'action': 'Actualizar'
    }
    
    return render(request, 'tickets/expense_report_form.html', context)


@login_required
def expense_report_delete(request, pk):
    """Eliminar rendición de gastos"""
    expense_report = get_object_or_404(ExpenseReport, pk=pk)
    
    # Verificar permisos
    if not expense_report.can_edit():
        messages.error(request, 'Esta rendición no puede ser eliminada.')
        return redirect('expense_report_detail', pk=pk)
    
    if not is_agent(request.user) and expense_report.employee != request.user:
        messages.error(request, 'No tienes permisos para eliminar esta rendición.')
        return redirect('expense_report_detail', pk=pk)
    
    if request.method == 'POST':
        expense_report.delete()
        messages.success(request, 'Rendición eliminada exitosamente.')
        return redirect('expense_report_list')
    
    context = {
        'expense_report': expense_report,
        'title': f'Eliminar: {expense_report.title}'
    }
    
    return render(request, 'tickets/expense_report_delete.html', context)


@login_required
def expense_report_submit(request, pk):
    """Enviar rendición para aprobación"""
    expense_report = get_object_or_404(ExpenseReport, pk=pk)
    
    # Verificar permisos
    if not expense_report.can_submit() or expense_report.employee != request.user:
        messages.error(request, 'No puedes enviar esta rendición.')
        return redirect('expense_report_detail', pk=pk)
    
    if request.method == 'POST':
        expense_report.status = 'submitted'
        expense_report.submitted_at = timezone.now()
        expense_report.save()
        
        messages.success(request, 'Rendición enviada para aprobación.')
        return redirect('expense_report_detail', pk=pk)
    
    context = {
        'expense_report': expense_report,
        'title': f'Enviar: {expense_report.title}'
    }
    
    return render(request, 'tickets/expense_report_submit.html', context)


@login_required
def expense_report_approve(request, pk):
    """Aprobar rendición de gastos"""
    if not is_agent(request.user):
        messages.error(request, 'No tienes permisos para aprobar rendiciones.')
        return redirect('expense_report_detail', pk=pk)
    
    expense_report = get_object_or_404(ExpenseReport, pk=pk)
    
    if not expense_report.can_approve():
        messages.error(request, 'Esta rendición no puede ser aprobada.')
        return redirect('expense_report_detail', pk=pk)
    
    if request.method == 'POST':
        expense_report.status = 'approved'
        expense_report.approved_by = request.user
        expense_report.approved_at = timezone.now()
        expense_report.save()
        
        messages.success(request, 'Rendición aprobada exitosamente.')
        return redirect('expense_report_detail', pk=pk)
    
    context = {
        'expense_report': expense_report,
        'title': f'Aprobar: {expense_report.title}'
    }
    
    return render(request, 'tickets/expense_report_approve.html', context)


@login_required
def expense_report_reject(request, pk):
    """Rechazar rendición de gastos"""
    if not is_agent(request.user):
        messages.error(request, 'No tienes permisos para rechazar rendiciones.')
        return redirect('expense_report_detail', pk=pk)
    
    expense_report = get_object_or_404(ExpenseReport, pk=pk)
    
    if not expense_report.can_approve():
        messages.error(request, 'Esta rendición no puede ser rechazada.')
        return redirect('expense_report_detail', pk=pk)
    
    if request.method == 'POST':
        reason = request.POST.get('reason', '')
        if not reason:
            messages.error(request, 'Debes proporcionar un motivo de rechazo.')
            return redirect('expense_report_detail', pk=pk)
        
        expense_report.status = 'rejected'
        expense_report.rejection_reason = reason
        expense_report.save()
        
        messages.success(request, 'Rendición rechazada.')
        return redirect('expense_report_detail', pk=pk)
    
    context = {
        'expense_report': expense_report,
        'title': f'Rechazar: {expense_report.title}'
    }
    
    return render(request, 'tickets/expense_report_reject.html', context)


@login_required
def expense_report_mark_paid(request, pk):
    """Marcar rendición como pagada"""
    if not is_agent(request.user):
        messages.error(request, 'No tienes permisos para marcar como pagado.')
        return redirect('expense_report_detail', pk=pk)
    
    expense_report = get_object_or_404(ExpenseReport, pk=pk)
    
    if expense_report.status != 'approved':
        messages.error(request, 'Solo se pueden marcar como pagadas las rendiciones aprobadas.')
        return redirect('expense_report_detail', pk=pk)
    
    if request.method == 'POST':
        payment_reference = request.POST.get('payment_reference', '')
        expense_report.status = 'paid'
        expense_report.payment_reference = payment_reference
        expense_report.paid_at = timezone.now()
        expense_report.save()
        
        messages.success(request, 'Rendición marcada como pagada.')
        return redirect('expense_report_detail', pk=pk)
    
    context = {
        'expense_report': expense_report,
        'title': f'Marcar como Pagado: {expense_report.title}'
    }
    
    return render(request, 'tickets/expense_report_mark_paid.html', context)


@login_required
def expense_item_create(request, report_pk):
    """Crear nuevo item de gasto"""
    expense_report = get_object_or_404(ExpenseReport, pk=report_pk)
    
    # Verificar permisos
    if not expense_report.can_edit():
        messages.error(request, 'No se pueden agregar gastos a esta rendición.')
        return redirect('expense_report_detail', pk=report_pk)
    
    if not is_agent(request.user) and expense_report.employee != request.user:
        messages.error(request, 'No tienes permisos para agregar gastos a esta rendición.')
        return redirect('expense_report_detail', pk=report_pk)
    
    if request.method == 'POST':
        form = ExpenseItemForm(request.POST, request.FILES, expense_report=expense_report)
        print(f"DEBUG - Errores del formulario: {form.errors}")
        print(f"DEBUG - Datos POST: {request.POST}")
        print(f"DEBUG - Currency field: {form['currency']}")
        print(f"DEBUG - Currency choices: {form.fields['currency'].choices}")
        if form.is_valid():
            expense_item = form.save(commit=False)
            expense_item.expense_report = expense_report
            expense_item.save()
            messages.success(request, 'Gasto agregado exitosamente.')
            return redirect('expense_report_detail', pk=report_pk)
    else:
        form = ExpenseItemForm(expense_report=expense_report)
        print(f"DEBUG - Currency field GET: {form['currency']}")
        print(f"DEBUG - Currency choices GET: {form.fields['currency'].choices}")
        print(f"DEBUG - Currency initial GET: {form.fields['currency'].initial}")
    
    context = {
        'form': form,
        'expense_report': expense_report,
        'title': f'Agregar Gasto - {expense_report.title}',
        'action': 'Agregar'
    }
    
    return render(request, 'tickets/expense_item_form.html', context)


@login_required
def expense_item_edit(request, pk):
    """Editar item de gasto"""
    expense_item = get_object_or_404(ExpenseItem, pk=pk)
    expense_report = expense_item.expense_report
    
    # Verificar permisos
    if not expense_report.can_edit():
        messages.error(request, 'Esta rendición no puede ser editada.')
        return redirect('expense_report_detail', pk=expense_report.pk)
    
    if not is_agent(request.user) and expense_report.employee != request.user:
        messages.error(request, 'No tienes permisos para editar este gasto.')
        return redirect('expense_report_detail', pk=expense_report.pk)
    
    if request.method == 'POST':
        form = ExpenseItemForm(request.POST, request.FILES, instance=expense_item, expense_report=expense_report)
        if form.is_valid():
            form.save()
            messages.success(request, 'Gasto actualizado exitosamente.')
            return redirect('expense_report_detail', pk=expense_report.pk)
    else:
        form = ExpenseItemForm(instance=expense_item, expense_report=expense_report)
    
    context = {
        'form': form,
        'expense_item': expense_item,
        'expense_report': expense_report,
        'title': f'Editar Gasto - {expense_item.description}',
        'action': 'Actualizar'
    }
    
    return render(request, 'tickets/expense_item_form.html', context)


@login_required
def expense_item_delete(request, pk):
    """Eliminar item de gasto"""
    expense_item = get_object_or_404(ExpenseItem, pk=pk)
    expense_report = expense_item.expense_report
    
    # Verificar permisos
    if not expense_report.can_edit():
        messages.error(request, 'Esta rendición no puede ser editada.')
        return redirect('expense_report_detail', pk=expense_report.pk)
    
    if not is_agent(request.user) and expense_report.employee != request.user:
        messages.error(request, 'No tienes permisos para eliminar este gasto.')
        return redirect('expense_report_detail', pk=expense_report.pk)
    
    if request.method == 'POST':
        expense_item.delete()
        messages.success(request, 'Gasto eliminado exitosamente.')
        return redirect('expense_report_detail', pk=expense_report.pk)
    
    context = {
        'expense_item': expense_item,
        'expense_report': expense_report,
        'title': f'Eliminar Gasto - {expense_item.description}'
    }
    
    return render(request, 'tickets/expense_item_delete.html', context)


@login_required
def expense_comment_create(request, report_pk):
    """Crear comentario en rendición"""
    expense_report = get_object_or_404(ExpenseReport, pk=report_pk)
    
    # Verificar permisos de lectura
    if not is_agent(request.user) and expense_report.employee != request.user:
        messages.error(request, 'No tienes permisos para comentar en esta rendición.')
        return redirect('expense_report_detail', pk=report_pk)
    
    if request.method == 'POST':
        form = ExpenseCommentForm(request.POST)
        if form.is_valid():
            comment = form.save(commit=False)
            comment.expense_report = expense_report
            comment.user = request.user
            # Solo agentes pueden crear comentarios internos
            if not is_agent(request.user):
                comment.is_internal = False
            comment.save()
            messages.success(request, 'Comentario agregado exitosamente.')
        else:
            messages.error(request, 'Error al agregar el comentario.')
    
    return redirect('expense_report_detail', pk=report_pk)


# ============================================
# VISTAS PARA REUNIONES DE VIDEO
# ============================================

@login_required
def video_meeting_list(request):
    """Lista de reuniones de video"""
    from .models import VideoMeeting
    from .forms import MeetingFilterForm
    
    # Obtener todas las reuniones del usuario
    meetings = VideoMeeting.objects.all()
    
    # Filtrar por permisos
    if not is_agent(request.user):
        # Los empleados solo ven sus reuniones (organizadas o participan)
        meetings = meetings.filter(
            models.Q(organizer=request.user) | 
            models.Q(participants=request.user)
        ).distinct()
    
    # Aplicar filtros
    filter_form = MeetingFilterForm(request.GET, user=request.user)
    if filter_form.is_valid():
        if filter_form.cleaned_data.get('search'):
            search = filter_form.cleaned_data['search']
            meetings = meetings.filter(
                models.Q(title__icontains=search) |
                models.Q(description__icontains=search)
            )
        
        if filter_form.cleaned_data.get('status'):
            meetings = meetings.filter(status=filter_form.cleaned_data['status'])
        
        if filter_form.cleaned_data.get('transcription_status'):
            meetings = meetings.filter(
                transcription_status=filter_form.cleaned_data['transcription_status']
            )
        
        if filter_form.cleaned_data.get('company'):
            meetings = meetings.filter(company=filter_form.cleaned_data['company'])
        
        if filter_form.cleaned_data.get('organizer'):
            meetings = meetings.filter(organizer=filter_form.cleaned_data['organizer'])
        
        if filter_form.cleaned_data.get('date_from'):
            meetings = meetings.filter(scheduled_date__gte=filter_form.cleaned_data['date_from'])
        
        if filter_form.cleaned_data.get('date_to'):
            from datetime import datetime, time
            date_to = datetime.combine(filter_form.cleaned_data['date_to'], time.max)
            meetings = meetings.filter(scheduled_date__lte=date_to)
    
    # Ordenar
    meetings = meetings.order_by('-scheduled_date', '-created_at')
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(meetings, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_obj': page_obj,
        'filter_form': filter_form,
        'total_meetings': meetings.count(),
    }
    
    return render(request, 'tickets/video_meeting_list.html', context)


@login_required
def video_meeting_create(request):
    """Crear nueva reunión de video (sin archivos)"""
    from .forms import VideoMeetingForm
    
    if request.method == 'POST':
        form = VideoMeetingForm(request.POST, user=request.user)
        if form.is_valid():
            meeting = form.save(commit=False)
            meeting.organizer = request.user
            
            # Si el usuario tiene empresa y no se especificó una, asignar la del usuario
            if not meeting.company and hasattr(request.user, 'employee') and request.user.employee and request.user.employee.company:
                meeting.company = request.user.employee.company
            
            meeting.save()
            form.save_m2m()  # Guardar participantes (ManyToMany)
            
            messages.success(request, 'Reunión creada exitosamente. Ahora puedes subir archivos en la edición.')
            return redirect('video_meeting_edit', pk=meeting.pk)
    else:
        form = VideoMeetingForm(user=request.user)
    
    context = {
        'form': form,
        'title': 'Nueva Reunión de Video',
        'action': 'Crear',
        'is_create': True
    }
    
    return render(request, 'tickets/video_meeting_form.html', context)


@login_required
def video_meeting_detail(request, pk):
    """Detalle de reunión de video"""
    from .models import VideoMeeting, MeetingNote
    from .forms import MeetingNoteForm
    
    meeting = get_object_or_404(VideoMeeting, pk=pk)
    
    # Verificar permisos
    if not is_agent(request.user):
        if request.user != meeting.organizer and request.user not in meeting.participants.all():
            messages.error(request, 'No tienes permisos para ver esta reunión.')
            return redirect('video_meeting_list')
    
    # Manejar formulario de notas
    if request.method == 'POST':
        if 'add_note' in request.POST:
            note_form = MeetingNoteForm(request.POST)
            if note_form.is_valid():
                note = note_form.save(commit=False)
                note.meeting = meeting
                note.user = request.user
                note.save()
                messages.success(request, 'Nota agregada exitosamente.')
                return redirect('video_meeting_detail', pk=pk)
        
        elif 'transcribe_now' in request.POST or 'force_transcription' in request.POST:
            # Iniciar/forzar transcripción
            if meeting.recording_file or meeting.attachments.exists():
                meeting.transcription_status = 'pending'
                meeting.save()
                
                try:
                    from .tasks import process_meeting_recordings_async
                    from .models import MeetingAttachment
                    
                    # Recolectar todas las rutas de archivos
                    file_paths = []
                    
                    # Agregar archivo principal si existe
                    if meeting.recording_file:
                        file_paths.append(meeting.recording_file.path)
                    
                    # Agregar archivos adjuntos
                    for attachment in meeting.attachments.all():
                        file_paths.append(attachment.file.path)
                    
                    # Procesar en segundo plano
                    process_meeting_recordings_async(meeting.id, file_paths)
                    
                    messages.success(
                        request, 
                        f'Procesamiento iniciado para {len(file_paths)} archivo(s). '
                        'La transcripción y análisis se realizarán en segundo plano.'
                    )
                except Exception as e:
                    messages.error(request, f'Error al iniciar el procesamiento: {str(e)}')
            else:
                messages.error(request, 'No hay archivos para transcribir.')
            
            return redirect('video_meeting_detail', pk=pk)
    
    # Obtener notas (filtrar privadas si no es el autor)
    notes = meeting.notes.all()
    if not is_agent(request.user):
        notes = notes.filter(
            models.Q(is_private=False) | models.Q(user=request.user)
        )
    notes = notes.order_by('-created_at')
    
    note_form = MeetingNoteForm()
    
    context = {
        'meeting': meeting,
        'notes': notes,
        'note_form': note_form,
        'can_edit': meeting.can_edit() and (is_agent(request.user) or meeting.organizer == request.user),
    }
    
    return render(request, 'tickets/video_meeting_detail.html', context)


@login_required
def video_meeting_edit(request, pk):
    """Editar reunión de video con subida de múltiples archivos"""
    from .forms import VideoMeetingEditForm
    
    meeting = get_object_or_404(VideoMeeting, pk=pk)
    
    # Verificar permisos
    if not is_agent(request.user) and meeting.organizer != request.user:
        messages.error(request, 'No tienes permisos para editar esta reunión.')
        return redirect('video_meeting_detail', pk=pk)
    
    if not meeting.can_edit():
        messages.error(request, 'Esta reunión no puede ser editada.')
        return redirect('video_meeting_detail', pk=pk)
    
    if request.method == 'POST':
        form = VideoMeetingEditForm(request.POST, request.FILES, instance=meeting, user=request.user)
        if form.is_valid():
            meeting = form.save()
            
            # Manejar múltiples archivos
            uploaded_files = request.FILES.getlist('recording_files')
            
            if uploaded_files:
                # Iniciar procesamiento en thread separado (sin Celery)
                from .tasks import process_meeting_recordings_async
                from .models import MeetingAttachment
                
                # Guardar archivos como adjuntos y crear lista de rutas
                file_paths = []
                from django.core.files.storage import default_storage
                import os
                
                for uploaded_file in uploaded_files:
                    # Guardar archivo
                    file_path = f'meeting_recordings/{meeting.id}_{uploaded_file.name}'
                    saved_path = default_storage.save(file_path, uploaded_file)
                    file_paths.append(saved_path)
                    
                    # Crear registro de adjunto
                    MeetingAttachment.objects.create(
                        meeting=meeting,
                        file=saved_path,
                        filename=uploaded_file.name,
                        file_size=uploaded_file.size,
                        uploaded_by=request.user
                    )
                
                # Procesar en segundo plano usando threading
                process_meeting_recordings_async(meeting.id, file_paths)
                
                messages.success(
                    request, 
                    f'Reunión actualizada. {len(uploaded_files)} archivo(s) se procesarán en segundo plano. '
                    'El análisis de IA se generará automáticamente.'
                )
            else:
                messages.success(request, 'Reunión actualizada exitosamente.')
            
            return redirect('video_meeting_detail', pk=meeting.pk)
    else:
        form = VideoMeetingEditForm(instance=meeting, user=request.user)
    
    context = {
        'form': form,
        'meeting': meeting,
        'title': f'Editar - {meeting.title}',
        'action': 'Guardar Cambios',
        'is_create': False
    }
    
    return render(request, 'tickets/video_meeting_form.html', context)


@login_required
def video_meeting_transcription(request, pk):
    """Editar transcripción manualmente"""
    from .forms import MeetingTranscriptionForm
    
    meeting = get_object_or_404(VideoMeeting, pk=pk)
    
    # Verificar permisos
    if not is_agent(request.user):
        if request.user != meeting.organizer and request.user not in meeting.participants.all():
            messages.error(request, 'No tienes permisos para editar la transcripción.')
            return redirect('video_meeting_detail', pk=pk)
    
    if request.method == 'POST':
        form = MeetingTranscriptionForm(request.POST, instance=meeting)
        if form.is_valid():
            form.save()
            # Si se editó manualmente, marcar como completada
            if meeting.transcription_text:
                meeting.transcription_status = 'completed'
                meeting.save()
            
            messages.success(request, 'Transcripción actualizada exitosamente.')
            return redirect('video_meeting_detail', pk=meeting.pk)
    else:
        form = MeetingTranscriptionForm(instance=meeting)
    
    context = {
        'form': form,
        'meeting': meeting,
        'title': f'Transcripción - {meeting.title}',
    }
    
    return render(request, 'tickets/video_meeting_transcription.html', context)


@login_required
def video_meeting_delete(request, pk):
    """Eliminar reunión de video"""
    meeting = get_object_or_404(VideoMeeting, pk=pk)
    
    # Verificar permisos
    if not is_agent(request.user) and meeting.organizer != request.user:
        messages.error(request, 'No tienes permisos para eliminar esta reunión.')
        return redirect('video_meeting_detail', pk=pk)
    
    if request.method == 'POST':
        meeting_title = meeting.title
        
        # Eliminar archivo de grabación si existe
        if meeting.recording_file:
            try:
                import os
                if os.path.exists(meeting.recording_file.path):
                    os.remove(meeting.recording_file.path)
            except:
                pass
        
        meeting.delete()
        messages.success(request, f'Reunión "{meeting_title}" eliminada exitosamente.')
        return redirect('video_meeting_list')
    
    context = {
        'meeting': meeting,
        'title': f'Eliminar Reunión - {meeting.title}',
    }
    
    return render(request, 'tickets/video_meeting_delete.html', context)


@login_required
@require_http_methods(["POST"])
def video_meeting_transcribe(request, pk):
    """Iniciar transcripción automática de reunión"""
    from django.http import JsonResponse
    from .ai_utils import transcribe_meeting_async
    
    meeting = get_object_or_404(VideoMeeting, pk=pk)
    
    # Verificar permisos
    if not is_agent(request.user) and meeting.organizer != request.user:
        return JsonResponse({'success': False, 'error': 'Sin permisos'})
    
    # Verificar que hay archivo
    if not meeting.recording_file:
        return JsonResponse({'success': False, 'error': 'No hay archivo para transcribir'})
    
    # Verificar que no esté ya procesando
    if meeting.transcription_status == 'pending':
        return JsonResponse({'success': False, 'error': 'Ya se está procesando la transcripción'})
    
    try:
        # Iniciar transcripción asíncrona
        transcribe_meeting_async(meeting.id)
        
        # Actualizar estado
        meeting.transcription_status = 'pending'
        meeting.save(update_fields=['transcription_status'])
        
        return JsonResponse({'success': True, 'message': 'Transcripción iniciada'})
    
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)})


@login_required
def video_meeting_transcription_status(request, pk):
    """Obtener estado de transcripción de reunión"""
    from django.http import JsonResponse
    
    meeting = get_object_or_404(VideoMeeting, pk=pk)
    
    # Verificar permisos
    if not is_agent(request.user) and meeting.organizer != request.user:
        return JsonResponse({'error': 'Sin permisos'}, status=403)
    
    return JsonResponse({
        'status': meeting.transcription_status or 'none',
        'has_transcription': bool(meeting.transcription_text),
        'transcription_date': meeting.transcription_date.isoformat() if meeting.transcription_date else None,
    })


@login_required
def meeting_note_delete(request, meeting_pk, note_pk):
    """Eliminar nota de reunión"""
    from .models import MeetingNote
    
    meeting = get_object_or_404(VideoMeeting, pk=meeting_pk)
    note = get_object_or_404(MeetingNote, pk=note_pk, meeting=meeting)
    
    # Verificar permisos
    if not is_agent(request.user) and note.user != request.user:
        messages.error(request, 'No tienes permisos para eliminar esta nota.')
        return redirect('video_meeting_detail', pk=meeting_pk)
    
    if request.method == 'POST':
        note.delete()
        messages.success(request, 'Nota eliminada exitosamente.')
    
    return redirect('video_meeting_detail', pk=meeting_pk)


@login_required
def video_meeting_download_transcription(request, pk):
    """Descargar transcripción de reunión de video como archivo de texto"""
    meeting = get_object_or_404(VideoMeeting, pk=pk)
    
    # Verificar que la transcripción esté completa y disponible
    if meeting.transcription_status != 'completed' or not meeting.transcription_text:
        messages.error(request, 'La transcripción no está disponible para descarga.')
        return redirect('dashboard')
    
    # Verificar permisos (organizador, participantes o agentes)
    if not is_agent(request.user) and meeting.organizer != request.user and request.user not in meeting.participants.all():
        messages.error(request, 'No tienes permisos para descargar esta transcripción.')
        return redirect('dashboard')
    
    # Crear el contenido del archivo
    content = f"""TRANSCRIPCIÓN DE REUNIÓN DE VIDEO
========================================

Título: {meeting.title}
Organizador: {meeting.organizer.get_full_name() or meeting.organizer.username}
Fecha: {meeting.created_at.strftime('%d/%m/%Y %H:%M')}
Duración: {meeting.duration_minutes or 'No especificada'} minutos
Estado: {meeting.get_status_display()}

DESCRIPCIÓN:
{meeting.description or 'Sin descripción'}

TRANSCRIPCIÓN:
==============
{meeting.transcription_text}

RESUMEN DE IA:
==============
{meeting.ai_summary or 'No disponible'}

PUNTOS CLAVE:
=============
{meeting.key_points or 'No disponibles'}

ELEMENTOS DE ACCIÓN:
===================
{meeting.action_items or 'No disponibles'}

---
Generado automáticamente por TicketProo
Fecha de descarga: {timezone.now().strftime('%d/%m/%Y %H:%M')}
"""
    
    # Crear la respuesta HTTP
    response = HttpResponse(content, content_type='text/plain; charset=utf-8')
    filename = f"transcripcion_{meeting.title.replace(' ', '_')}_{meeting.created_at.strftime('%Y%m%d')}.txt"
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    
    return response


# ==================== VISTAS DE GENERADOR DE CITAS ====================

@login_required
def quote_generator_list(request):
    """Lista de generadores de citas"""
    if is_agent(request.user):
        generators = QuoteGenerator.objects.all().order_by('-created_at')
    else:
        # Usuarios regulares ven solo los de su empresa
        user_company = None
        try:
            user_company = request.user.profile.company
        except:
            pass
        
        if user_company:
            generators = QuoteGenerator.objects.filter(
                models.Q(created_by=request.user) | models.Q(company=user_company)
            ).distinct().order_by('-created_at')
        else:
            generators = QuoteGenerator.objects.filter(created_by=request.user).order_by('-created_at')
    
    return render(request, 'tickets/quote_generator_list.html', {
        'generators': generators,
        'page_title': 'Generadores de Citas IA'
    })


@login_required
def quote_generator_create(request):
    """Crear un nuevo generador de citas"""
    if request.method == 'POST':
        form = QuoteGeneratorForm(request.POST, user=request.user)
        if form.is_valid():
            generator = form.save(commit=False)
            generator.created_by = request.user
            
            # Asignar empresa del usuario
            try:
                generator.company = request.user.profile.company
            except:
                pass
                
            generator.save()
            
            # Generar las citas con IA
            success = generate_quotes_with_ai(generator)
            
            if success:
                messages.success(request, f'Generador "{generator.title}" creado exitosamente. Se generaron las citas automáticamente.')
                return redirect('quote_generator_detail', pk=generator.pk)
            else:
                messages.warning(request, f'Generador "{generator.title}" creado, pero hubo un error al generar las citas. Puedes intentar generar nuevamente.')
                return redirect('quote_generator_detail', pk=generator.pk)
    else:
        form = QuoteGeneratorForm(user=request.user)
    
    return render(request, 'tickets/quote_generator_form.html', {
        'form': form,
        'page_title': 'Crear Generador de Citas',
        'submit_text': 'Generar Citas'
    })


@login_required
def quote_generator_detail(request, pk):
    """Detalle de un generador de citas"""
    generator = get_object_or_404(QuoteGenerator, pk=pk)
    
    # Verificar permisos
    if not is_agent(request.user) and generator.created_by != request.user:
        user_company = None
        try:
            user_company = request.user.profile.company
        except:
            pass
        
        if not user_company or generator.company != user_company:
            messages.error(request, 'No tienes permisos para ver este generador.')
            return redirect('quote_generator_list')
    
    quotes_list = generator.get_quotes_list()
    
    return render(request, 'tickets/quote_generator_detail.html', {
        'generator': generator,
        'quotes_list': quotes_list,
        'page_title': f'Generador: {generator.title}'
    })


@login_required
def quote_generator_regenerate(request, pk):
    """Regenerar citas de un generador"""
    generator = get_object_or_404(QuoteGenerator, pk=pk)
    
    # Verificar permisos
    if not is_agent(request.user) and generator.created_by != request.user:
        messages.error(request, 'No tienes permisos para regenerar estas citas.')
        return redirect('quote_generator_list')
    
    if request.method == 'POST':
        success = generate_quotes_with_ai(generator)
        
        if success:
            messages.success(request, 'Citas regeneradas exitosamente.')
        else:
            messages.error(request, 'Error al regenerar las citas. Inténtalo de nuevo.')
    
    return redirect('quote_generator_detail', pk=pk)


@login_required
def quote_generator_edit(request, pk):
    """Editar un generador de citas"""
    generator = get_object_or_404(QuoteGenerator, pk=pk)
    
    # Verificar permisos
    if not is_agent(request.user) and generator.created_by != request.user:
        messages.error(request, 'No tienes permisos para editar este generador.')
        return redirect('quote_generator_list')
    
    if request.method == 'POST':
        form = QuoteGeneratorForm(request.POST, user=request.user, instance=generator)
        if form.is_valid():
            # Verificar si cambió el tema
            old_topic = generator.topic
            generator = form.save()
            
            # Si cambió el tema, regenerar citas automáticamente
            if old_topic != generator.topic:
                success = generate_quotes_with_ai(generator)
                if success:
                    messages.success(request, f'Generador "{generator.title}" actualizado exitosamente. Se regeneraron las citas automáticamente debido al cambio de tema.')
                else:
                    messages.warning(request, f'Generador "{generator.title}" actualizado, pero hubo un error al regenerar las citas.')
            else:
                messages.success(request, f'Generador "{generator.title}" actualizado exitosamente.')
            
            return redirect('quote_generator_detail', pk=generator.pk)
    else:
        form = QuoteGeneratorForm(user=request.user, instance=generator)
    
    return render(request, 'tickets/quote_generator_form.html', {
        'form': form,
        'generator': generator,
        'page_title': f'Editar Generador: {generator.title}',
        'submit_text': 'Actualizar Generador'
    })


def generate_quotes_with_ai(generator):
    """Función para generar citas con IA usando OpenAI"""
    try:
        from .models import SystemConfiguration
        import json
        import requests
        
        # Obtener configuración de OpenAI
        config = SystemConfiguration.objects.first()
        if not config or not config.openai_api_key:
            print("Error: No hay API key de OpenAI configurada")
            return False
        
        # Configurar la petición a OpenAI
        headers = {
            "Authorization": f"Bearer {config.openai_api_key}",
            "Content-Type": "application/json"
        }
        
        # Crear el prompt para generar citas
        prompt = f"""Genera exactamente 10 citas sobre el siguiente tema: {generator.topic}

Requisitos:
- Deben ser citas reales o inspiradas en el tema solicitado
- Cada cita debe tener máximo 150 caracteres (aproximadamente 2-3 líneas cuando se muestre)
- IMPORTANTE: Las citas deben ser cortas y concisas, que no excedan 3 líneas al mostrarse
- Incluye el autor cuando sea posible
- Si no hay autor conocido, usa "Anónimo"
- Las citas deben ser inspiradoras, motivacionales o reflexivas
- Evita citas muy largas o con múltiples frases

Responde únicamente con un JSON válido en este formato exacto:
[
  {{"quote": "texto de la cita", "author": "nombre del autor"}},
  {{"quote": "texto de la cita", "author": "nombre del autor"}}
]"""

        data = {
            "model": "gpt-3.5-turbo",
            "messages": [
                {"role": "system", "content": "Eres un experto en citas famosas y motivacionales. Generas únicamente citas cortas y concisas que no excedan 150 caracteres. Respondes únicamente con JSON válido, sin texto adicional antes o después del JSON."},
                {"role": "user", "content": prompt}
            ],
            "max_tokens": 1500,
            "temperature": 0.7
        }
        
        # Hacer la petición a OpenAI
        response = requests.post(
            "https://api.openai.com/v1/chat/completions",
            headers=headers,
            json=data,
            timeout=30
        )
        
        if response.status_code != 200:
            print(f"Error en respuesta de OpenAI: {response.status_code} - {response.text}")
            return False
        
        response_data = response.json()
        
        # Procesar respuesta
        content = response_data['choices'][0]['message']['content'].strip()
        print(f"Respuesta de OpenAI: {content}")
        
        # Limpiar el contenido para extraer solo el JSON
        if content.startswith('```json'):
            content = content[7:]
        if content.endswith('```'):
            content = content[:-3]
        content = content.strip()
        
        # Parsear JSON
        quotes_data = json.loads(content)
        
        # Validar que tenemos citas
        if not isinstance(quotes_data, list) or len(quotes_data) == 0:
            print(f"Error: Respuesta no es una lista válida: {quotes_data}")
            return False
            
        # Asegurar que cada cita tenga los campos necesarios
        valid_quotes = []
        for quote in quotes_data:
            if isinstance(quote, dict) and 'quote' in quote:
                valid_quotes.append({
                    'quote': quote.get('quote', ''),
                    'author': quote.get('author', 'Anónimo')
                })
        
        if len(valid_quotes) == 0:
            print("Error: No se encontraron citas válidas")
            return False
        
        # Guardar las citas en el generador
        generator.set_quotes_list(valid_quotes)
        generator.save()
        
        print(f"Éxito: Se generaron {len(valid_quotes)} citas")
        return True
        
    except json.JSONDecodeError as e:
        print(f"Error parseando JSON: {e}")
        print(f"Contenido recibido: {content}")
        return False
    except requests.exceptions.RequestException as e:
        print(f"Error en petición AI: {e}")
        return False
    except Exception as e:
        print(f"Error generando citas: {e}")
        return False


# =============================================
# VISTAS PARA CUENTAS REGRESIVAS
# =============================================

@login_required
def countdown_timer_list(request):
    """Lista todas las cuentas regresivas"""
    from .models import CountdownTimer
    
    # Filtrar por empresa si el usuario no es agente
    if is_agent(request.user):
        # Los agentes ven todas las cuentas regresivas no privadas + las propias privadas
        countdowns = CountdownTimer.objects.filter(
            models.Q(is_private=False) | models.Q(created_by=request.user)
        )
    else:
        # Solo mostrar cuentas regresivas de la empresa del usuario
        user_company = None
        if hasattr(request.user, 'profile') and request.user.profile.company:
            user_company = request.user.profile.company
        
        if user_company:
            # Mostrar solo las públicas de la empresa + las privadas propias
            countdowns = CountdownTimer.objects.filter(
                company=user_company
            ).filter(
                models.Q(is_private=False) | models.Q(created_by=request.user)
            )
        else:
            # Solo las propias (privadas y públicas)
            countdowns = CountdownTimer.objects.filter(created_by=request.user)
    
    # Ordenar por fecha objetivo
    countdowns = countdowns.filter(is_active=True).order_by('target_date')
    
    return render(request, 'tickets/countdown_timer_list.html', {
        'countdowns': countdowns,
        'page_title': 'Cuentas Regresivas'
    })


@login_required
def countdown_timer_create(request):
    """Crear una nueva cuenta regresiva"""
    from .models import CountdownTimer
    from .forms import CountdownTimerForm
    
    if request.method == 'POST':
        form = CountdownTimerForm(request.POST, user=request.user)
        if form.is_valid():
            countdown = form.save(commit=False)
            countdown.created_by = request.user
            
            # Asignar empresa del usuario si no es agente
            if hasattr(request.user, 'profile') and request.user.profile.company:
                countdown.company = request.user.profile.company
            
            countdown.save()
            messages.success(request, f'Cuenta regresiva "{countdown.title}" creada exitosamente.')
            return redirect('countdown_timer_list')
    else:
        form = CountdownTimerForm(user=request.user)
    
    return render(request, 'tickets/countdown_timer_form.html', {
        'form': form,
        'page_title': 'Nueva Cuenta Regresiva',
        'submit_text': 'Crear Cuenta Regresiva'
    })


@login_required
def countdown_timer_detail(request, pk):
    """Ver detalles de una cuenta regresiva"""
    from .models import CountdownTimer
    
    countdown = get_object_or_404(CountdownTimer, pk=pk)
    
    # Verificar permisos de privacidad
    if countdown.is_private and countdown.created_by != request.user:
        messages.error(request, 'Esta cuenta regresiva es privada y no tienes permisos para verla.')
        return redirect('countdown_timer_list')
    
    # Verificar permisos de empresa (solo si no es privada)
    if not countdown.is_private and not is_agent(request.user):
        user_company = None
        if hasattr(request.user, 'profile') and request.user.profile.company:
            user_company = request.user.profile.company
        
        if countdown.company != user_company and countdown.created_by != request.user:
            messages.error(request, 'No tienes permisos para ver esta cuenta regresiva.')
            return redirect('countdown_timer_list')
    
    return render(request, 'tickets/countdown_timer_detail.html', {
        'countdown': countdown,
        'page_title': f'Cuenta Regresiva: {countdown.title}'
    })


@login_required
def countdown_timer_edit(request, pk):
    """Editar una cuenta regresiva"""
    from .models import CountdownTimer
    from .forms import CountdownTimerForm
    
    countdown = get_object_or_404(CountdownTimer, pk=pk)
    
    # Verificar permisos
    if not is_agent(request.user) and countdown.created_by != request.user:
        messages.error(request, 'No tienes permisos para editar esta cuenta regresiva.')
        return redirect('countdown_timer_list')
    
    if request.method == 'POST':
        form = CountdownTimerForm(request.POST, user=request.user, instance=countdown)
        if form.is_valid():
            countdown = form.save()
            messages.success(request, f'Cuenta regresiva "{countdown.title}" actualizada exitosamente.')
            return redirect('countdown_timer_detail', pk=countdown.pk)
    else:
        form = CountdownTimerForm(user=request.user, instance=countdown)
    
    return render(request, 'tickets/countdown_timer_form.html', {
        'form': form,
        'countdown': countdown,
        'page_title': f'Editar: {countdown.title}',
        'submit_text': 'Actualizar Cuenta Regresiva'
    })


@login_required
def countdown_timer_delete(request, pk):
    """Eliminar una cuenta regresiva"""
    from .models import CountdownTimer
    
    countdown = get_object_or_404(CountdownTimer, pk=pk)
    
    # Verificar permisos
    if not is_agent(request.user) and countdown.created_by != request.user:
        messages.error(request, 'No tienes permisos para eliminar esta cuenta regresiva.')
        return redirect('countdown_timer_list')
    
    if request.method == 'POST':
        title = countdown.title
        countdown.delete()
        messages.success(request, f'Cuenta regresiva "{title}" eliminada exitosamente.')
        return redirect('countdown_timer_list')
    
    return render(request, 'tickets/countdown_timer_delete.html', {
        'countdown': countdown,
        'page_title': f'Eliminar: {countdown.title}'
    })


# ========== VISTAS PARA GESTIÓN DE TIPOS DE AUSENCIAS ==========

@login_required
@user_passes_test(is_agent)
def absence_type_list(request):
    """Lista todos los tipos de ausencias"""
    from .models import AbsenceType
    
    absence_types = AbsenceType.objects.all().order_by('name')
    
    # Estadísticas
    total_types = absence_types.count()
    active_types = absence_types.filter(is_active=True).count()
    
    context = {
        'absence_types': absence_types,
        'total_types': total_types,
        'active_types': active_types,
        'page_title': 'Tipos de Ausencias'
    }
    
    return render(request, 'tickets/absence_type_list.html', context)


@login_required
@user_passes_test(is_agent)
def absence_type_create(request):
    """Crear un nuevo tipo de ausencia"""
    from .models import AbsenceType
    
    if request.method == 'POST':
        form = AbsenceTypeForm(request.POST)
        if form.is_valid():
            absence_type = form.save()
            messages.success(request, f'Tipo de ausencia "{absence_type.name}" creado exitosamente.')
            return redirect('absence_type_list')
    else:
        form = AbsenceTypeForm()
    
    return render(request, 'tickets/absence_type_form.html', {
        'form': form,
        'page_title': 'Crear Tipo de Ausencia',
        'submit_text': 'Crear Tipo de Ausencia'
    })


@login_required
@user_passes_test(is_agent)
def absence_type_edit(request, pk):
    """Editar un tipo de ausencia existente"""
    from .models import AbsenceType
    
    absence_type = get_object_or_404(AbsenceType, pk=pk)
    
    if request.method == 'POST':
        form = AbsenceTypeForm(request.POST, instance=absence_type)
        if form.is_valid():
            absence_type = form.save()
            messages.success(request, f'Tipo de ausencia "{absence_type.name}" actualizado exitosamente.')
            return redirect('absence_type_list')
    else:
        form = AbsenceTypeForm(instance=absence_type)
    
    return render(request, 'tickets/absence_type_form.html', {
        'form': form,
        'absence_type': absence_type,
        'page_title': f'Editar: {absence_type.name}',
        'submit_text': 'Actualizar Tipo de Ausencia'
    })


@login_required
@user_passes_test(is_agent)
def absence_type_delete(request, pk):
    """Eliminar un tipo de ausencia"""
    from .models import AbsenceType
    
    absence_type = get_object_or_404(AbsenceType, pk=pk)
    
    # Verificar si hay ausencias asociadas
    usage_count = absence_type.get_usage_count()
    
    if request.method == 'POST':
        if usage_count > 0:
            messages.error(request, f'No se puede eliminar el tipo "{absence_type.name}" porque tiene {usage_count} ausencias asociadas.')
        else:
            name = absence_type.name
            absence_type.delete()
            messages.success(request, f'Tipo de ausencia "{name}" eliminado exitosamente.')
        return redirect('absence_type_list')
    
    return render(request, 'tickets/absence_type_delete.html', {
        'absence_type': absence_type,
        'usage_count': usage_count,
        'page_title': f'Eliminar: {absence_type.name}'
    })


@login_required
@user_passes_test(is_agent)
def absence_type_toggle_active(request, pk):
    """Alternar el estado activo/inactivo de un tipo de ausencia"""
    from .models import AbsenceType
    
    absence_type = get_object_or_404(AbsenceType, pk=pk)
    absence_type.is_active = not absence_type.is_active
    absence_type.save()
    
    status = "activado" if absence_type.is_active else "desactivado"
    messages.success(request, f'Tipo de ausencia "{absence_type.name}" {status} exitosamente.')
    
    return redirect('absence_type_list')


# =====================================
# VISTAS DE PROCEDIMIENTOS
# =====================================

@login_required
def procedure_list(request):
    """Vista para listar procedimientos"""
    from .models import Procedure
    
    procedures = Procedure.objects.filter(is_active=True).order_by('sequence', 'title')
    
    # Búsqueda
    search = request.GET.get('search', '')
    if search:
        procedures = procedures.filter(
            Q(title__icontains=search) | 
            Q(description__icontains=search)
        )
    
    # Paginación
    paginator = Paginator(procedures, 20)
    page_number = request.GET.get('page')
    procedures = paginator.get_page(page_number)
    
    context = {
        'procedures': procedures,
        'search': search,
        'page_title': 'Procedimientos'
    }
    
    return render(request, 'tickets/procedure_list.html', context)


@login_required
@user_passes_test(is_agent)
def procedure_create(request):
    """Vista para crear un nuevo procedimiento"""
    from .forms import ProcedureForm
    from .models import Procedure
    
    if request.method == 'POST':
        form = ProcedureForm(request.POST, request.FILES)
        if form.is_valid():
            procedure = form.save(commit=False)
            procedure.created_by = request.user
            
            # Auto-generar la secuencia
            max_sequence = Procedure.objects.aggregate(
                max_seq=models.Max('sequence')
            )['max_seq']
            procedure.sequence = (max_sequence + 1) if max_sequence else 1
            
            procedure.save()
            messages.success(request, f'Procedimiento "{procedure.title}" creado exitosamente.')
            return redirect('procedure_list')
    else:
        form = ProcedureForm()
    
    context = {
        'form': form,
        'page_title': 'Crear Procedimiento'
    }
    
    return render(request, 'tickets/procedure_form.html', context)


@login_required
@user_passes_test(is_agent)
def procedure_edit(request, pk):
    """Vista para editar un procedimiento"""
    from .models import Procedure
    from .forms import ProcedureForm
    
    procedure = get_object_or_404(Procedure, pk=pk)
    
    if request.method == 'POST':
        form = ProcedureForm(request.POST, request.FILES, instance=procedure)
        if form.is_valid():
            form.save()
            messages.success(request, f'Procedimiento "{procedure.title}" actualizado exitosamente.')
            return redirect('procedure_list')
    else:
        form = ProcedureForm(instance=procedure)
    
    context = {
        'form': form,
        'procedure': procedure,
        'page_title': f'Editar: {procedure.title}'
    }
    
    return render(request, 'tickets/procedure_form.html', context)


@login_required
def procedure_detail(request, pk):
    """Vista para ver detalles de un procedimiento"""
    from .models import Procedure
    
    procedure = get_object_or_404(Procedure, pk=pk)
    
    context = {
        'procedure': procedure,
        'page_title': procedure.title
    }
    
    return render(request, 'tickets/procedure_detail.html', context)


@login_required
@user_passes_test(is_agent)
def procedure_delete(request, pk):
    """Vista para eliminar un procedimiento"""
    from .models import Procedure
    
    procedure = get_object_or_404(Procedure, pk=pk)
    
    if request.method == 'POST':
        title = procedure.title
        procedure.delete()
        messages.success(request, f'Procedimiento "{title}" eliminado exitosamente.')
        return redirect('procedure_list')
    
    context = {
        'procedure': procedure,
        'page_title': f'Eliminar: {procedure.title}'
    }
    
    return render(request, 'tickets/procedure_delete.html', context)


@login_required
@user_passes_test(is_agent)
def procedure_toggle_active(request, pk):
    """Alternar el estado activo/inactivo de un procedimiento"""
    from .models import Procedure
    
    procedure = get_object_or_404(Procedure, pk=pk)
    procedure.is_active = not procedure.is_active
    procedure.save()
    
    status = "activado" if procedure.is_active else "desactivado"
    messages.success(request, f'Procedimiento "{procedure.title}" {status} exitosamente.')
    
    return redirect('procedure_list')


# ================================
# CUMPLIMIENTO MENSUAL - QA
# ================================

@login_required
@user_passes_test(lambda user: user.is_staff, login_url='/')
def monthly_cumplimiento_list(request):
    """Lista de cumplimientos mensuales"""
    from .models import MonthlyCumplimiento
    
    cumplimientos = MonthlyCumplimiento.objects.all().order_by('-created_at')
    
    # Filtros
    search = request.GET.get('search')
    if search:
        cumplimientos = cumplimientos.filter(
            Q(name__icontains=search) |
            Q(user__icontains=search) |
            Q(description__icontains=search)
        )
    
    is_active = request.GET.get('is_active')
    if is_active in ['true', 'false']:
        cumplimientos = cumplimientos.filter(is_active=is_active == 'true')
    
    # Paginación
    from django.core.paginator import Paginator
    paginator = Paginator(cumplimientos, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_obj': page_obj,
        'page_title': 'Cumplimiento Mensual',
        'section': 'qa'
    }
    
    return render(request, 'tickets/monthly_cumplimiento_list.html', context)


@login_required
@user_passes_test(lambda user: user.is_staff, login_url='/')
def monthly_cumplimiento_create(request):
    """Crear nuevo cumplimiento mensual"""
    from .forms import MonthlyCumplimientoForm
    
    if request.method == 'POST':
        form = MonthlyCumplimientoForm(request.POST)
        if form.is_valid():
            cumplimiento = form.save(commit=False)
            cumplimiento.created_by = request.user
            cumplimiento.save()
            
            messages.success(request, f'Cumplimiento mensual "{cumplimiento.name}" creado exitosamente.')
            return redirect('monthly_cumplimiento_detail', pk=cumplimiento.pk)
    else:
        form = MonthlyCumplimientoForm()
    
    context = {
        'form': form,
        'page_title': 'Nuevo Cumplimiento Mensual',
        'section': 'qa'
    }
    
    return render(request, 'tickets/monthly_cumplimiento_form.html', context)


@login_required
@user_passes_test(lambda user: user.is_staff, login_url='/')
def monthly_cumplimiento_detail(request, pk):
    """Detalle del cumplimiento mensual"""
    from .models import MonthlyCumplimiento
    
    cumplimiento = get_object_or_404(MonthlyCumplimiento, pk=pk)
    progress = cumplimiento.get_current_month_progress()
    
    # Obtener cumplimientos del mes actual para mostrar calendario
    from datetime import date, timedelta
    today = date.today()
    current_month_start = today.replace(day=1)
    
    # Generar días del mes
    days_in_month = []
    current_date = current_month_start
    while current_date.month == today.month:
        daily_cumplimiento = cumplimiento.daily_cumplimientos.filter(date=current_date).first()
        days_in_month.append({
            'date': current_date,
            'is_today': current_date == today,
            'is_past': current_date < today,
            'is_future': current_date > today,
            'completed': daily_cumplimiento.completed if daily_cumplimiento else False,
            'has_notes': daily_cumplimiento.notes if daily_cumplimiento else False
        })
        current_date += timedelta(days=1)
    
    context = {
        'cumplimiento': cumplimiento,
        'progress': progress,
        'days_in_month': days_in_month,
        'page_title': f'Cumplimiento - {cumplimiento.name}',
        'section': 'qa'
    }
    
    return render(request, 'tickets/monthly_cumplimiento_detail.html', context)


@login_required
@user_passes_test(lambda user: user.is_staff, login_url='/')
def monthly_cumplimiento_edit(request, pk):
    """Editar cumplimiento mensual"""
    from .models import MonthlyCumplimiento
    from .forms import MonthlyCumplimientoForm
    
    cumplimiento = get_object_or_404(MonthlyCumplimiento, pk=pk)
    
    if request.method == 'POST':
        form = MonthlyCumplimientoForm(request.POST, instance=cumplimiento)
        if form.is_valid():
            form.save()
            messages.success(request, f'Cumplimiento mensual "{cumplimiento.name}" actualizado exitosamente.')
            return redirect('monthly_cumplimiento_detail', pk=cumplimiento.pk)
    else:
        form = MonthlyCumplimientoForm(instance=cumplimiento)
    
    context = {
        'form': form,
        'cumplimiento': cumplimiento,
        'page_title': f'Editar - {cumplimiento.name}',
        'section': 'qa'
    }
    
    return render(request, 'tickets/monthly_cumplimiento_form.html', context)


@login_required
@user_passes_test(lambda user: user.is_staff, login_url='/')
def monthly_cumplimiento_delete(request, pk):
    """Eliminar cumplimiento mensual"""
    from .models import MonthlyCumplimiento
    
    cumplimiento = get_object_or_404(MonthlyCumplimiento, pk=pk)
    
    if request.method == 'POST':
        name = cumplimiento.name
        cumplimiento.delete()
        messages.success(request, f'Cumplimiento mensual "{name}" eliminado exitosamente.')
        return redirect('monthly_cumplimiento_list')
    
    context = {
        'cumplimiento': cumplimiento,
        'page_title': f'Eliminar - {cumplimiento.name}',
        'section': 'qa'
    }
    
    return render(request, 'tickets/monthly_cumplimiento_delete.html', context)


@login_required
@user_passes_test(lambda user: user.is_staff, login_url='/')
def monthly_cumplimiento_toggle(request, pk):
    """Activar/desactivar cumplimiento mensual"""
    from .models import MonthlyCumplimiento
    
    cumplimiento = get_object_or_404(MonthlyCumplimiento, pk=pk)
    cumplimiento.is_active = not cumplimiento.is_active
    cumplimiento.save()
    
    status = "activado" if cumplimiento.is_active else "desactivado"
    messages.success(request, f'Cumplimiento mensual "{cumplimiento.name}" {status} exitosamente.')
    
    return redirect('monthly_cumplimiento_detail', pk=cumplimiento.pk)


# Vista pública para móviles
def monthly_cumplimiento_public(request, uuid):
    """Vista pública para marcar cumplimientos diarios (optimizada para móvil)"""
    from .models import MonthlyCumplimiento, DailyCumplimiento
    from .forms import DailyCumplimientoForm
    from datetime import date, timedelta
    
    cumplimiento = get_object_or_404(MonthlyCumplimiento, public_uuid=uuid, is_active=True)
    today = date.today()
    
    # Verificar si el usuario tiene múltiples cumplimientos
    user_cumplimientos_count = MonthlyCumplimiento.objects.filter(
        user=cumplimiento.user, 
        is_active=True
    ).count()
    
    # Manejar POST (marcar/desmarcar cumplimiento)
    if request.method == 'POST':
        target_date_str = request.POST.get('date')
        if target_date_str:
            try:
                target_date = date.fromisoformat(target_date_str)
                daily_cumplimiento, created = DailyCumplimiento.objects.get_or_create(
                    monthly_cumplimiento=cumplimiento,
                    date=target_date,
                    defaults={'completed': False}
                )
                
                # Toggle estado
                daily_cumplimiento.completed = not daily_cumplimiento.completed
                daily_cumplimiento.save()
                
                status = "marcado como cumplido" if daily_cumplimiento.completed else "desmarcado"
                return JsonResponse({
                    'success': True,
                    'message': f'Día {target_date.strftime("%d/%m")} {status}',
                    'completed': daily_cumplimiento.completed
                })
            except ValueError:
                return JsonResponse({'success': False, 'message': 'Fecha inválida'})
    
    # Generar calendario del mes actual
    current_month_start = today.replace(day=1)
    next_month = (current_month_start + timedelta(days=32)).replace(day=1)
    
    # Calcular el primer día de la semana (lunes = 0, domingo = 6)
    first_weekday = current_month_start.weekday()
    
    # Agregar días vacíos del mes anterior si es necesario
    days_in_month = []
    
    # Añadir días vacíos al inicio si el mes no empieza en lunes
    for i in range(first_weekday):
        days_in_month.append({
            'date': None,
            'day': '',
            'is_today': False,
            'is_past': False,
            'is_future': False,
            'completed': False,
            'weekday': '',
            'iso_date': '',
            'is_empty': True
        })
    
    # Generar días del mes actual
    current_date = current_month_start
    while current_date < next_month:
        daily_cumplimiento = cumplimiento.daily_cumplimientos.filter(date=current_date).first()
        
        # Determinar el estado del día correctamente
        is_past = current_date < today
        is_today = current_date == today
        is_future = current_date > today
        
        days_in_month.append({
            'date': current_date,
            'day': current_date.day,
            'is_today': is_today,
            'is_past': is_past,
            'is_future': is_future,
            'completed': daily_cumplimiento.completed if daily_cumplimiento else False,
            'weekday': current_date.strftime('%a'),
            'iso_date': current_date.isoformat(),
            'is_empty': False
        })
        current_date += timedelta(days=1)
    
    # Completar la última fila con días vacíos si es necesario (para que siempre sean 42 días = 6 semanas)
    total_cells_needed = 42  # 6 filas x 7 días
    while len(days_in_month) < total_cells_needed:
        days_in_month.append({
            'date': None,
            'day': '',
            'is_today': False,
            'is_past': False,
            'is_future': False,
            'completed': False,
            'weekday': '',
            'iso_date': '',
            'is_empty': True
        })
    
    # Progreso del mes
    progress = cumplimiento.get_current_month_progress()
    
    context = {
        'cumplimiento': cumplimiento,
        'days_in_month': days_in_month,
        'progress': progress,
        'today': today,
        'current_month': today.strftime('%B %Y'),
        'page_title': f'{cumplimiento.name} - {cumplimiento.user}',
        'user_cumplimientos_count': user_cumplimientos_count,
        'has_multiple_cumplimientos': user_cumplimientos_count > 1
    }
    
    return render(request, 'tickets/monthly_cumplimiento_public.html', context)


def user_cumplimientos_menu(request, uuid):
    """Vista que muestra todos los cumplimientos de un usuario específico"""
    from .models import MonthlyCumplimiento
    
    # Buscar el cumplimiento por UUID para obtener el usuario
    primary_cumplimiento = get_object_or_404(MonthlyCumplimiento, public_uuid=uuid, is_active=True)
    
    # Obtener todos los cumplimientos activos del mismo usuario
    user_cumplimientos = MonthlyCumplimiento.objects.filter(
        user=primary_cumplimiento.user, 
        is_active=True
    ).order_by('name')
    
    # Si solo hay un cumplimiento, redirigir directamente
    if user_cumplimientos.count() == 1:
        return redirect('monthly_cumplimiento_public', uuid=uuid)
    
    context = {
        'user': primary_cumplimiento.user,
        'cumplimientos': user_cumplimientos,
        'primary_uuid': uuid,
        'page_title': f'Cumplimientos de {primary_cumplimiento.user.get_full_name() or primary_cumplimiento.user.username}'
    }
    
    return render(request, 'tickets/user_cumplimientos_menu.html', context)


# ================================
# Generador QR Views
# ================================

@login_required
def qr_generator(request):
    """Vista principal del generador de QR"""
    from .models import QRCode
    from .forms import QRCodeForm
    
    # Obtener códigos QR del usuario
    qr_codes = QRCode.objects.filter(created_by=request.user, is_active=True).order_by('-created_at')
    
    # Estadísticas
    total_qrs = qr_codes.count()
    qr_types_stats = {}
    for qr in qr_codes:
        qr_type = qr.get_qr_type_display()
        qr_types_stats[qr_type] = qr_types_stats.get(qr_type, 0) + 1
    
    context = {
        'qr_codes': qr_codes,
        'total_qrs': total_qrs,
        'qr_types_stats': qr_types_stats,
        'page_title': 'Generador de Códigos QR',
        'section': 'training'
    }
    
    return render(request, 'tickets/qr_generator.html', context)


@login_required
def qr_create(request):
    """Crear nuevo código QR"""
    from .models import QRCode
    from .forms import QRCodeForm
    
    if request.method == 'POST':
        form = QRCodeForm(request.POST, user=request.user)
        if form.is_valid():
            qr_code = form.save(commit=False)
            qr_code.created_by = request.user
            qr_code.save()
            messages.success(request, f'Código QR "{qr_code.title}" creado exitosamente.')
            return redirect('qr_detail', pk=qr_code.pk)
    else:
        form = QRCodeForm(user=request.user)
    
    context = {
        'form': form,
        'page_title': 'Crear Código QR',
        'section': 'training'
    }
    
    return render(request, 'tickets/qr_form.html', context)


@login_required
def qr_detail(request, pk):
    """Detalle del código QR"""
    from .models import QRCode
    
    qr_code = get_object_or_404(QRCode, pk=pk, created_by=request.user)
    
    context = {
        'qr_code': qr_code,
        'page_title': f'QR: {qr_code.title}',
        'section': 'training'
    }
    
    return render(request, 'tickets/qr_detail.html', context)


@login_required
def qr_edit(request, pk):
    """Editar código QR"""
    from .models import QRCode
    from .forms import QRCodeForm
    
    qr_code = get_object_or_404(QRCode, pk=pk, created_by=request.user)
    
    if request.method == 'POST':
        form = QRCodeForm(request.POST, instance=qr_code, user=request.user)
        if form.is_valid():
            form.save()
            messages.success(request, f'Código QR "{qr_code.title}" actualizado exitosamente.')
            return redirect('qr_detail', pk=qr_code.pk)
    else:
        form = QRCodeForm(instance=qr_code, user=request.user)
    
    context = {
        'form': form,
        'qr_code': qr_code,
        'page_title': f'Editar QR: {qr_code.title}',
        'section': 'training'
    }
    
    return render(request, 'tickets/qr_form.html', context)


@login_required
def qr_delete(request, pk):
    """Eliminar código QR"""
    from .models import QRCode
    
    qr_code = get_object_or_404(QRCode, pk=pk, created_by=request.user)
    
    if request.method == 'POST':
        title = qr_code.title
        qr_code.delete()
        messages.success(request, f'Código QR "{title}" eliminado exitosamente.')
        return redirect('qr_generator')
    
    context = {
        'qr_code': qr_code,
        'page_title': f'Eliminar QR: {qr_code.title}',
        'section': 'training'
    }
    
    return render(request, 'tickets/qr_delete.html', context)


@login_required
def qr_toggle_public(request, pk):
    """Activar/desactivar acceso público del QR"""
    from .models import QRCode
    
    qr_code = get_object_or_404(QRCode, pk=pk, created_by=request.user)
    
    if request.method == 'POST':
        qr_code.is_public = not qr_code.is_public
        
        # Si se está activando público, asegurar que tiene UUID
        if qr_code.is_public and not qr_code.public_uuid:
            qr_code.public_uuid = uuid.uuid4()
        
        qr_code.save()
        
        status = "público" if qr_code.is_public else "privado"
        messages.success(request, f'QR "{qr_code.title}" ahora es {status}.')
        
        return JsonResponse({
            'success': True,
            'is_public': qr_code.is_public,
            'public_url': qr_code.get_public_url() if qr_code.is_public else None
        })
    
    return JsonResponse({'success': False, 'error': 'Método no permitido'})


def qr_public(request, token):
    """Vista pública del código QR (sin autenticación)"""
    from .models import QRCode
    
    qr_code = get_object_or_404(QRCode, public_token=token, is_public=True, is_active=True)
    
    # Incrementar contador de vistas
    qr_code.public_views += 1
    qr_code.save(update_fields=['public_views'])
    
    context = {
        'qr_code': qr_code,
        'page_title': f'QR: {qr_code.title}',
        'is_public_view': True
    }
    
    return render(request, 'tickets/qr_public.html', context)


# ============= VISTAS PARA QUICK TODO =============

@login_required
@require_http_methods(["GET"])
def quick_todo_list(request):
    """API para obtener la lista de tareas rápidas del usuario"""
    from .models import QuickTodo
    
    todos = QuickTodo.objects.filter(created_by=request.user)
    
    data = []
    for todo in todos:
        data.append({
            'id': todo.id,
            'text': todo.text,
            'completed': todo.completed,
            'created_at': todo.created_at.strftime('%H:%M %d/%m/%Y')
        })
    
    return JsonResponse({'todos': data})


@login_required
@require_http_methods(["POST"])
def quick_todo_create(request):
    """API para crear una nueva tarea rápida"""
    from .models import QuickTodo
    
    try:
        data = json.loads(request.body)
        text = data.get('text', '').strip()
        
        if not text:
            return JsonResponse({'error': 'El texto de la tarea es requerido'}, status=400)
        
        if len(text) > 500:
            return JsonResponse({'error': 'El texto de la tarea es demasiado largo'}, status=400)
        
        todo = QuickTodo.objects.create(
            text=text,
            created_by=request.user
        )
        
        return JsonResponse({
            'success': True,
            'todo': {
                'id': todo.id,
                'text': todo.text,
                'completed': todo.completed,
                'created_at': todo.created_at.strftime('%H:%M %d/%m/%Y')
            }
        })
        
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Datos JSON inválidos'}, status=400)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


@login_required
@require_http_methods(["POST"])
def quick_todo_toggle(request, todo_id):
    """API para marcar/desmarcar una tarea como completada"""
    from .models import QuickTodo
    
    try:
        todo = get_object_or_404(QuickTodo, id=todo_id, created_by=request.user)
        todo.completed = not todo.completed
        todo.save()
        
        return JsonResponse({
            'success': True,
            'completed': todo.completed
        })
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


@login_required
@require_http_methods(["DELETE"])
def quick_todo_delete(request, todo_id):
    """API para eliminar una tarea rápida"""
    from .models import QuickTodo
    
    try:
        todo = get_object_or_404(QuickTodo, id=todo_id, created_by=request.user)
        todo.delete()
        
        return JsonResponse({'success': True})
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


@login_required
@require_http_methods(["DELETE"])
def quick_todo_clear_completed(request):
    """API para eliminar todas las tareas completadas del usuario"""
    from .models import QuickTodo
    
    try:
        deleted_count = QuickTodo.objects.filter(
            created_by=request.user, 
            completed=True
        ).delete()[0]
        
        return JsonResponse({
            'success': True,
            'deleted_count': deleted_count
        })
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


# Views para respaldo de base de datos
@login_required
@user_passes_test(lambda u: u.is_superuser)
def database_backup(request):
    """Vista para crear respaldos de la base de datos (compatible con SQLite y PostgreSQL)"""
    import os
    import shutil
    import zipfile
    import subprocess
    from datetime import datetime
    from django.conf import settings
    from django.db import connection
    
    backups = []
    backup_dir = os.path.join(settings.BASE_DIR, 'backups')
    
    # Crear directorio de respaldos si no existe
    if not os.path.exists(backup_dir):
        os.makedirs(backup_dir)
    
    # Detectar tipo de base de datos
    db_engine = settings.DATABASES['default']['ENGINE']
    is_sqlite = 'sqlite' in db_engine.lower()
    is_postgresql = 'postgresql' in db_engine.lower() or 'psycopg' in db_engine.lower()
    
    # Listar respaldos existentes
    if os.path.exists(backup_dir):
        for filename in os.listdir(backup_dir):
            if filename.endswith('.zip'):
                filepath = os.path.join(backup_dir, filename)
                try:
                    # Extraer fecha del nombre del archivo
                    date_str = filename.replace('backup_', '').replace('.zip', '')
                    backup_date = datetime.strptime(date_str, '%Y%m%d_%H%M%S')
                    file_size = os.path.getsize(filepath)
                    
                    backups.append({
                        'filename': filename,
                        'date': backup_date,
                        'size': file_size,
                        'size_mb': round(file_size / (1024 * 1024), 2)
                    })
                except:
                    pass
    
    # Ordenar por fecha descendente
    backups.sort(key=lambda x: x['date'], reverse=True)
    
    if request.method == 'POST':
        try:
            # Crear nombre de archivo con timestamp
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            backup_filename = f'backup_{timestamp}.zip'
            backup_path = os.path.join(backup_dir, backup_filename)
            
            # Crear el respaldo
            with zipfile.ZipFile(backup_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                
                if is_sqlite:
                    # Respaldo SQLite - copiar archivo directamente
                    db_path = settings.DATABASES['default']['NAME']
                    if os.path.exists(db_path):
                        zipf.write(db_path, 'database.sqlite3')
                        
                elif is_postgresql:
                    # Respaldo PostgreSQL - usar pg_dump
                    db_config = settings.DATABASES['default']
                    db_name = db_config['NAME']
                    db_user = db_config['USER']
                    db_host = db_config.get('HOST', 'localhost')
                    db_port = db_config.get('PORT', '5432')
                    db_password = db_config.get('PASSWORD', '')
                    
                    # Crear archivo temporal para el dump
                    temp_sql_path = os.path.join(backup_dir, f'temp_dump_{timestamp}.sql')
                    
                    # Preparar comando pg_dump
                    env = os.environ.copy()
                    if db_password:
                        env['PGPASSWORD'] = db_password
                    
                    cmd = [
                        'pg_dump',
                        '-h', db_host,
                        '-p', str(db_port),
                        '-U', db_user,
                        '-d', db_name,
                        '--no-password',
                        '-f', temp_sql_path
                    ]
                    
                    # Ejecutar pg_dump
                    result = subprocess.run(cmd, env=env, capture_output=True, text=True)
                    
                    if result.returncode == 0:
                        # Agregar el dump al ZIP
                        zipf.write(temp_sql_path, 'database.sql')
                        # Eliminar archivo temporal
                        os.remove(temp_sql_path)
                    else:
                        # Eliminar archivo temporal si existe
                        if os.path.exists(temp_sql_path):
                            os.remove(temp_sql_path)
                        raise Exception(f"Error en pg_dump: {result.stderr}")
                
                else:
                    raise Exception(f"Base de datos no soportada: {db_engine}")
                
                # Agregar archivos de media
                media_root = settings.MEDIA_ROOT
                if os.path.exists(media_root):
                    for root, dirs, files in os.walk(media_root):
                        for file in files:
                            file_path = os.path.join(root, file)
                            arc_path = os.path.relpath(file_path, settings.BASE_DIR)
                            zipf.write(file_path, arc_path)
            
            messages.success(request, f'Respaldo creado exitosamente: {backup_filename}')
            return redirect('database_backup')
            
        except Exception as e:
            messages.error(request, f'Error al crear respaldo: {str(e)}')
    
    context = {
        'backups': backups,
        'title': 'Respaldo de Base de Datos',
        'db_engine': db_engine,
        'is_sqlite': is_sqlite,
        'is_postgresql': is_postgresql
    }
    return render(request, 'tickets/database_backup.html', context)


@login_required
@user_passes_test(lambda u: u.is_superuser)
def database_restore(request):
    """Vista para restaurar respaldos de la base de datos (compatible con SQLite y PostgreSQL)"""
    import os
    import shutil
    import zipfile
    import subprocess
    from datetime import datetime
    from django.conf import settings
    from django.db import connection
    
    backups = []
    backup_dir = os.path.join(settings.BASE_DIR, 'backups')
    
    # Detectar tipo de base de datos
    db_engine = settings.DATABASES['default']['ENGINE']
    is_sqlite = 'sqlite' in db_engine.lower()
    is_postgresql = 'postgresql' in db_engine.lower() or 'psycopg' in db_engine.lower()
    
    # Listar respaldos disponibles
    if os.path.exists(backup_dir):
        for filename in os.listdir(backup_dir):
            if filename.endswith('.zip'):
                filepath = os.path.join(backup_dir, filename)
                try:
                    date_str = filename.replace('backup_', '').replace('.zip', '')
                    backup_date = datetime.strptime(date_str, '%Y%m%d_%H%M%S')
                    file_size = os.path.getsize(filepath)
                    
                    backups.append({
                        'filename': filename,
                        'date': backup_date,
                        'size': file_size,
                        'size_mb': round(file_size / (1024 * 1024), 2)
                    })
                except:
                    pass
    
    backups.sort(key=lambda x: x['date'], reverse=True)
    
    if request.method == 'POST':
        backup_filename = request.POST.get('backup_file')
        if not backup_filename:
            messages.error(request, 'Debe seleccionar un archivo de respaldo')
            return redirect('database_restore')
        
        backup_path = os.path.join(backup_dir, backup_filename)
        
        if not os.path.exists(backup_path):
            messages.error(request, 'El archivo de respaldo no existe')
            return redirect('database_restore')
        
        try:
            # Crear respaldo de la base de datos actual antes de restaurar
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            current_backup = f'backup_before_restore_{timestamp}.zip'
            current_backup_path = os.path.join(backup_dir, current_backup)
            
            # Crear respaldo de seguridad según el tipo de base de datos
            with zipfile.ZipFile(current_backup_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                if is_sqlite:
                    db_path = settings.DATABASES['default']['NAME']
                    if os.path.exists(db_path):
                        zipf.write(db_path, 'database.sqlite3')
                elif is_postgresql:
                    # Crear respaldo PostgreSQL de seguridad
                    db_config = settings.DATABASES['default']
                    temp_sql_path = os.path.join(backup_dir, f'temp_safety_dump_{timestamp}.sql')
                    
                    env = os.environ.copy()
                    if db_config.get('PASSWORD'):
                        env['PGPASSWORD'] = db_config['PASSWORD']
                    
                    cmd = [
                        'pg_dump',
                        '-h', db_config.get('HOST', 'localhost'),
                        '-p', str(db_config.get('PORT', '5432')),
                        '-U', db_config['USER'],
                        '-d', db_config['NAME'],
                        '--no-password',
                        '-f', temp_sql_path
                    ]
                    
                    result = subprocess.run(cmd, env=env, capture_output=True, text=True)
                    if result.returncode == 0:
                        zipf.write(temp_sql_path, 'database.sql')
                        os.remove(temp_sql_path)
                    else:
                        if os.path.exists(temp_sql_path):
                            os.remove(temp_sql_path)
                        raise Exception(f"Error creando respaldo de seguridad: {result.stderr}")
            
            # Restaurar desde el respaldo seleccionado
            with zipfile.ZipFile(backup_path, 'r') as zipf:
                temp_extract_dir = os.path.join(backup_dir, f'temp_restore_{timestamp}')
                os.makedirs(temp_extract_dir, exist_ok=True)
                
                try:
                    if is_sqlite:
                        # Restaurar SQLite
                        if 'database.sqlite3' in zipf.namelist():
                            zipf.extract('database.sqlite3', temp_extract_dir)
                            extracted_db = os.path.join(temp_extract_dir, 'database.sqlite3')
                            target_db = settings.DATABASES['default']['NAME']
                            shutil.copy2(extracted_db, target_db)
                        elif 'db.sqlite3' in zipf.namelist():  # Compatibilidad con formato anterior
                            zipf.extract('db.sqlite3', temp_extract_dir)
                            extracted_db = os.path.join(temp_extract_dir, 'db.sqlite3')
                            target_db = settings.DATABASES['default']['NAME']
                            shutil.copy2(extracted_db, target_db)
                        
                    elif is_postgresql:
                        # Restaurar PostgreSQL
                        sql_file = None
                        if 'database.sql' in zipf.namelist():
                            sql_file = 'database.sql'
                        
                        if sql_file:
                            zipf.extract(sql_file, temp_extract_dir)
                            extracted_sql = os.path.join(temp_extract_dir, sql_file)
                            
                            # Cerrar todas las conexiones existentes
                            connection.close()
                            
                            # Ejecutar restauración PostgreSQL
                            db_config = settings.DATABASES['default']
                            env = os.environ.copy()
                            if db_config.get('PASSWORD'):
                                env['PGPASSWORD'] = db_config['PASSWORD']
                            
                            # Primero dropear y recrear la base de datos
                            drop_cmd = [
                                'psql',
                                '-h', db_config.get('HOST', 'localhost'),
                                '-p', str(db_config.get('PORT', '5432')),
                                '-U', db_config['USER'],
                                '-d', 'postgres',  # Conectar a postgres para poder dropear la BD
                                '-c', f'DROP DATABASE IF EXISTS "{db_config["NAME"]}"; CREATE DATABASE "{db_config["NAME"]}";'
                            ]
                            
                            drop_result = subprocess.run(drop_cmd, env=env, capture_output=True, text=True)
                            if drop_result.returncode != 0:
                                raise Exception(f"Error recreando base de datos: {drop_result.stderr}")
                            
                            # Restaurar el dump
                            restore_cmd = [
                                'psql',
                                '-h', db_config.get('HOST', 'localhost'),
                                '-p', str(db_config.get('PORT', '5432')),
                                '-U', db_config['USER'],
                                '-d', db_config['NAME'],
                                '-f', extracted_sql
                            ]
                            
                            restore_result = subprocess.run(restore_cmd, env=env, capture_output=True, text=True)
                            if restore_result.returncode != 0:
                                raise Exception(f"Error restaurando base de datos: {restore_result.stderr}")
                    
                    # Restaurar archivos de media
                    for member in zipf.namelist():
                        if member.startswith('media/'):
                            zipf.extract(member, settings.BASE_DIR)
                    
                finally:
                    # Limpiar directorio temporal
                    if os.path.exists(temp_extract_dir):
                        shutil.rmtree(temp_extract_dir)
            
            messages.success(request, f'Base de datos restaurada exitosamente desde {backup_filename}')
            messages.info(request, f'Se creó un respaldo de seguridad en {current_backup}')
            
        except Exception as e:
            messages.error(request, f'Error al restaurar: {str(e)}')
        
        return redirect('database_restore')
    
    context = {
        'backups': backups,
        'title': 'Restaurar Base de Datos',
        'db_engine': db_engine,
        'is_sqlite': is_sqlite,
        'is_postgresql': is_postgresql
    }
    return render(request, 'tickets/database_restore.html', context)


@login_required
@user_passes_test(lambda u: u.is_superuser)
def download_backup(request, filename):
    """Vista para descargar archivos de respaldo"""
    import os
    from django.http import FileResponse, Http404
    from django.conf import settings
    
    backup_dir = os.path.join(settings.BASE_DIR, 'backups')
    backup_path = os.path.join(backup_dir, filename)
    
    if not os.path.exists(backup_path) or not filename.endswith('.zip'):
        raise Http404("Archivo de respaldo no encontrado")
    
    response = FileResponse(
        open(backup_path, 'rb'),
        as_attachment=True,
        filename=filename
    )
    response['Content-Type'] = 'application/zip'
    return response


@login_required
@user_passes_test(lambda u: u.is_superuser)
def delete_backup(request, filename):
    """Vista para eliminar archivos de respaldo"""
    import os
    from django.conf import settings
    
    if request.method == 'POST':
        backup_dir = os.path.join(settings.BASE_DIR, 'backups')
        backup_path = os.path.join(backup_dir, filename)
        
        if os.path.exists(backup_path) and filename.endswith('.zip'):
            try:
                os.remove(backup_path)
                messages.success(request, f'Respaldo {filename} eliminado exitosamente')
            except Exception as e:
                messages.error(request, f'Error al eliminar respaldo: {str(e)}')
        else:
            messages.error(request, 'Archivo de respaldo no encontrado')
    
    return redirect('database_backup')


# === VISTAS DE COTIZACIONES ===

@user_passes_test(is_agent, login_url='/')
@login_required
def quotation_list_view(request):
    """Vista para listar cotizaciones"""
    from .models import Quotation, SystemConfiguration
    
    # Obtener configuración del sistema para la moneda
    config = SystemConfiguration.get_config()
    currency_symbol = config.get_currency_symbol() if config else '€'
    
    quotations = Quotation.objects.all()
    
    # Filtros
    status = request.GET.get('status')
    if status:
        quotations = quotations.filter(status=status)
    
    company = request.GET.get('company')
    if company:
        quotations = quotations.filter(company_id=company)
    
    salesperson = request.GET.get('salesperson')
    if salesperson:
        quotations = quotations.filter(salesperson_id=salesperson)
    
    search = request.GET.get('search')
    if search:
        quotations = quotations.filter(
            models.Q(sequence__icontains=search) | 
            models.Q(company__name__icontains=search) |
            models.Q(salesperson__first_name__icontains=search) |
            models.Q(salesperson__last_name__icontains=search)
        )
    
    quotations = quotations.order_by('-created_at')
    
    # Estadísticas
    stats = {
        'total': Quotation.objects.count(),
        'draft': Quotation.objects.filter(status='draft').count(),
        'sent': Quotation.objects.filter(status='sent').count(),
        'approved': Quotation.objects.filter(status='approved').count(),
        'rejected': Quotation.objects.filter(status='rejected').count(),
    }
    
    # Calcular suma total de todas las cotizaciones mostradas
    total_amount = sum(quotation.get_total_amount() for quotation in quotations)
    stats['total_amount'] = total_amount
    
    # Para los filtros
    from .models import Company
    from django.contrib.auth.models import User
    companies = Company.objects.filter(is_active=True).order_by('name')
    salespeople = User.objects.filter(is_active=True).order_by('first_name', 'last_name')
    
    context = {
        'page_title': 'Cotizaciones',
        'quotations': quotations,
        'stats': stats,
        'companies': companies,
        'salespeople': salespeople,
        'current_status': status,
        'current_company': company,
        'current_salesperson': salesperson,
        'current_search': search,
        'currency_symbol': currency_symbol,
    }
    
    return render(request, 'tickets/quotation_list.html', context)


@user_passes_test(is_agent, login_url='/')
def quotation_create_view(request):
    """Vista para crear una nueva cotización"""
    from .models import Quotation, Company, Product
    from django.contrib.auth.models import User
    
    if request.method == 'POST':
        try:
            quotation = Quotation(
                company_id=request.POST.get('company'),
                salesperson_id=request.POST.get('salesperson'),
                date=request.POST.get('date'),
                status=request.POST.get('status', 'draft'),
                client_status=request.POST.get('client_status', 'pending'),
                description=request.POST.get('description', '')
            )
            
            # Manejar fecha de vencimiento
            expiry_date = request.POST.get('expiry_date')
            if expiry_date:
                quotation.expiry_date = expiry_date
            # Si no se proporciona, se calculará automáticamente en el método save()
            
            quotation.save()
            messages.success(request, f'Cotización {quotation.sequence} creada exitosamente')
            return redirect('quotation_list')
        except Exception as e:
            messages.error(request, f'Error al crear la cotización: {str(e)}')
    
    companies = Company.objects.filter(is_active=True).order_by('name')
    salespeople = User.objects.filter(is_active=True).order_by('first_name', 'last_name')
    products = Product.objects.filter(is_active=True).order_by('name')
    
    # Obtener configuración del sistema para la moneda
    from .models import SystemConfiguration
    config = SystemConfiguration.get_config()
    currency_symbol = config.get_currency_symbol() if config else '€'
    
    context = {
        'page_title': 'Nueva Cotización',
        'companies': companies,
        'salespeople': salespeople,
        'products': products,
        'today': timezone.now().date(),
        'currency_symbol': currency_symbol,
    }
    
    return render(request, 'tickets/quotation_form.html', context)


@user_passes_test(is_agent, login_url='/')
def quotation_detail_view(request, quotation_id):
    """Vista para ver detalles de una cotización"""
    from .models import Quotation, SystemConfiguration
    
    # Obtener configuración del sistema para la moneda
    config = SystemConfiguration.get_config()
    currency_symbol = config.get_currency_symbol() if config else '€'
    
    quotation = get_object_or_404(Quotation, id=quotation_id)
    
    context = {
        'page_title': f'Cotización {quotation.sequence}',
        'quotation': quotation,
        'currency_symbol': currency_symbol,
    }
    
    return render(request, 'tickets/quotation_detail.html', context)


@user_passes_test(is_agent, login_url='/')
def quotation_edit_view(request, quotation_id):
    """Vista para editar una cotización"""
    from .models import Quotation, Company, Product
    from django.contrib.auth.models import User
    
    quotation = get_object_or_404(Quotation, id=quotation_id)
    
    if request.method == 'POST':
        try:
            quotation.company_id = request.POST.get('company')
            quotation.salesperson_id = request.POST.get('salesperson')
            quotation.date = request.POST.get('date')
            quotation.status = request.POST.get('status')
            
            # Manejar fecha de vencimiento
            expiry_date = request.POST.get('expiry_date')
            if expiry_date:
                quotation.expiry_date = expiry_date
            else:
                # Si no se proporciona, se calculará automáticamente en el método save()
                quotation.expiry_date = None
            
            new_client_status = request.POST.get('client_status', 'pending')
            
            # Si se cambia a 'pending', limpiar datos de respuesta anterior para permitir nueva respuesta
            if new_client_status == 'pending' and quotation.client_status != 'pending':
                quotation.client_response_name = ''
                quotation.client_response_email = ''
                quotation.client_response_comments = ''
                quotation.client_response_date = None
                messages.info(request, f'Estado del cliente cambiado a "Pendiente". Se habilitó nuevamente la respuesta pública.')
            
            quotation.client_status = new_client_status
            quotation.description = request.POST.get('description', '')
            
            # Manejar fechas de servicio
            service_start_date = request.POST.get('service_start_date')
            service_end_date = request.POST.get('service_end_date')
            
            if service_start_date:
                quotation.service_start_date = service_start_date
            else:
                quotation.service_start_date = None
                
            if service_end_date:
                quotation.service_end_date = service_end_date
            else:
                quotation.service_end_date = None
            
            quotation.save()
            
            # Mensaje especial cuando se aprueba
            if quotation.status == 'approved':
                messages.success(request, f'¡Excelente! La cotización {quotation.sequence} ha sido APROBADA exitosamente 🎉')
            else:
                messages.success(request, f'Cotización {quotation.sequence} actualizada exitosamente')
                
            return redirect('quotation_detail', quotation_id=quotation.id)
        except Exception as e:
            messages.error(request, f'Error al actualizar la cotización: {str(e)}')
    
    companies = Company.objects.filter(is_active=True).order_by('name')
    salespeople = User.objects.filter(is_active=True).order_by('first_name', 'last_name')
    products = Product.objects.filter(is_active=True).order_by('name')
    
    # Obtener configuración del sistema para la moneda
    from .models import SystemConfiguration
    config = SystemConfiguration.get_config()
    currency_symbol = config.get_currency_symbol() if config else '€'
    
    context = {
        'page_title': f'Editar Cotización {quotation.sequence}',
        'quotation': quotation,
        'companies': companies,
        'salespeople': salespeople,
        'products': products,
        'currency_symbol': currency_symbol,
    }
    
    return render(request, 'tickets/quotation_form.html', context)


@user_passes_test(is_agent, login_url='/')
def quotation_duplicate_view(request, quotation_id):
    """Vista para duplicar una cotización"""
    from .models import Quotation, QuotationLine
    from django.utils import timezone
    
    # Obtener la cotización original
    original_quotation = get_object_or_404(Quotation, id=quotation_id)
    
    try:
        # Crear una nueva cotización duplicada
        new_quotation = Quotation(
            company=original_quotation.company,
            salesperson=original_quotation.salesperson,
            date=timezone.now().date(),  # Fecha actual
            status='draft',  # Siempre empezar como borrador
            client_status='pending',  # Estado del cliente pendiente
            description=f"Duplicada de {original_quotation.sequence} - {original_quotation.description}"
        )
        new_quotation.save()  # Esto generará automáticamente la secuencia
        
        # Duplicar todas las líneas de la cotización original
        original_lines = original_quotation.lines.all()
        for line in original_lines:
            QuotationLine.objects.create(
                quotation=new_quotation,
                product=line.product,
                quantity=line.quantity,
                unit_price=line.unit_price,
                discount_percentage=line.discount_percentage,
                description=line.description
            )
        
        messages.success(
            request, 
            f'Cotización duplicada exitosamente. Nueva cotización: {new_quotation.sequence}'
        )
        
        # Redirigir a la edición de la nueva cotización
        return redirect('quotation_edit', quotation_id=new_quotation.id)
        
    except Exception as e:
        messages.error(request, f'Error al duplicar la cotización: {str(e)}')
        return redirect('quotation_detail', quotation_id=quotation_id)


@user_passes_test(is_agent, login_url='/')
def quotation_delete_view(request, quotation_id):
    """Vista para eliminar una cotización"""
    from .models import Quotation
    
    quotation = get_object_or_404(Quotation, id=quotation_id)
    
    if request.method == 'POST':
        sequence = quotation.sequence
        quotation.delete()
        messages.success(request, f'Cotización {sequence} eliminada exitosamente')
        return redirect('quotation_list')
    
    context = {
        'page_title': f'Eliminar Cotización {quotation.sequence}',
        'quotation': quotation,
    }
    
    return render(request, 'tickets/quotation_delete.html', context)


@user_passes_test(is_agent, login_url='/')
@user_passes_test(is_agent, login_url='/')
def quotation_add_line_view(request, quotation_id):
    """Vista AJAX para agregar línea a cotización"""
    from .models import Quotation, QuotationLine, Product
    from django.http import JsonResponse
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'message': 'Método no permitido'})
    
    try:
        quotation = get_object_or_404(Quotation, id=quotation_id)
        product_id = request.POST.get('product_id')
        quantity = request.POST.get('quantity', 1)
        unit_price = request.POST.get('unit_price')
        discount_percentage = request.POST.get('discount_percentage', 0)
        description = request.POST.get('description', '')
        
        product = get_object_or_404(Product, id=product_id)
        
        # Si no se proporciona precio unitario, usar el del producto
        if not unit_price:
            unit_price = product.price
        
        line = QuotationLine.objects.create(
            quotation=quotation,
            product=product,
            quantity=float(quantity),
            unit_price=float(unit_price),
            discount_percentage=float(discount_percentage),
            description=description
        )
        
        return JsonResponse({
            'success': True,
            'line': {
                'id': line.id,
                'product_name': line.product.name,
                'quantity': float(line.quantity),
                'unit_price': float(line.unit_price),
                'discount_percentage': float(line.discount_percentage),
                'subtotal': float(line.get_subtotal()),
                'discount_amount': float(line.get_discount_amount()),
                'total': float(line.get_total()),
                'description': line.description,
            },
            'quotation_total': float(quotation.get_total_amount())
        })
        
    except Exception as e:
        return JsonResponse({'success': False, 'message': str(e)})


@user_passes_test(is_agent, login_url='/')
def quotation_remove_line_view(request, quotation_id, line_id):
    """Vista AJAX para remover línea de cotización"""
    from .models import Quotation, QuotationLine
    from django.http import JsonResponse
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'message': 'Método no permitido'})
    
    try:
        quotation = get_object_or_404(Quotation, id=quotation_id)
        line = get_object_or_404(QuotationLine, id=line_id, quotation=quotation)
        
        line.delete()
        
        return JsonResponse({
            'success': True,
            'quotation_total': float(quotation.get_total_amount())
        })
        
    except Exception as e:
        return JsonResponse({'success': False, 'message': str(e)})


@login_required
def quotation_pdf_view(request, quotation_id):
    """Vista para generar PDF de cotización"""
    from .models import Quotation, SystemConfiguration
    
    quotation = get_object_or_404(Quotation, id=quotation_id)
    
    # Crear el objeto response con content type PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="cotizacion_{quotation.sequence}.pdf"'
    
    # Crear el buffer
    buffer = BytesIO()
    
    # Crear el documento PDF
    doc = SimpleDocTemplate(buffer, pagesize=A4,
                           rightMargin=72, leftMargin=72,
                           topMargin=72, bottomMargin=18)
    
    # Crear lista de elementos para el PDF
    elements = []
    
    # Obtener estilos
    styles = getSampleStyleSheet()
    
    # Estilo personalizado para el encabezado
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=18,
        textColor=colors.darkblue,
        alignment=1,  # Center
        spaceAfter=20
    )
    
    # Estilo para información de empresa
    company_style = ParagraphStyle(
        'Company',
        parent=styles['Normal'],
        fontSize=10,
        alignment=2,  # Right
    )
    
    # Información de la empresa emisora (parte superior derecha)
    company_info = """
    <b>Manufactura y Servicios TACA</b><br/>
    CALLE 2DA TRANS LOCAL 22 ZONA<br/>
    INDUSTRIAL 2<br/>
    ACARIGUA PORTUGUESA ZONA POSTAL<br/>
    3301<br/><br/>
    Venezuela<br/>
    NIF: V-14.677.128
    """
    elements.append(Paragraph(company_info, company_style))
    elements.append(Spacer(1, 20))
    
    # Información del cliente (parte inferior izquierda) 
    client_info = f"""
    <b>{quotation.company.name}</b><br/>
    {quotation.company.address or ''}<br/>
    {quotation.company.phone or ''}<br/>
    {quotation.company.email or ''}
    """
    
    client_style = ParagraphStyle(
        'Client',
        parent=styles['Normal'],
        fontSize=10,
        alignment=0,  # Left
    )
    elements.append(Paragraph(client_info, client_style))
    elements.append(Spacer(1, 30))
    
    # Título del documento
    elements.append(Paragraph(f'Pedido # {quotation.sequence}', title_style))
    
    # Información del pedido
    order_data = [
        ['Fecha orden:', quotation.date.strftime('%d/%m/%Y %H:%M:%S')],
        ['Comercial:', quotation.salesperson.get_full_name() or quotation.salesperson.username],
    ]
    
    order_table = Table(order_data, colWidths=[2*inch, 3*inch])
    order_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
        ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
    ]))
    elements.append(order_table)
    elements.append(Spacer(1, 20))
    
    # Tabla de productos
    lines = quotation.lines.all()
    table_data = [['Descripción', 'Cantidad', 'Precio unitario', 'Impuestos', 'Importe']]
    
    # Obtener configuración del sistema para la moneda
    config = SystemConfiguration.get_config()
    currency_symbol = config.get_currency_symbol()
    
    for line in lines:
        table_data.append([
            line.description or line.product.name,
            f'{line.quantity:,.0f}',
            f'{line.unit_price:,.2f}',
            '',  # Impuestos vacío por ahora
            f'{line.get_total():,.2f} {currency_symbol}'
        ])
    
    # Crear la tabla
    product_table = Table(table_data, colWidths=[3*inch, 1*inch, 1.2*inch, 1*inch, 1.2*inch])
    product_table.setStyle(TableStyle([
        # Encabezado
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 10),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        
        # Contenido
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 1), (-1, -1), 9),
        ('ALIGN', (0, 1), (0, -1), 'LEFT'),  # Descripción alineada a la izquierda
        ('ALIGN', (1, 1), (-1, -1), 'RIGHT'), # Números alineados a la derecha
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.beige, colors.white]),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
    ]))
    elements.append(product_table)
    elements.append(Spacer(1, 20))
    
    # Totales
    total_amount = quotation.get_total_amount()
    totals_data = [
        ['', '', '', 'Subtotal', f'{total_amount:,.2f} {currency_symbol}'],
        ['', '', '', 'Total', f'{total_amount:,.2f} {currency_symbol}']
    ]
    
    totals_table = Table(totals_data, colWidths=[3*inch, 1*inch, 1.2*inch, 1*inch, 1.2*inch])
    totals_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'RIGHT'),
        ('FONTNAME', (3, 0), (3, -1), 'Helvetica-Bold'),
        ('FONTNAME', (4, 0), (4, -1), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('LINEBELOW', (3, -1), (4, -1), 2, colors.black),
    ]))
    elements.append(totals_table)
    elements.append(Spacer(1, 40))
    
    # Información de pago y QR code
    payment_info = """
    <b>Forma Trabajo</b><br/><br/>
    
    <b>Datos Pago</b><br/>
    Banco: CAJAMAR ( https://www.cajamar.es )<br/>
    Nombre del Beneficiario: Marlon Falcon Hernandez<br/>
    Dirección Beneficiario: Valencia, España<br/>
    Numero de Cuenta Bancaria: ES84 3058 2214 0427 2001 3741<br/>
    BIC ( SWIFT ): CCRIES2AXXX<br/><br/>
    • mfalconsoft@gmail.com<br/>
    • www.marlonfalcon.com<br/><br/>
    - Cubre cualquier error del sistema.<br/>
    - El valor es por mes.<br/>
    - Se paga trimestral o semestral.<br/>
    - Incluye 1 horas de desarrollo al mes que se puede hacer en reunión.
    """
    
    # Crear una tabla con dos columnas: una para el QR (vacío por ahora) y otra para la información de pago
    payment_table_data = [
        ['[QR CODE PLACEHOLDER]', payment_info]
    ]
    
    payment_table = Table(payment_table_data, colWidths=[2*inch, 4*inch])
    payment_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (0, 0), 'CENTER'),
        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
        ('FONTNAME', (1, 0), (1, 0), 'Helvetica'),
        ('FONTSIZE', (1, 0), (1, 0), 9),
    ]))
    elements.append(payment_table)
    
    # Construir el PDF
    doc.build(elements)
    
    # Obtener el valor del buffer y cerrarlo
    pdf = buffer.getvalue()
    buffer.close()
    response.write(pdf)
    
    return response


@login_required 
def quotation_share_view(request, quotation_id):
    """Vista para generar y compartir enlace público de cotización"""
    from .models import Quotation
    
    quotation = get_object_or_404(Quotation, id=quotation_id)
    
    if request.method == 'POST':
        # Generar token si no existe
        token = quotation.generate_public_token()
        public_url = quotation.get_public_url(request)
        
        return JsonResponse({
            'success': True,
            'public_url': public_url,
            'token': token
        })
    
    # Si es GET, mostrar modal o redirigir
    return redirect('quotation_detail', quotation_id=quotation_id)


def quotation_public_view(request, token):
    """Vista pública para mostrar cotización sin autenticación"""
    from .models import Quotation, SystemConfiguration
    
    try:
        quotation = get_object_or_404(Quotation, public_token=token)
        
        # Obtener configuración del sistema para la moneda
        config = SystemConfiguration.get_config()
        currency_symbol = config.get_currency_symbol()
        
        context = {
            'quotation': quotation,
            'currency_symbol': currency_symbol,
            'can_respond': quotation.can_be_responded(),
        }
        
        return render(request, 'tickets/quotation_public_view.html', context)
        
    except Exception as e:
        return render(request, 'tickets/quotation_public_error.html', {
            'error': 'Cotización no encontrada o enlace inválido.'
        })


def quotation_public_respond_view(request, token):
    """Vista pública para que el cliente acepte o rechace la cotización"""
    from .models import Quotation
    from django.utils import timezone
    
    if request.method == 'POST':
        try:
            quotation = get_object_or_404(Quotation, public_token=token)
            
            if not quotation.can_be_responded():
                return JsonResponse({
                    'success': False, 
                    'message': 'Esta cotización ya no puede ser modificada.'
                })
            
            action = request.POST.get('action')  # 'accept' o 'reject'
            client_name = request.POST.get('client_name', '')
            client_email = request.POST.get('client_email', '')
            comments = request.POST.get('comments', '')
            
            # Registrar información del cliente
            quotation.client_response_name = client_name
            quotation.client_response_email = client_email
            quotation.client_response_comments = comments
            quotation.client_response_date = timezone.now()
            
            if action == 'accept':
                quotation.client_status = 'accepted'
                quotation.status = 'approved'  # También actualizar el estado interno
                message = f"Cotización aceptada por {client_name}"
            elif action == 'reject':
                quotation.client_status = 'rejected'
                quotation.status = 'rejected'  # También actualizar el estado interno
                message = f"Cotización rechazada por {client_name}"
            else:
                return JsonResponse({
                    'success': False,
                    'message': 'Acción no válida.'
                })
            
            quotation.save()
            
            # Aquí podrías agregar lógica para enviar notificaciones por email
            # o crear un registro de la respuesta del cliente
            
            return JsonResponse({
                'success': True,
                'message': message,
                'new_status': quotation.get_status_display(),
                'client_status': quotation.get_client_status_display()
            })
            
        except Exception as e:
            return JsonResponse({
                'success': False,
                'message': f'Error al procesar la respuesta: {str(e)}'
            })
    
    return JsonResponse({'success': False, 'message': 'Método no permitido.'})


@user_passes_test(is_agent, login_url='/')
def quotation_edit_line_view(request, quotation_id, line_id):
    """Vista AJAX para editar línea de cotización"""
    from .models import Quotation, QuotationLine
    from django.http import JsonResponse
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'message': 'Método no permitido'})
    
    try:
        quotation = get_object_or_404(Quotation, id=quotation_id)
        line = get_object_or_404(QuotationLine, id=line_id, quotation=quotation)
        
        # Actualizar los campos de la línea
        quantity = request.POST.get('quantity')
        unit_price = request.POST.get('unit_price')
        discount_percentage = request.POST.get('discount_percentage')
        description = request.POST.get('description', '')
        
        if quantity:
            line.quantity = float(quantity)
        if unit_price:
            line.unit_price = float(unit_price)
        if discount_percentage:
            line.discount_percentage = float(discount_percentage)
        
        line.description = description
        line.save()
        
        return JsonResponse({
            'success': True,
            'line': {
                'id': line.id,
                'product_name': line.product.name,
                'quantity': float(line.quantity),
                'unit_price': float(line.unit_price),
                'discount_percentage': float(line.discount_percentage),
                'subtotal': float(line.get_subtotal()),
                'discount_amount': float(line.get_discount_amount()),
                'total': float(line.get_total()),
                'description': line.description,
            },
            'quotation_total': float(quotation.get_total_amount())
        })
        
    except Exception as e:
        return JsonResponse({'success': False, 'message': str(e)})


@user_passes_test(is_agent, login_url='/')
def quotation_get_lines_view(request, quotation_id):
    """Vista AJAX para obtener líneas de una cotización"""
    from .models import Quotation
    from django.http import JsonResponse
    
    try:
        quotation = get_object_or_404(Quotation, id=quotation_id)
        
        lines = []
        for line in quotation.lines.all():
            lines.append({
                'id': line.id,
                'product_name': line.product.name,
                'quantity': float(line.quantity),
                'unit_price': float(line.unit_price),
                'discount_percentage': float(line.discount_percentage),
                'subtotal': float(line.get_subtotal()),
                'discount_amount': float(line.get_discount_amount()),
                'total': float(line.get_total()),
                'description': line.description,
            })
        
        return JsonResponse({
            'success': True,
            'lines': lines,
            'quotation_total': float(quotation.get_total_amount())
        })
        
    except Exception as e:
        return JsonResponse({'success': False, 'message': str(e)})


@user_passes_test(is_agent, login_url='/')
def get_products_ajax_view(request):
    """Vista AJAX para obtener productos"""
    from .models import Product
    from django.http import JsonResponse
    
    try:
        search = request.GET.get('search', '')
        products = Product.objects.filter(is_active=True)
        
        if search:
            products = products.filter(
                models.Q(name__icontains=search) |
                models.Q(description__icontains=search)
            )
        
        products = products.order_by('name')[:20]  # Limitar a 20 resultados
        
        product_list = []
        for product in products:
            product_list.append({
                'id': product.id,
                'name': product.name,
                'price': float(product.price),
                'description': product.description[:100] + '...' if len(product.description) > 100 else product.description
            })
        
        return JsonResponse({
            'success': True,
            'products': product_list
        })
        
    except Exception as e:
        return JsonResponse({'success': False, 'message': str(e)})


# =================================
# VISTAS PARA PLANTILLAS PÚBLICAS
# =================================

@user_passes_test(is_agent, login_url='/')
@user_passes_test(is_agent, login_url='/')
def quotation_template_create_new_view(request):
    """Vista para crear una nueva plantilla desde cero"""
    from .models import QuotationTemplate, Quotation
    from django.contrib import messages
    
    if request.method == 'POST':
        title = request.POST.get('title')
        description = request.POST.get('description', '')
        quotation_id = request.POST.get('quotation_id')
        
        if not title:
            messages.error(request, 'El título es obligatorio.')
        elif not quotation_id:
            messages.error(request, 'Debes seleccionar una cotización base.')
        else:
            try:
                quotation = Quotation.objects.get(id=quotation_id)
                
                # Crear la plantilla
                template = QuotationTemplate.objects.create(
                    title=title,
                    description=description,
                    template_quotation=quotation,
                    created_by=request.user,
                    is_active=True
                )
                
                messages.success(request, f'Plantilla "{title}" creada exitosamente.')
                return redirect('quotation_template_detail', template_id=template.id)
                
            except Quotation.DoesNotExist:
                messages.error(request, 'La cotización seleccionada no existe.')
    
    # Obtener cotizaciones disponibles para usar como plantilla
    quotations = Quotation.objects.select_related('company').filter(
        status__in=['sent', 'approved']  # Solo cotizaciones enviadas o aprobadas
    ).order_by('-created_at')[:50]  # Últimas 50
    
    context = {
        'page_title': 'Crear Nueva Plantilla',
        'quotations': quotations,
    }
    
    return render(request, 'tickets/quotation_template_create_new.html', context)


@user_passes_test(is_agent, login_url='/')
def quotation_template_edit_view(request, template_id):
    """Vista para editar una plantilla existente"""
    from .models import QuotationTemplate, Quotation
    from django.contrib import messages
    
    template = get_object_or_404(QuotationTemplate, id=template_id)
    
    if request.method == 'POST':
        title = request.POST.get('title')
        description = request.POST.get('description', '')
        quotation_id = request.POST.get('quotation_id')
        is_active = request.POST.get('is_active') == 'on'
        
        if not title:
            messages.error(request, 'El título es obligatorio.')
        elif not quotation_id:
            messages.error(request, 'Debes seleccionar una cotización base.')
        else:
            try:
                quotation = Quotation.objects.get(id=quotation_id)
                
                # Actualizar la plantilla
                template.title = title
                template.description = description
                template.template_quotation = quotation
                template.is_active = is_active
                template.save()
                
                messages.success(request, f'Plantilla "{title}" actualizada exitosamente.')
                return redirect('quotation_template_detail', template_id=template.id)
                
            except Quotation.DoesNotExist:
                messages.error(request, 'La cotización seleccionada no existe.')
    
    # Obtener cotizaciones disponibles para usar como plantilla
    quotations = Quotation.objects.select_related('company').filter(
        status__in=['sent', 'approved']  # Solo cotizaciones enviadas o aprobadas
    ).order_by('-created_at')[:50]  # Últimas 50
    
    context = {
        'page_title': f'Editar Plantilla: {template.title}',
        'template': template,
        'quotations': quotations,
    }
    
    return render(request, 'tickets/quotation_template_edit.html', context)


@user_passes_test(is_agent, login_url='/')
def quotation_template_delete_view(request, template_id):
    """Vista para eliminar una plantilla"""
    from .models import QuotationTemplate
    from django.contrib import messages
    
    template = get_object_or_404(QuotationTemplate, id=template_id)
    
    if request.method == 'POST':
        template_title = template.title
        template.delete()
        messages.success(request, f'Plantilla "{template_title}" eliminada exitosamente.')
        return redirect('quotation_template_list')
    
    # Si no es POST, redirigir a la lista
    return redirect('quotation_template_list')


@user_passes_test(is_agent, login_url='/')
def quotation_template_create_view(request, quotation_id):
    """Vista para crear una plantilla pública desde una cotización"""
    from .models import Quotation, QuotationTemplate
    
    quotation = get_object_or_404(Quotation, id=quotation_id)
    
    if request.method == 'POST':
        try:
            template = QuotationTemplate.objects.create(
                template_quotation=quotation,
                title=request.POST.get('title'),
                description=request.POST.get('description', ''),
                created_by=request.user
            )
            
            messages.success(request, f'Plantilla pública creada exitosamente. Token: {template.public_token}')
            return redirect('quotation_template_detail', template_id=template.id)
        except Exception as e:
            messages.error(request, f'Error al crear la plantilla: {str(e)}')
    
    # Obtener configuración del sistema para la moneda
    from .models import SystemConfiguration
    config = SystemConfiguration.get_config()
    currency_symbol = config.get_currency_symbol() if config else '€'
    
    context = {
        'page_title': f'Crear Plantilla Pública - {quotation.sequence}',
        'quotation': quotation,
        'currency_symbol': currency_symbol,
    }
    
    return render(request, 'tickets/quotation_template_create.html', context)


@user_passes_test(is_agent, login_url='/')
def quotation_template_list_view(request):
    """Vista para listar todas las plantillas públicas"""
    from .models import QuotationTemplate
    
    templates = QuotationTemplate.objects.select_related(
        'template_quotation', 'created_by'
    ).order_by('-created_at')
    
    # Filtros opcionales
    if request.GET.get('active_only'):
        templates = templates.filter(is_active=True)
    
    # Calcular porcentajes de conversión y URLs públicas
    for template in templates:
        if template.views_count > 0:
            template.conversion_rate = round((template.conversions_count * 100) / template.views_count, 1)
        else:
            template.conversion_rate = 0
        # Agregar URL pública completa
        template.public_url_full = request.build_absolute_uri(template.get_public_url())
    
    context = {
        'page_title': 'Plantillas Públicas',
        'templates': templates,
    }
    
    return render(request, 'tickets/quotation_template_list.html', context)


@user_passes_test(is_agent, login_url='/')
def quotation_template_detail_view(request, template_id):
    """Vista para ver detalles de una plantilla pública"""
    from .models import QuotationTemplate
    
    template = get_object_or_404(QuotationTemplate, id=template_id)
    
    # Calcular porcentaje de conversión
    if template.views_count > 0:
        template.conversion_rate = round((template.conversions_count * 100) / template.views_count, 1)
    else:
        template.conversion_rate = 0
    
    # Obtener solicitudes recientes
    recent_requests = template.requests.select_related(
        'generated_quotation'
    ).order_by('-created_at')[:10]
    
    # Obtener configuración del sistema para la moneda
    from .models import SystemConfiguration
    config = SystemConfiguration.get_config()
    currency_symbol = config.get_currency_symbol() if config else '€'
    
    context = {
        'page_title': f'Plantilla: {template.title}',
        'template': template,
        'recent_requests': recent_requests,
        'currency_symbol': currency_symbol,
        'public_url': request.build_absolute_uri(template.get_public_url()),
    }
    
    return render(request, 'tickets/quotation_template_detail.html', context)


def quotation_template_public_form_view(request, token):
    """Vista pública para que el cliente llene sus datos"""
    from .models import QuotationTemplate, QuotationTemplateRequest
    
    try:
        template = QuotationTemplate.objects.select_related(
            'template_quotation', 'template_quotation__company'
        ).get(public_token=token, is_active=True)
    except QuotationTemplate.DoesNotExist:
        return render(request, 'tickets/quotation_template_error.html', {
            'error_message': 'El enlace que está intentando acceder no existe o ha expirado.'
        })
    
    # Incrementar contador de vistas
    template.increment_views()
    
    if request.method == 'POST':
        try:
            # Crear la solicitud
            template_request = QuotationTemplateRequest.objects.create(
                template=template,
                client_name=request.POST.get('client_name'),
                client_email=request.POST.get('client_email'),
                client_phone=request.POST.get('client_phone', ''),
                client_company=request.POST.get('client_company', ''),
                client_comments=request.POST.get('client_comments', '')
            )
            
            # Procesar automáticamente la solicitud
            # Usar el vendedor de la cotización plantilla
            salesperson = template.template_quotation.salesperson
            new_quotation = template_request.process_request(salesperson)
            
            # Redirigir a la vista pública de la nueva cotización
            return redirect('quotation_public_view', token=new_quotation.public_token)
            
        except Exception as e:
            messages.error(request, f'Error al procesar su solicitud: {str(e)}')
    
    # Obtener configuración del sistema para la moneda
    from .models import SystemConfiguration
    config = SystemConfiguration.get_config()
    currency_symbol = config.get_currency_symbol() if config else '€'
    
    context = {
        'template': template,
        'currency_symbol': currency_symbol,
    }
    
    return render(request, 'tickets/quotation_template_public_form.html', context)


@user_passes_test(is_agent, login_url='/')
def quotation_template_toggle_active_view(request, template_id):
    """Vista para activar/desactivar una plantilla"""
    from .models import QuotationTemplate
    
    if request.method == 'POST':
        template = get_object_or_404(QuotationTemplate, id=template_id)
        template.is_active = not template.is_active
        template.save()
        
        status = "activada" if template.is_active else "desactivada"
        messages.success(request, f'Plantilla {status} exitosamente')
    
    return redirect('quotation_template_detail', template_id=template_id)


@user_passes_test(is_agent, login_url='/')
def quotation_template_requests_view(request):
    """Vista para ver todas las solicitudes de plantillas"""
    from .models import QuotationTemplateRequest, QuotationTemplate
    from django.core.paginator import Paginator
    from django.db.models import Q
    from datetime import datetime
    
    # Obtener todas las solicitudes
    requests = QuotationTemplateRequest.objects.select_related(
        'template', 'template__template_quotation', 'generated_quotation', 
        'generated_quotation__company'
    ).order_by('-created_at')
    
    # Filtros
    template_filter = request.GET.get('template')
    status_filter = request.GET.get('status')
    date_from = request.GET.get('date_from')
    date_to = request.GET.get('date_to')
    
    if template_filter:
        requests = requests.filter(template_id=template_filter)
    
    if status_filter == 'processed':
        requests = requests.filter(status__in=['processed', 'quoted'])
    elif status_filter == 'pending':
        requests = requests.filter(status='pending')
    
    if date_from:
        try:
            date_from_obj = datetime.strptime(date_from, '%Y-%m-%d').date()
            requests = requests.filter(created_at__date__gte=date_from_obj)
        except ValueError:
            pass
    
    if date_to:
        try:
            date_to_obj = datetime.strptime(date_to, '%Y-%m-%d').date()
            requests = requests.filter(created_at__date__lte=date_to_obj)
        except ValueError:
            pass
    
    # Paginación
    paginator = Paginator(requests, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Estadísticas
    all_requests = QuotationTemplateRequest.objects.all()
    total_requests = all_requests.count()
    processed_requests = all_requests.filter(status__in=['processed', 'quoted']).count()
    pending_requests = total_requests - processed_requests
    
    conversion_rate = 0
    if total_requests > 0:
        conversion_rate = round((processed_requests * 100) / total_requests, 1)
    
    # Plantillas para filtro
    templates_for_filter = QuotationTemplate.objects.select_related(
        'template_quotation'
    ).order_by('title')
    
    context = {
        'page_title': 'Solicitudes de Plantillas',
        'requests': page_obj,
        'templates_for_filter': templates_for_filter,
        'total_requests': total_requests,
        'processed_requests': processed_requests,
        'pending_requests': pending_requests,
        'conversion_rate': conversion_rate,
        'is_paginated': page_obj.has_other_pages(),
        'page_obj': page_obj,
    }
    
    return render(request, 'tickets/quotation_template_requests.html', context)